module Net
  # :stopdoc:
  class HTTPBadResponse < StandardError
  end

  class HTTPHeaderSyntaxError < StandardError
  end

  # == An HTTP client API for Ruby.
  #
  # Net::HTTP provides a rich library which can be used to build HTTP
  # user-agents.  For more details about HTTP see
  # [RFC2616](http://www.ietf.org/rfc/rfc2616.txt).
  #
  # Net::HTTP is designed to work closely with URI.  URI::HTTP#host,
  # URI::HTTP#port and URI::HTTP#request_uri are designed to work with
  # Net::HTTP.
  #
  # If you are only performing a few GET requests you should try OpenURI.
  #
  # == Simple Examples
  #
  # All examples assume you have loaded Net::HTTP with:
  #
  #   require 'net/http'
  #
  # This will also require 'uri' so you don't need to require it separately.
  #
  # The Net::HTTP methods in the following section do not persist
  # connections.  They are not recommended if you are performing many HTTP
  # requests.
  #
  # === GET
  #
  #   Net::HTTP.get('example.com', '/index.html') # => String
  #
  # === GET by URI
  #
  #   uri = URI('http://example.com/index.html?count=10')
  #   Net::HTTP.get(uri) # => String
  #
  # === GET with Dynamic Parameters
  #
  #   uri = URI('http://example.com/index.html')
  #   params = { :limit => 10, :page => 3 }
  #   uri.query = URI.encode_www_form(params)
  #
  #   res = Net::HTTP.get_response(uri)
  #   puts res.body if res.is_a?(Net::HTTPSuccess)
  #
  # === POST
  #
  #   uri = URI('http://www.example.com/search.cgi')
  #   res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
  #   puts res.body
  #
  # === POST with Multiple Values
  #
  #   uri = URI('http://www.example.com/search.cgi')
  #   res = Net::HTTP.post_form(uri, 'q' => ['ruby', 'perl'], 'max' => '50')
  #   puts res.body
  #
  # == How to use Net::HTTP
  #
  # The following example code can be used as the basis of an HTTP user-agent
  # which can perform a variety of request types using persistent
  # connections.
  #
  #   uri = URI('http://example.com/some_path?query=string')
  #
  #   Net::HTTP.start(uri.host, uri.port) do |http|
  #     request = Net::HTTP::Get.new uri
  #
  #     response = http.request request # Net::HTTPResponse object
  #   end
  #
  # Net::HTTP::start immediately creates a connection to an HTTP server which
  # is kept open for the duration of the block.  The connection will remain
  # open for multiple requests in the block if the server indicates it
  # supports persistent connections.
  #
  # If you wish to re-use a connection across multiple HTTP requests without
  # automatically closing it you can use ::new and then call #start and
  # #finish manually.
  #
  # The request types Net::HTTP supports are listed below in the section "HTTP
  # Request Classes".
  #
  # For all the Net::HTTP request objects and shortcut request methods you may
  # supply either a String for the request path or a URI from which Net::HTTP
  # will extract the request path.
  #
  # === Response Data
  #
  #   uri = URI('http://example.com/index.html')
  #   res = Net::HTTP.get_response(uri)
  #
  #   # Headers
  #   res['Set-Cookie']            # => String
  #   res.get_fields('set-cookie') # => Array
  #   res.to_hash['set-cookie']    # => Array
  #   puts "Headers: #{res.to_hash.inspect}"
  #
  #   # Status
  #   puts res.code       # => '200'
  #   puts res.message    # => 'OK'
  #   puts res.class.name # => 'HTTPOK'
  #
  #   # Body
  #   puts res.body if res.response_body_permitted?
  #
  # === Following Redirection
  #
  # Each Net::HTTPResponse object belongs to a class for its response code.
  #
  # For example, all 2XX responses are instances of a Net::HTTPSuccess
  # subclass, a 3XX response is an instance of a Net::HTTPRedirection
  # subclass and a 200 response is an instance of the Net::HTTPOK class.  For
  # details of response classes, see the section "HTTP Response Classes"
  # below.
  #
  # Using a case statement you can handle various types of responses properly:
  #
  #   def fetch(uri_str, limit = 10)
  #     # You should choose a better exception.
  #     raise ArgumentError, 'too many HTTP redirects' if limit == 0
  #
  #     response = Net::HTTP.get_response(URI(uri_str))
  #
  #     case response
  #     when Net::HTTPSuccess then
  #       response
  #     when Net::HTTPRedirection then
  #       location = response['location']
  #       warn "redirected to #{location}"
  #       fetch(location, limit - 1)
  #     else
  #       response.value
  #     end
  #   end
  #
  #   print fetch('http://www.ruby-lang.org')
  #
  # === POST
  #
  # A POST can be made using the Net::HTTP::Post request class.  This example
  # creates a URL encoded POST body:
  #
  #   uri = URI('http://www.example.com/todo.cgi')
  #   req = Net::HTTP::Post.new(uri)
  #   req.set_form_data('from' => '2005-01-01', 'to' => '2005-03-31')
  #
  #   res = Net::HTTP.start(uri.hostname, uri.port) do |http|
  #     http.request(req)
  #   end
  #
  #   case res
  #   when Net::HTTPSuccess, Net::HTTPRedirection
  #     # OK
  #   else
  #     res.value
  #   end
  #
  # To send multipart/form-data use Net::HTTPHeader#set_form:
  #
  #   req = Net::HTTP::Post.new(uri)
  #   req.set_form([['upload', File.open('foo.bar')]], 'multipart/form-data')
  #
  # Other requests that can contain a body such as PUT can be created in the
  # same way using the corresponding request class (Net::HTTP::Put).
  #
  # === Setting Headers
  #
  # The following example performs a conditional GET using the
  # If-Modified-Since header.  If the files has not been modified since the
  # time in the header a Not Modified response will be returned.  See RFC 2616
  # section 9.3 for further details.
  #
  #   uri = URI('http://example.com/cached_response')
  #   file = File.stat 'cached_response'
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req['If-Modified-Since'] = file.mtime.rfc2822
  #
  #   res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  #     http.request(req)
  #   }
  #
  #   open 'cached_response', 'w' do |io|
  #     io.write res.body
  #   end if res.is_a?(Net::HTTPSuccess)
  #
  # === Basic Authentication
  #
  # Basic authentication is performed according to
  # [RFC2617](http://www.ietf.org/rfc/rfc2617.txt).
  #
  #   uri = URI('http://example.com/index.html?key=value')
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.basic_auth 'user', 'pass'
  #
  #   res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  #     http.request(req)
  #   }
  #   puts res.body
  #
  # === Streaming Response Bodies
  #
  # By default Net::HTTP reads an entire response into memory.  If you are
  # handling large files or wish to implement a progress bar you can instead
  # stream the body directly to an IO.
  #
  #   uri = URI('http://example.com/large_file')
  #
  #   Net::HTTP.start(uri.host, uri.port) do |http|
  #     request = Net::HTTP::Get.new uri
  #
  #     http.request request do |response|
  #       open 'large_file', 'w' do |io|
  #         response.read_body do |chunk|
  #           io.write chunk
  #         end
  #       end
  #     end
  #   end
  #
  # === HTTPS
  #
  # HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=.
  #
  #   uri = URI('https://secure.example.com/some_path?query=string')
  #
  #   Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
  #     request = Net::HTTP::Get.new uri
  #     response = http.request request # Net::HTTPResponse object
  #   end
  #
  # Or if you simply want to make a GET request, you may pass in an URI
  # object that has an HTTPS URL. Net::HTTP automatically turns on TLS
  # verification if the URI object has a 'https' URI scheme.
  #
  #   uri = URI('https://example.com/')
  #   Net::HTTP.get(uri) # => String
  #
  # In previous versions of Ruby you would need to require 'net/https' to use
  # HTTPS. This is no longer true.
  #
  # === Proxies
  #
  # Net::HTTP will automatically create a proxy from the +http_proxy+
  # environment variable if it is present.  To disable use of +http_proxy+,
  # pass +nil+ for the proxy address.
  #
  # You may also create a custom proxy:
  #
  #   proxy_addr = 'your.proxy.host'
  #   proxy_port = 8080
  #
  #   Net::HTTP.new('example.com', nil, proxy_addr, proxy_port).start { |http|
  #     # always proxy via your.proxy.addr:8080
  #   }
  #
  # See Net::HTTP.new for further details and examples such as proxies that
  # require a username and password.
  #
  # === Compression
  #
  # Net::HTTP automatically adds Accept-Encoding for compression of response
  # bodies and automatically decompresses gzip and deflate responses unless a
  # Range header was sent.
  #
  # Compression can be disabled through the Accept-Encoding: identity header.
  #
  # == HTTP Request Classes
  #
  # Here is the HTTP request class hierarchy.
  #
  # * Net::HTTPRequest
  #   * Net::HTTP::Get
  #   * Net::HTTP::Head
  #   * Net::HTTP::Post
  #   * Net::HTTP::Patch
  #   * Net::HTTP::Put
  #   * Net::HTTP::Proppatch
  #   * Net::HTTP::Lock
  #   * Net::HTTP::Unlock
  #   * Net::HTTP::Options
  #   * Net::HTTP::Propfind
  #   * Net::HTTP::Delete
  #   * Net::HTTP::Move
  #   * Net::HTTP::Copy
  #   * Net::HTTP::Mkcol
  #   * Net::HTTP::Trace
  #
  # == HTTP Response Classes
  #
  # Here is HTTP response class hierarchy.  All classes are defined in Net
  # module and are subclasses of Net::HTTPResponse.
  #
  # HTTPUnknownResponse:: For unhandled HTTP extensions
  # HTTPInformation::                    1xx
  #   HTTPContinue::                        100
  #   HTTPSwitchProtocol::                  101
  #   HTTPProcessing::                      102
  #   HTTPEarlyHints::                      103
  # HTTPSuccess::                        2xx
  #   HTTPOK::                              200
  #   HTTPCreated::                         201
  #   HTTPAccepted::                        202
  #   HTTPNonAuthoritativeInformation::     203
  #   HTTPNoContent::                       204
  #   HTTPResetContent::                    205
  #   HTTPPartialContent::                  206
  #   HTTPMultiStatus::                     207
  #   HTTPAlreadyReported::                 208
  #   HTTPIMUsed::                          226
  # HTTPRedirection::                    3xx
  #   HTTPMultipleChoices::                 300
  #   HTTPMovedPermanently::                301
  #   HTTPFound::                           302
  #   HTTPSeeOther::                        303
  #   HTTPNotModified::                     304
  #   HTTPUseProxy::                        305
  #   HTTPTemporaryRedirect::               307
  #   HTTPPermanentRedirect::               308
  # HTTPClientError::                    4xx
  #   HTTPBadRequest::                      400
  #   HTTPUnauthorized::                    401
  #   HTTPPaymentRequired::                 402
  #   HTTPForbidden::                       403
  #   HTTPNotFound::                        404
  #   HTTPMethodNotAllowed::                405
  #   HTTPNotAcceptable::                   406
  #   HTTPProxyAuthenticationRequired::     407
  #   HTTPRequestTimeOut::                  408
  #   HTTPConflict::                        409
  #   HTTPGone::                            410
  #   HTTPLengthRequired::                  411
  #   HTTPPreconditionFailed::              412
  #   HTTPRequestEntityTooLarge::           413
  #   HTTPRequestURITooLong::               414
  #   HTTPUnsupportedMediaType::            415
  #   HTTPRequestedRangeNotSatisfiable::    416
  #   HTTPExpectationFailed::               417
  #   HTTPMisdirectedRequest::              421
  #   HTTPUnprocessableEntity::             422
  #   HTTPLocked::                          423
  #   HTTPFailedDependency::                424
  #   HTTPUpgradeRequired::                 426
  #   HTTPPreconditionRequired::            428
  #   HTTPTooManyRequests::                 429
  #   HTTPRequestHeaderFieldsTooLarge::     431
  #   HTTPUnavailableForLegalReasons::      451
  # HTTPServerError::                    5xx
  #   HTTPInternalServerError::             500
  #   HTTPNotImplemented::                  501
  #   HTTPBadGateway::                      502
  #   HTTPServiceUnavailable::              503
  #   HTTPGatewayTimeOut::                  504
  #   HTTPVersionNotSupported::             505
  #   HTTPVariantAlsoNegotiates::           506
  #   HTTPInsufficientStorage::             507
  #   HTTPLoopDetected::                    508
  #   HTTPNotExtended::                     510
  #   HTTPNetworkAuthenticationRequired::   511
  #
  # There is also the Net::HTTPBadResponse exception which is raised when
  # there is a protocol error.
  #
  class HTTP < Protocol
    # :stopdoc:
    VERSION: "0.2.0"

    Revision: untyped

    HTTPVersion: "1.1"

    HAVE_ZLIB: bool

    # Turns on net/http 1.2 (Ruby 1.8) features.
    # Defaults to ON in Ruby 1.8 or later.
    def self.version_1_2: () -> true

    # Returns true if net/http is in version 1.2 mode.
    # Defaults to true.
    def self.version_1_2?: () -> true

    def self.version_1_1?: () -> false

    alias self.is_version_1_1? self.version_1_1?

    alias self.is_version_1_2? self.version_1_2?

    #
    # Gets the body text from the target and outputs it to $stdout.  The
    # target can either be specified as
    # (+uri+, +headers+), or as (+host+, +path+, +port+ = 80); so:
    #
    #    Net::HTTP.get_print URI('http://www.example.com/index.html')
    #
    # or:
    #
    #    Net::HTTP.get_print 'www.example.com', '/index.html'
    #
    # you can also specify request headers:
    #
    #    Net::HTTP.get_print URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' }
    #
    def self.get_print: (untyped uri_or_host, ?untyped? path_or_headers, ?untyped? port) -> nil

    # Sends a GET request to the target and returns the HTTP response
    # as a string.  The target can either be specified as
    # (+uri+, +headers+), or as (+host+, +path+, +port+ = 80); so:
    #
    #    print Net::HTTP.get(URI('http://www.example.com/index.html'))
    #
    # or:
    #
    #    print Net::HTTP.get('www.example.com', '/index.html')
    #
    # you can also specify request headers:
    #
    #    Net::HTTP.get(URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' })
    #
    def self.get: (untyped uri_or_host, ?untyped? path_or_headers, ?untyped? port) -> untyped

    # Sends a GET request to the target and returns the HTTP response
    # as a Net::HTTPResponse object.  The target can either be specified as
    # (+uri+, +headers+), or as (+host+, +path+, +port+ = 80); so:
    #
    #    res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))
    #    print res.body
    #
    # or:
    #
    #    res = Net::HTTP.get_response('www.example.com', '/index.html')
    #    print res.body
    #
    # you can also specify request headers:
    #
    #    Net::HTTP.get_response(URI('http://www.example.com/index.html'), { 'Accept' => 'text/html' })
    #
    def self.get_response: (untyped uri_or_host, ?untyped? path_or_headers, ?untyped? port) ?{ () -> untyped } -> untyped

    # Posts data to the specified URI object.
    #
    # Example:
    #
    #   require 'net/http'
    #   require 'uri'
    #
    #   Net::HTTP.post URI('http://www.example.com/api/search'),
    #                  { "q" => "ruby", "max" => "50" }.to_json,
    #                  "Content-Type" => "application/json"
    #
    def self.post: (untyped url, untyped data, ?untyped? header) -> untyped

    # Posts HTML form data to the specified URI object.
    # The form data must be provided as a Hash mapping from String to String.
    # Example:
    #
    #   { "cmd" => "search", "q" => "ruby", "max" => "50" }
    #
    # This method also does Basic Authentication if and only if +url+.user exists.
    # But userinfo for authentication is deprecated (RFC3986).
    # So this feature will be removed.
    #
    # Example:
    #
    #   require 'net/http'
    #
    #   Net::HTTP.post_form URI('http://www.example.com/search.cgi'),
    #                       { "q" => "ruby", "max" => "50" }
    #
    def self.post_form: (untyped url, untyped params) -> untyped

    # The default port to use for HTTP requests; defaults to 80.
    def self.default_port: () -> untyped

    # The default port to use for HTTP requests; defaults to 80.
    def self.http_default_port: () -> 80

    # The default port to use for HTTPS requests; defaults to 443.
    def self.https_default_port: () -> 443

    def self.socket_type: () -> untyped

    def self.start: (untyped address, *untyped arg) { () -> untyped } -> untyped

    alias self.newobj self.new

    # Creates a new Net::HTTP object without opening a TCP connection or
    # HTTP session.
    #
    # The +address+ should be a DNS hostname or IP address, the +port+ is the
    # port the server operates on.  If no +port+ is given the default port for
    # HTTP or HTTPS is used.
    #
    # If none of the +p_+ arguments are given, the proxy host and port are
    # taken from the +http_proxy+ environment variable (or its uppercase
    # equivalent) if present.  If the proxy requires authentication you must
    # supply it by hand.  See URI::Generic#find_proxy for details of proxy
    # detection from the environment.  To disable proxy detection set +p_addr+
    # to nil.
    #
    # If you are connecting to a custom proxy, +p_addr+ specifies the DNS name
    # or IP address of the proxy host, +p_port+ the port to use to access the
    # proxy, +p_user+ and +p_pass+ the username and password if authorization
    # is required to use the proxy, and p_no_proxy hosts which do not
    # use the proxy.
    #
    def self.new: (untyped address, ?untyped? port, ?::Symbol p_addr, ?untyped? p_port, ?untyped? p_user, ?untyped? p_pass, ?untyped? p_no_proxy) -> untyped

    # Creates a new Net::HTTP object for the specified server address,
    # without opening the TCP connection or initializing the HTTP session.
    # The +address+ should be a DNS hostname or IP address.
    def initialize: (untyped address, ?untyped? port) -> void

    def inspect: () -> ::String

    # *WARNING* This method opens a serious security hole.
    # Never use this method in production code.
    #
    # Sets an output stream for debugging.
    #
    #   http = Net::HTTP.new(hostname)
    #   http.set_debug_output $stderr
    #   http.start { .... }
    #
    def set_debug_output: (untyped output) -> untyped

    # The DNS host name or IP address to connect to.
    attr_reader address: untyped

    # The port number to connect to.
    attr_reader port: untyped

    # The local host used to establish the connection.
    attr_accessor local_host: untyped

    # The local port used to establish the connection.
    attr_accessor local_port: untyped

    # The encoding to use for the response body.  If Encoding, uses the
    # specified encoding.  If other true value, tries to detect the response
    # body encoding.
    attr_reader response_body_encoding: untyped

    # Set the encoding to use for the response body.  If given a String, find
    # the related Encoding.
    def response_body_encoding=: (untyped value) -> untyped

    attr_writer proxy_from_env: untyped

    attr_writer proxy_address: untyped

    attr_writer proxy_port: untyped

    attr_writer proxy_user: untyped

    attr_writer proxy_pass: untyped

    # The IP address to connect to/used to connect to
    def ipaddr: () -> untyped

    # Set the IP address to connect to
    def ipaddr=: (untyped addr) -> untyped

    # Number of seconds to wait for the connection to open. Any number
    # may be used, including Floats for fractional seconds. If the HTTP
    # object cannot open a connection in this many seconds, it raises a
    # Net::OpenTimeout exception. The default value is 60 seconds.
    attr_accessor open_timeout: untyped

    # Number of seconds to wait for one block to be read (via one read(2)
    # call). Any number may be used, including Floats for fractional
    # seconds. If the HTTP object cannot read data in this many seconds,
    # it raises a Net::ReadTimeout exception. The default value is 60 seconds.
    attr_reader read_timeout: untyped

    # Number of seconds to wait for one block to be written (via one write(2)
    # call). Any number may be used, including Floats for fractional
    # seconds. If the HTTP object cannot write data in this many seconds,
    # it raises a Net::WriteTimeout exception. The default value is 60 seconds.
    # Net::WriteTimeout is not raised on Windows.
    attr_reader write_timeout: untyped

    # Maximum number of times to retry an idempotent request in case of
    # Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET,
    # Errno::ECONNABORTED, Errno::EPIPE, OpenSSL::SSL::SSLError,
    # Timeout::Error.
    # Should be a non-negative integer number. Zero means no retries.
    # The default value is 1.
    def max_retries=: (untyped retries) -> untyped

    attr_reader max_retries: untyped

    # Setter for the read_timeout attribute.
    def read_timeout=: (untyped sec) -> untyped

    # Setter for the write_timeout attribute.
    def write_timeout=: (untyped sec) -> untyped

    # Seconds to wait for 100 Continue response. If the HTTP object does not
    # receive a response in this many seconds it sends the request body. The
    # default value is +nil+.
    attr_reader continue_timeout: untyped

    # Setter for the continue_timeout attribute.
    def continue_timeout=: (untyped sec) -> untyped

    # Seconds to reuse the connection of the previous request.
    # If the idle time is less than this Keep-Alive Timeout,
    # Net::HTTP reuses the TCP/IP socket used by the previous communication.
    # The default value is 2 seconds.
    attr_accessor keep_alive_timeout: untyped

    # Returns true if the HTTP session has been started.
    def started?: () -> untyped

    alias active? started?

    attr_accessor close_on_empty_response: untyped

    # Returns true if SSL/TLS is being used with HTTP.
    def use_ssl?: () -> untyped

    # Turn on/off SSL.
    # This flag must be set before starting session.
    # If you change use_ssl value after session started,
    # a Net::HTTP object raises IOError.
    def use_ssl=: (untyped flag) -> untyped

    SSL_IVNAMES: ::Array[:@ca_file | :@ca_path | :@cert | :@cert_store | :@ciphers | :@extra_chain_cert | :@key | :@ssl_timeout | :@ssl_version | :@min_version | :@max_version | :@verify_callback | :@verify_depth | :@verify_mode | :@verify_hostname]

    SSL_ATTRIBUTES: ::Array[:ca_file | :ca_path | :cert | :cert_store | :ciphers | :extra_chain_cert | :key | :ssl_timeout | :ssl_version | :min_version | :max_version | :verify_callback | :verify_depth | :verify_mode | :verify_hostname]

    # Sets path of a CA certification file in PEM format.
    #
    # The file can contain several CA certificates.
    attr_accessor ca_file: untyped

    # Sets path of a CA certification directory containing certifications in
    # PEM format.
    attr_accessor ca_path: untyped

    # Sets an OpenSSL::X509::Certificate object as client certificate.
    # (This method is appeared in Michal Rokos's OpenSSL extension).
    attr_accessor cert: untyped

    # Sets the X509::Store to verify peer certificate.
    attr_accessor cert_store: untyped

    # Sets the available ciphers.  See OpenSSL::SSL::SSLContext#ciphers=
    attr_accessor ciphers: untyped

    # Sets the extra X509 certificates to be added to the certificate chain.
    # See OpenSSL::SSL::SSLContext#extra_chain_cert=
    attr_accessor extra_chain_cert: untyped

    # Sets an OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
    # (This method is appeared in Michal Rokos's OpenSSL extension.)
    attr_accessor key: untyped

    # Sets the SSL timeout seconds.
    attr_accessor ssl_timeout: untyped

    # Sets the SSL version.  See OpenSSL::SSL::SSLContext#ssl_version=
    attr_accessor ssl_version: untyped

    # Sets the minimum SSL version.  See OpenSSL::SSL::SSLContext#min_version=
    attr_accessor min_version: untyped

    # Sets the maximum SSL version.  See OpenSSL::SSL::SSLContext#max_version=
    attr_accessor max_version: untyped

    # Sets the verify callback for the server certification verification.
    attr_accessor verify_callback: untyped

    # Sets the maximum depth for the certificate chain verification.
    attr_accessor verify_depth: untyped

    # Sets the flags for server the certification verification at beginning of
    # SSL/TLS session.
    #
    # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
    attr_accessor verify_mode: untyped

    # Sets to check the server certificate is valid for the hostname.
    # See OpenSSL::SSL::SSLContext#verify_hostname=
    attr_accessor verify_hostname: untyped

    # Returns the X.509 certificates the server presented.
    def peer_cert: () -> (nil | untyped)

    def start: () { (untyped) -> untyped } -> untyped

    private

    def do_start: () -> untyped

    def connect: () -> untyped

    def on_connect: () -> nil

    public

    # Finishes the HTTP session and closes the TCP connection.
    # Raises IOError if the session has not been started.
    def finish: () -> untyped

    private

    def do_finish: () -> untyped

    public

    # Creates an HTTP proxy class which behaves like Net::HTTP, but
    # performs all access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    def self.Proxy: (?::Symbol p_addr, ?untyped? p_port, ?untyped? p_user, ?untyped? p_pass) -> untyped

    # returns true if self is a class which was created by HTTP::Proxy.
    def self.proxy_class?: () -> untyped

    # Address of proxy host. If Net::HTTP does not use a proxy, nil.
    attr_reader self.proxy_address: untyped

    # Port number of proxy host. If Net::HTTP does not use a proxy, nil.
    attr_reader self.proxy_port: untyped

    # User name for accessing proxy. If Net::HTTP does not use a proxy, nil.
    attr_reader self.proxy_user: untyped

    # User password for accessing proxy. If Net::HTTP does not use a proxy,
    # nil.
    attr_reader self.proxy_pass: untyped

    # True if requests for this connection will be proxied
    def proxy?: () -> untyped

    # True if the proxy for this connection is determined from the environment
    def proxy_from_env?: () -> untyped

    def proxy_uri: () -> (nil | untyped)

    # The address of the proxy server, if one is configured.
    def proxy_address: () -> untyped

    # The port of the proxy server, if one is configured.
    def proxy_port: () -> untyped

    ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE: bool

    # The username of the proxy server, if one is configured.
    def proxy_user: () -> untyped

    # The password of the proxy server, if one is configured.
    def proxy_pass: () -> untyped

    alias proxyaddr proxy_address

    alias proxyport proxy_port

    private

    def unescape: (untyped value) -> untyped

    def conn_address: () -> untyped

    def conn_port: () -> untyped

    def edit_path: (untyped path) -> untyped

    public

    def get: (untyped path, ?untyped? initheader, ?untyped? dest) { () -> untyped } -> untyped

    # Gets only the header from +path+ on the connected-to host.
    # +header+ is a Hash like { 'Accept' => '*/*', ... }.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # This method never raises an exception.
    #
    #     response = nil
    #     Net::HTTP.start('some.www.server', 80) {|http|
    #       response = http.head('/index.html')
    #     }
    #     p response['content-type']
    #
    def head: (untyped path, ?untyped? initheader) -> untyped

    def post: (untyped path, untyped data, ?untyped? initheader, ?untyped? dest) { () -> untyped } -> untyped

    def patch: (untyped path, untyped data, ?untyped? initheader, ?untyped? dest) { () -> untyped } -> untyped

    def put: (untyped path, untyped data, ?untyped? initheader) -> untyped

    # Sends a PROPPATCH request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def proppatch: (untyped path, untyped body, ?untyped? initheader) -> untyped

    # Sends a LOCK request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def lock: (untyped path, untyped body, ?untyped? initheader) -> untyped

    # Sends a UNLOCK request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def unlock: (untyped path, untyped body, ?untyped? initheader) -> untyped

    # Sends a OPTIONS request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def options: (untyped path, ?untyped? initheader) -> untyped

    # Sends a PROPFIND request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def propfind: (untyped path, ?untyped? body, ?::Hash[untyped, untyped] initheader) -> untyped

    # Sends a DELETE request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def delete: (untyped path, ?::Hash[untyped, untyped] initheader) -> untyped

    # Sends a MOVE request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def move: (untyped path, ?untyped? initheader) -> untyped

    # Sends a COPY request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def copy: (untyped path, ?untyped? initheader) -> untyped

    # Sends a MKCOL request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def mkcol: (untyped path, ?untyped? body, ?untyped? initheader) -> untyped

    # Sends a TRACE request to the +path+ and gets a response,
    # as an HTTPResponse object.
    def trace: (untyped path, ?untyped? initheader) -> untyped

    def request_get: (untyped path, ?untyped? initheader) { () -> untyped } -> untyped

    # Sends a HEAD request to the +path+ and returns the response
    # as a Net::HTTPResponse object.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.request_head('/index.html')
    #     p response['content-type']
    #
    def request_head: (untyped path, ?untyped? initheader) { () -> untyped } -> untyped

    def request_post: (untyped path, untyped data, ?untyped? initheader) { () -> untyped } -> untyped

    def request_put: (untyped path, untyped data, ?untyped? initheader) { () -> untyped } -> untyped

    alias get2 request_get

    alias head2 request_head

    alias post2 request_post

    alias put2 request_put

    # Sends an HTTP request to the HTTP server.
    # Also sends a DATA string if +data+ is given.
    #
    # Returns a Net::HTTPResponse object.
    #
    # This method never raises Net::* exceptions.
    #
    #    response = http.send_request('GET', '/index.html')
    #    puts response.body
    #
    def send_request: (untyped name, untyped path, ?untyped? data, ?untyped? header) -> untyped

    def request: (untyped req, ?untyped? body) { () -> untyped } -> untyped

    private

    # Executes a request which uses a representation
    # and returns its body.
    def send_entity: (untyped path, untyped data, untyped initheader, untyped dest, untyped `type`) { () -> untyped } -> untyped

    IDEMPOTENT_METHODS_: ::Array["GET" | "HEAD" | "PUT" | "DELETE" | "OPTIONS" | "TRACE"]

    def transport_request: (untyped req) { (untyped) -> untyped } -> untyped

    def begin_transport: (untyped req) -> untyped

    def end_transport: (untyped req, untyped res) -> untyped

    def keep_alive?: (untyped req, untyped res) -> (false | untyped)

    def sspi_auth?: (untyped res) -> (false | untyped)

    def sspi_auth: (untyped req) -> untyped

    def addr_port: () -> untyped

    # Adds a message to debugging output
    def debug: (untyped msg) -> (nil | untyped)

    alias D debug
  end
end

Net::HTTP::STATUS_CODES: { 100 => "Continue", 101 => "Switching Protocols", 102 => "Processing", 103 => "Early Hints", 200 => "OK", 201 => "Created", 202 => "Accepted", 203 => "Non-Authoritative Information", 204 => "No Content", 205 => "Reset Content", 206 => "Partial Content", 207 => "Multi-Status", 208 => "Already Reported", 226 => "IM Used", 300 => "Multiple Choices", 301 => "Moved Permanently", 302 => "Found", 303 => "See Other", 304 => "Not Modified", 305 => "Use Proxy", 307 => "Temporary Redirect", 308 => "Permanent Redirect", 400 => "Bad Request", 401 => "Unauthorized", 402 => "Payment Required", 403 => "Forbidden", 404 => "Not Found", 405 => "Method Not Allowed", 406 => "Not Acceptable", 407 => "Proxy Authentication Required", 408 => "Request Timeout", 409 => "Conflict", 410 => "Gone", 411 => "Length Required", 412 => "Precondition Failed", 413 => "Payload Too Large", 414 => "URI Too Long", 415 => "Unsupported Media Type", 416 => "Range Not Satisfiable", 417 => "Expectation Failed", 421 => "Misdirected Request", 422 => "Unprocessable Entity", 423 => "Locked", 424 => "Failed Dependency", 426 => "Upgrade Required", 428 => "Precondition Required", 429 => "Too Many Requests", 431 => "Request Header Fields Too Large", 451 => "Unavailable For Legal Reasons", 500 => "Internal Server Error", 501 => "Not Implemented", 502 => "Bad Gateway", 503 => "Service Unavailable", 504 => "Gateway Timeout", 505 => "HTTP Version Not Supported", 506 => "Variant Also Negotiates", 507 => "Insufficient Storage", 508 => "Loop Detected", 510 => "Not Extended", 511 => "Network Authentication Required" }

# See Net::HTTPGenericRequest for attributes and methods.
# See Net::HTTP for usage examples.
class Net::HTTP::Get < Net::HTTPRequest
  METHOD: "GET"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
# See Net::HTTP for usage examples.
class Net::HTTP::Head < Net::HTTPRequest
  METHOD: "HEAD"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: false
end

# See Net::HTTPGenericRequest for attributes and methods.
# See Net::HTTP for usage examples.
class Net::HTTP::Post < Net::HTTPRequest
  METHOD: "POST"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
# See Net::HTTP for usage examples.
class Net::HTTP::Put < Net::HTTPRequest
  METHOD: "PUT"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
# See Net::HTTP for usage examples.
class Net::HTTP::Delete < Net::HTTPRequest
  METHOD: "DELETE"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Options < Net::HTTPRequest
  METHOD: "OPTIONS"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Trace < Net::HTTPRequest
  METHOD: "TRACE"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Patch < Net::HTTPRequest
  METHOD: "PATCH"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Propfind < Net::HTTPRequest
  METHOD: "PROPFIND"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Proppatch < Net::HTTPRequest
  METHOD: "PROPPATCH"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Mkcol < Net::HTTPRequest
  METHOD: "MKCOL"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Copy < Net::HTTPRequest
  METHOD: "COPY"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Move < Net::HTTPRequest
  METHOD: "MOVE"

  REQUEST_HAS_BODY: false

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Lock < Net::HTTPRequest
  METHOD: "LOCK"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# See Net::HTTPGenericRequest for attributes and methods.
class Net::HTTP::Unlock < Net::HTTPRequest
  METHOD: "UNLOCK"

  REQUEST_HAS_BODY: true

  RESPONSE_HAS_BODY: true
end

# frozen_string_literal: false
# Net::HTTP exception class.
# You cannot use Net::HTTPExceptions directly; instead, you must use
# its subclasses.
module Net::HTTPExceptions
  def initialize: (untyped msg, untyped res) -> void

  attr_reader response: untyped

  alias data response
end

class Net::HTTPError < Net::ProtocolError
  include Net::HTTPExceptions
end

class Net::HTTPRetriableError < Net::ProtoRetriableError
  include Net::HTTPExceptions
end

class Net::HTTPServerException < Net::ProtoServerError
  # We cannot use the name "HTTPServerError", it is the name of the response.
  include Net::HTTPExceptions
end

# for compatibility
Net::HTTPClientException: untyped

class Net::HTTPFatalError < Net::ProtoFatalError
  include Net::HTTPExceptions
end

module Net
end

# frozen_string_literal: false
# HTTPGenericRequest is the parent of the Net::HTTPRequest class.
# Do not use this directly; use a subclass of Net::HTTPRequest.
#
# Mixes in the Net::HTTPHeader module to provide easier access to HTTP headers.
#
class Net::HTTPGenericRequest
  include Net::HTTPHeader

  def initialize: (untyped m, untyped reqbody, untyped resbody, untyped uri_or_path, ?untyped? initheader) -> void

  attr_reader method: untyped

  attr_reader path: untyped

  attr_reader uri: untyped

  # Automatically set to false if the user sets the Accept-Encoding header.
  # This indicates they wish to handle Content-encoding in responses
  # themselves.
  attr_reader decode_content: untyped

  def inspect: () -> ::String

  def []=: (untyped key, untyped val) -> untyped

  def request_body_permitted?: () -> untyped

  def response_body_permitted?: () -> untyped

  def body_exist?: () -> untyped

  attr_reader body: untyped

  def body=: (untyped str) -> untyped

  attr_reader body_stream: untyped

  def body_stream=: (untyped input) -> untyped

  def set_body_internal: (untyped str) -> untyped

  def exec: (untyped sock, untyped ver, untyped path) -> untyped

  def update_uri: (untyped addr, untyped port, untyped ssl) -> (nil | untyped)

  private

  class Chunker
    # nodoc:
    def initialize: (untyped sock) -> void

    def write: (untyped buf) -> untyped

    def finish: () -> untyped
  end

  def send_request_with_body: (untyped sock, untyped ver, untyped path, untyped body) -> untyped

  def send_request_with_body_stream: (untyped sock, untyped ver, untyped path, untyped f) -> untyped

  def send_request_with_body_data: (untyped sock, untyped ver, untyped path, untyped params) -> untyped

  def encode_multipart_form_data: (untyped `out`, untyped params, untyped opt) -> untyped

  def quote_string: (untyped str, untyped charset) -> untyped

  def flush_buffer: (untyped `out`, untyped buf, untyped chunked_p) -> (nil | untyped)

  def supply_default_content_type: () -> (nil | untyped)

  def wait_for_continue: (untyped sock, untyped ver) -> untyped

  def write_header: (untyped sock, untyped ver, untyped path) -> untyped
end

class Net::HTTP
  ProxyMod: untyped
end

module Net::NetPrivate
  HTTPRequest: untyped
end

module Net
  HTTPSession: untyped

  HTTPInformationCode: untyped

  HTTPSuccessCode: untyped

  HTTPRedirectionCode: untyped

  HTTPRetriableCode: untyped

  HTTPClientErrorCode: untyped

  HTTPFatalErrorCode: untyped

  HTTPServerErrorCode: untyped

  HTTPResponseReceiver: untyped

  HTTPResponceReceiver: untyped
end

# frozen_string_literal: false
# HTTP response class.
#
# This class wraps together the response header and the response body (the
# entity requested).
#
# It mixes in the HTTPHeader module, which provides access to response
# header values both via hash-like methods and via individual readers.
#
# Note that each possible HTTP response code defines its own
# HTTPResponse subclass. All classes are defined under the Net module.
# Indentation indicates inheritance.  For a list of the classes see Net::HTTP.
#
# Correspondence <code>HTTP code => class</code> is stored in CODE_TO_OBJ
# constant:
#
#    Net::HTTPResponse::CODE_TO_OBJ['404'] #=> Net::HTTPNotFound
#
class Net::HTTPResponse
  # true if the response has a body.
  def self.body_permitted?: () -> untyped

  def self.exception_type: () -> untyped

  def self.read_new: (untyped sock) -> untyped

  private

  def self.read_status_line: (untyped sock) -> untyped

  def self.response_class: (untyped code) -> untyped

  def self.each_response_header: (untyped sock) { (untyped, untyped) -> untyped } -> untyped

  public

  include Net::HTTPHeader

  def initialize: (untyped httpv, untyped code, untyped msg) -> void

  # The HTTP version supported by the server.
  attr_reader http_version: untyped

  # The HTTP result code string. For example, '302'.  You can also
  # determine the response type by examining which response subclass
  # the response object is an instance of.
  attr_reader code: untyped

  # The HTTP result message sent by the server. For example, 'Not Found'.
  attr_reader message: untyped

  alias msg message

  # The URI used to fetch this response.  The response URI is only available
  # if a URI was used to create the request.
  attr_reader uri: untyped

  # Set to true automatically when the request did not contain an
  # Accept-Encoding header from the user.
  attr_accessor decode_content: untyped

  # The encoding to use for the response body. If Encoding, use that encoding.
  # If other true value, attempt to detect the appropriate encoding, and use
  # that.
  attr_reader body_encoding: untyped

  # Set the encoding to use for the response body.  If given a String, find
  # the related Encoding.
  def body_encoding=: (untyped value) -> untyped

  def inspect: () -> ::String

  def code_type: () -> untyped

  def error!: () -> untyped

  def error_type: () -> untyped

  # Raises an HTTP error if the response is not 2xx (success).
  def value: () -> untyped

  def uri=: (untyped uri) -> untyped

  def response: () -> untyped

  def header: () -> untyped

  def read_header: () -> untyped

  def reading_body: (untyped sock, untyped reqmethodallowbody) { () -> untyped } -> untyped

  # Gets the entity body returned by the remote HTTP server.
  #
  # If a block is given, the body is passed to the block, and
  # the body is provided in fragments, as it is read in from the socket.
  #
  # If +dest+ argument is given, response is read into that variable,
  # with <code>dest#<<</code> method (it could be String or IO, or any
  # other object responding to <code><<</code>).
  #
  # Calling this method a second or subsequent time for the same
  # HTTPResponse object will return the value already read.
  #
  #   http.request_get('/index.html') {|res|
  #     puts res.read_body
  #   }
  #
  #   http.request_get('/index.html') {|res|
  #     p res.read_body.object_id   # 538149362
  #     p res.read_body.object_id   # 538149362
  #   }
  #
  #   # using iterator
  #   http.request_get('/index.html') {|res|
  #     res.read_body do |segment|
  #       print segment
  #     end
  #   }
  #
  def read_body: (?untyped? dest) { () -> untyped } -> untyped

  # Returns the full entity body.
  #
  # Calling this method a second or subsequent time will return the
  # string already read.
  #
  #   http.request_get('/index.html') {|res|
  #     puts res.body
  #   }
  #
  #   http.request_get('/index.html') {|res|
  #     p res.body.object_id   # 538149362
  #     p res.body.object_id   # 538149362
  #   }
  #
  def body: () -> untyped

  # Because it may be necessary to modify the body, Eg, decompression
  # this method facilitates that.
  def body=: (untyped value) -> untyped

  alias entity body

  private

  # :nodoc:
  def detect_encoding: (untyped str, ?untyped? encoding) -> untyped

  # :nodoc:
  def sniff_encoding: (untyped str, ?untyped? encoding) -> untyped

  # :nodoc:
  def check_bom: (untyped str) -> (untyped | nil)

  # :nodoc:
  def scanning_meta: (untyped str) -> (nil | untyped)

  def get_attribute: (untyped ss) -> (nil | ::Array[untyped])

  def extracting_encodings_from_meta_elements: (untyped value) -> (untyped | nil)

  def inflater: () { (untyped) -> untyped } -> untyped

  def read_body_0: (untyped dest) -> untyped

  def read_chunked: (untyped dest, untyped chunk_data_io) -> untyped

  def stream_check: () -> untyped

  def procdest: (untyped dest, untyped block) -> untyped

  class Inflater
    def initialize: (untyped socket) -> void

    def finish: () -> (nil | untyped)

    def bytes_inflated: () -> untyped

    def inflate_adapter: (untyped dest) -> untyped

    def read: (untyped clen, untyped dest, ?bool ignore_eof) -> untyped

    def read_all: (untyped dest) -> untyped
  end
end

# frozen_string_literal: false
# HTTP request class.
# This class wraps together the request header and the request path.
# You cannot use this class directly. Instead, you should use one of its
# subclasses: Net::HTTP::Get, Net::HTTP::Post, Net::HTTP::Head.
#
class Net::HTTPRequest < Net::HTTPGenericRequest
  def initialize: (untyped path, ?untyped? initheader) -> void
end

# frozen_string_literal: false
# The HTTPHeader module defines methods for reading and writing
# HTTP headers.
#
# It is used as a mixin by other classes, to provide hash-like
# access to HTTP header values. Unlike raw hash access, HTTPHeader
# provides access via case-insensitive keys. It also provides
# methods for accessing commonly-used HTTP header values in more
# convenient formats.
#
module Net::HTTPHeader
  def initialize_http_header: (untyped initheader) -> (nil | untyped)

  def size: () -> untyped

  alias length size

  # Returns the header field corresponding to the case-insensitive key.
  # For example, a key of "Content-Type" might return "text/html"
  def []: (untyped key) -> (nil | untyped)

  # Sets the header field corresponding to the case-insensitive key.
  def []=: (untyped key, untyped val) -> untyped

  # [Ruby 1.8.3]
  # Adds a value to a named header field, instead of replacing its value.
  # Second argument +val+ must be a String.
  # See also #[]=, #[] and #get_fields.
  #
  #   request.add_field 'X-My-Header', 'a'
  #   p request['X-My-Header']              #=> "a"
  #   p request.get_fields('X-My-Header')   #=> ["a"]
  #   request.add_field 'X-My-Header', 'b'
  #   p request['X-My-Header']              #=> "a, b"
  #   p request.get_fields('X-My-Header')   #=> ["a", "b"]
  #   request.add_field 'X-My-Header', 'c'
  #   p request['X-My-Header']              #=> "a, b, c"
  #   p request.get_fields('X-My-Header')   #=> ["a", "b", "c"]
  #
  def add_field: (untyped key, untyped val) -> untyped

  private

  def set_field: (untyped key, untyped val) -> untyped

  def append_field_value: (untyped ary, untyped val) -> untyped

  public

  # [Ruby 1.8.3]
  # Returns an array of header field strings corresponding to the
  # case-insensitive +key+.  This method allows you to get duplicated
  # header fields without any processing.  See also #[].
  #
  #   p response.get_fields('Set-Cookie')
  #     #=> ["session=al98axx; expires=Fri, 31-Dec-1999 23:58:23",
  #          "query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"]
  #   p response['Set-Cookie']
  #     #=> "session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"
  #
  def get_fields: (untyped key) -> (nil | untyped)

  def fetch: (untyped key, *untyped args) { () -> untyped } -> untyped

  def each_header: () { (untyped, untyped) -> untyped } -> untyped

  alias each each_header

  def each_name: () { () -> untyped } -> untyped

  alias each_key each_name

  def each_capitalized_name: () { (untyped) -> untyped } -> untyped

  def each_value: () { (untyped) -> untyped } -> untyped

  # Removes a header field, specified by case-insensitive key.
  def delete: (untyped key) -> untyped

  # true if +key+ header exists.
  def key?: (untyped key) -> untyped

  # Returns a Hash consisting of header names and array of values.
  # e.g.
  # {"cache-control" => ["private"],
  #  "content-type" => ["text/html"],
  #  "date" => ["Wed, 22 Jun 2005 22:11:50 GMT"]}
  def to_hash: () -> untyped

  # As for #each_header, except the keys are provided in capitalized form.
  #
  # Note that header names are capitalized systematically;
  # capitalization may not match that used by the remote HTTP
  # server in its response.
  #
  # Returns an enumerator if no block is given.
  def each_capitalized: () { (untyped, untyped) -> untyped } -> untyped

  alias canonical_each each_capitalized

  private

  def capitalize: (untyped name) -> untyped

  public

  # Returns an Array of Range objects which represent the Range:
  # HTTP header field, or +nil+ if there is no such header.
  def range: () -> (nil | untyped)

  # Sets the HTTP Range: header.
  # Accepts either a Range object as a single argument,
  # or a beginning index and a length from that index.
  # Example:
  #
  #   req.range = (0..1023)
  #   req.set_range 0, 1023
  #
  def set_range: (untyped r, ?untyped? e) -> untyped

  alias range= set_range

  # Returns an Integer object which represents the HTTP Content-Length:
  # header field, or +nil+ if that field was not provided.
  def content_length: () -> (nil | untyped)

  def content_length=: (untyped len) -> (nil | untyped)

  # Returns "true" if the "transfer-encoding" header is present and
  # set to "chunked".  This is an HTTP/1.1 feature, allowing
  # the content to be sent in "chunks" without at the outset
  # stating the entire content length.
  def chunked?: () -> (false | untyped)

  # Returns a Range object which represents the value of the Content-Range:
  # header field.
  # For a partial entity body, this indicates where this fragment
  # fits inside the full entity body, as range of byte offsets.
  def content_range: () -> (nil | ::Range[untyped])

  # The length of the range represented in Content-Range: header.
  def range_length: () -> (nil | untyped)

  # Returns a content type string such as "text/html".
  # This method returns nil if Content-Type: header field does not exist.
  def content_type: () -> (nil | untyped)

  # Returns a content type string such as "text".
  # This method returns nil if Content-Type: header field does not exist.
  def main_type: () -> (nil | untyped)

  # Returns a content type string such as "html".
  # This method returns nil if Content-Type: header field does not exist
  # or sub-type is not given (e.g. "Content-Type: text").
  def sub_type: () -> (nil | untyped)

  # Any parameters specified for the content type, returned as a Hash.
  # For example, a header of Content-Type: text/html; charset=EUC-JP
  # would result in type_params returning {'charset' => 'EUC-JP'}
  def type_params: () -> untyped

  # Sets the content type in an HTTP header.
  # The +type+ should be a full HTTP content type, e.g. "text/html".
  # The +params+ are an optional Hash of parameters to add after the
  # content type, e.g. {'charset' => 'iso-8859-1'}
  def set_content_type: (untyped `type`, ?::Hash[untyped, untyped] params) -> untyped

  alias content_type= set_content_type

  # Set header fields and a body from HTML form data.
  # +params+ should be an Array of Arrays or
  # a Hash containing HTML form data.
  # Optional argument +sep+ means data record separator.
  #
  # Values are URL encoded as necessary and the content-type is set to
  # application/x-www-form-urlencoded
  #
  # Example:
  #    http.form_data = {"q" => "ruby", "lang" => "en"}
  #    http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
  #    http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')
  #
  def set_form_data: (untyped params, ?::String sep) -> untyped

  alias form_data= set_form_data

  # Set an HTML form data set.
  # +params+ :: The form data to set, which should be an enumerable.
  #             See below for more details.
  # +enctype+ :: The content type to use to encode the form submission,
  #              which should be application/x-www-form-urlencoded or
  #              multipart/form-data.
  # +formopt+ :: An options hash, supporting the following options:
  #              :boundary :: The boundary of the multipart message. If
  #                           not given, a random boundary will be used.
  #              :charset :: The charset of the form submission. All
  #                          field names and values of non-file fields
  #                          should be encoded with this charset.
  #
  # Each item of params should respond to +each+ and yield 2-3 arguments,
  # or an array of 2-3 elements. The arguments yielded should be:
  #  * The name of the field.
  #  * The value of the field, it should be a String or a File or IO-like.
  #  * An options hash, supporting the following options, only
  #    used for file uploads:
  #    :filename :: The name of the file to use.
  #    :content_type :: The content type of the uploaded file.
  #
  # Each item is a file field or a normal field.
  # If +value+ is a File object or the +opt+ hash has a :filename key,
  # the item is treated as a file field.
  #
  # If Transfer-Encoding is set as chunked, this sends the request using
  # chunked encoding. Because chunked encoding is HTTP/1.1 feature,
  # you should confirm that the server supports HTTP/1.1 before using
  # chunked encoding.
  #
  # Example:
  #    req.set_form([["q", "ruby"], ["lang", "en"]])
  #
  #    req.set_form({"f"=>File.open('/path/to/filename')},
  #                 "multipart/form-data",
  #                 charset: "UTF-8",
  #    )
  #
  #    req.set_form([["f",
  #                   File.open('/path/to/filename.bar'),
  #                   {filename: "other-filename.foo"}
  #                 ]],
  #                 "multipart/form-data",
  #    )
  #
  # See also RFC 2388, RFC 2616, HTML 4.01, and HTML5
  #
  def set_form: (untyped params, ?::String enctype, ?::Hash[untyped, untyped] formopt) -> untyped

  # Set the Authorization: header for "Basic" authorization.
  def basic_auth: (untyped account, untyped password) -> untyped

  # Set Proxy-Authorization: header for "Basic" authorization.
  def proxy_basic_auth: (untyped account, untyped password) -> untyped

  private

  def basic_encode: (untyped account, untyped password) -> untyped

  public

  def connection_close?: () -> (true | false)

  def connection_keep_alive?: () -> (true | false)
end

module Net::HTTP::ProxyDelta
  private

  def conn_address: () -> untyped

  def conn_port: () -> untyped

  def edit_path: (untyped path) -> untyped
end

# frozen_string_literal: true
# :stopdoc:
# https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
class Net::HTTPUnknownResponse < Net::HTTPResponse
  HAS_BODY: true

  EXCEPTION_TYPE: untyped
end

class Net::HTTPInformation < Net::HTTPResponse
  # 1xx
  HAS_BODY: false

  EXCEPTION_TYPE: untyped
end

class Net::HTTPSuccess < Net::HTTPResponse
  # 2xx
  HAS_BODY: true

  EXCEPTION_TYPE: untyped
end

class Net::HTTPRedirection < Net::HTTPResponse
  # 3xx
  HAS_BODY: true

  EXCEPTION_TYPE: untyped
end

class Net::HTTPClientError < Net::HTTPResponse
  # 4xx
  HAS_BODY: true

  EXCEPTION_TYPE: untyped
end

class Net::HTTPServerError < Net::HTTPResponse
  # 5xx
  HAS_BODY: true

  EXCEPTION_TYPE: untyped
end

class Net::HTTPContinue < Net::HTTPInformation
  # 100
  HAS_BODY: false
end

class Net::HTTPSwitchProtocol < Net::HTTPInformation
  # 101
  HAS_BODY: false
end

class Net::HTTPProcessing < Net::HTTPInformation
  # 102
  HAS_BODY: false
end

class Net::HTTPEarlyHints < Net::HTTPInformation
  # 103 - RFC 8297
  HAS_BODY: false
end

class Net::HTTPOK < Net::HTTPSuccess
  # 200
  HAS_BODY: true
end

class Net::HTTPCreated < Net::HTTPSuccess
  # 201
  HAS_BODY: true
end

class Net::HTTPAccepted < Net::HTTPSuccess
  # 202
  HAS_BODY: true
end

class Net::HTTPNonAuthoritativeInformation < Net::HTTPSuccess
  # 203
  HAS_BODY: true
end

class Net::HTTPNoContent < Net::HTTPSuccess
  # 204
  HAS_BODY: false
end

class Net::HTTPResetContent < Net::HTTPSuccess
  # 205
  HAS_BODY: false
end

class Net::HTTPPartialContent < Net::HTTPSuccess
  # 206
  HAS_BODY: true
end

class Net::HTTPMultiStatus < Net::HTTPSuccess
  # 207 - RFC 4918
  HAS_BODY: true
end

class Net::HTTPAlreadyReported < Net::HTTPSuccess
  # 208 - RFC 5842
  HAS_BODY: true
end

class Net::HTTPIMUsed < Net::HTTPSuccess
  # 226 - RFC 3229
  HAS_BODY: true
end

class Net::HTTPMultipleChoices < Net::HTTPRedirection
  # 300
  HAS_BODY: true
end

Net::HTTPMultipleChoice: untyped

class Net::HTTPMovedPermanently < Net::HTTPRedirection
  # 301
  HAS_BODY: true
end

class Net::HTTPFound < Net::HTTPRedirection
  # 302
  HAS_BODY: true
end

Net::HTTPMovedTemporarily: untyped

class Net::HTTPSeeOther < Net::HTTPRedirection
  # 303
  HAS_BODY: true
end

class Net::HTTPNotModified < Net::HTTPRedirection
  # 304
  HAS_BODY: false
end

class Net::HTTPUseProxy < Net::HTTPRedirection
  # 305
  HAS_BODY: false
end

class Net::HTTPTemporaryRedirect < Net::HTTPRedirection
  # 306 Switch Proxy - no longer unused
  # 307
  HAS_BODY: true
end

class Net::HTTPPermanentRedirect < Net::HTTPRedirection
  # 308
  HAS_BODY: true
end

class Net::HTTPBadRequest < Net::HTTPClientError
  # 400
  HAS_BODY: true
end

class Net::HTTPUnauthorized < Net::HTTPClientError
  # 401
  HAS_BODY: true
end

class Net::HTTPPaymentRequired < Net::HTTPClientError
  # 402
  HAS_BODY: true
end

class Net::HTTPForbidden < Net::HTTPClientError
  # 403
  HAS_BODY: true
end

class Net::HTTPNotFound < Net::HTTPClientError
  # 404
  HAS_BODY: true
end

class Net::HTTPMethodNotAllowed < Net::HTTPClientError
  # 405
  HAS_BODY: true
end

class Net::HTTPNotAcceptable < Net::HTTPClientError
  # 406
  HAS_BODY: true
end

class Net::HTTPProxyAuthenticationRequired < Net::HTTPClientError
  # 407
  HAS_BODY: true
end

class Net::HTTPRequestTimeout < Net::HTTPClientError
  # 408
  HAS_BODY: true
end

Net::HTTPRequestTimeOut: untyped

class Net::HTTPConflict < Net::HTTPClientError
  # 409
  HAS_BODY: true
end

class Net::HTTPGone < Net::HTTPClientError
  # 410
  HAS_BODY: true
end

class Net::HTTPLengthRequired < Net::HTTPClientError
  # 411
  HAS_BODY: true
end

class Net::HTTPPreconditionFailed < Net::HTTPClientError
  # 412
  HAS_BODY: true
end

class Net::HTTPPayloadTooLarge < Net::HTTPClientError
  # 413
  HAS_BODY: true
end

Net::HTTPRequestEntityTooLarge: untyped

class Net::HTTPURITooLong < Net::HTTPClientError
  # 414
  HAS_BODY: true
end

Net::HTTPRequestURITooLong: untyped

Net::HTTPRequestURITooLarge: untyped

class Net::HTTPUnsupportedMediaType < Net::HTTPClientError
  # 415
  HAS_BODY: true
end

class Net::HTTPRangeNotSatisfiable < Net::HTTPClientError
  # 416
  HAS_BODY: true
end

Net::HTTPRequestedRangeNotSatisfiable: untyped

class Net::HTTPExpectationFailed < Net::HTTPClientError
  # 417
  HAS_BODY: true
end

class Net::HTTPMisdirectedRequest < Net::HTTPClientError
  # 418 I'm a teapot - RFC 2324; a joke RFC
  # 420 Enhance Your Calm - Twitter
  # 421 - RFC 7540
  HAS_BODY: true
end

class Net::HTTPUnprocessableEntity < Net::HTTPClientError
  # 422 - RFC 4918
  HAS_BODY: true
end

class Net::HTTPLocked < Net::HTTPClientError
  # 423 - RFC 4918
  HAS_BODY: true
end

class Net::HTTPFailedDependency < Net::HTTPClientError
  # 424 - RFC 4918
  HAS_BODY: true
end

class Net::HTTPUpgradeRequired < Net::HTTPClientError
  # 425 Unordered Collection - existed only in draft
  # 426 - RFC 2817
  HAS_BODY: true
end

class Net::HTTPPreconditionRequired < Net::HTTPClientError
  # 428 - RFC 6585
  HAS_BODY: true
end

class Net::HTTPTooManyRequests < Net::HTTPClientError
  # 429 - RFC 6585
  HAS_BODY: true
end

class Net::HTTPRequestHeaderFieldsTooLarge < Net::HTTPClientError
  # 431 - RFC 6585
  HAS_BODY: true
end

class Net::HTTPUnavailableForLegalReasons < Net::HTTPClientError
  # 451 - RFC 7725
  HAS_BODY: true
end

class Net::HTTPInternalServerError < Net::HTTPServerError
  # 500
  HAS_BODY: true
end

class Net::HTTPNotImplemented < Net::HTTPServerError
  # 501
  HAS_BODY: true
end

class Net::HTTPBadGateway < Net::HTTPServerError
  # 502
  HAS_BODY: true
end

class Net::HTTPServiceUnavailable < Net::HTTPServerError
  # 503
  HAS_BODY: true
end

class Net::HTTPGatewayTimeout < Net::HTTPServerError
  # 504
  HAS_BODY: true
end

Net::HTTPGatewayTimeOut: untyped

class Net::HTTPVersionNotSupported < Net::HTTPServerError
  # 505
  HAS_BODY: true
end

class Net::HTTPVariantAlsoNegotiates < Net::HTTPServerError
  # 506
  HAS_BODY: true
end

class Net::HTTPInsufficientStorage < Net::HTTPServerError
  # 507 - RFC 4918
  HAS_BODY: true
end

class Net::HTTPLoopDetected < Net::HTTPServerError
  # 508 - RFC 5842
  HAS_BODY: true
end

class Net::HTTPNotExtended < Net::HTTPServerError
  # 509 Bandwidth Limit Exceeded - Apache bw/limited extension
  # 510 - RFC 2774
  HAS_BODY: true
end

class Net::HTTPNetworkAuthenticationRequired < Net::HTTPServerError
  # 511 - RFC 6585
  HAS_BODY: true
end

class Net::HTTPResponse
  CODE_CLASS_TO_OBJ: ::Hash[::String, untyped]

  CODE_TO_OBJ: ::Hash[::String, untyped]
end
