
class Object
  def remove_local_multiverse_databases: () -> untyped

  def remove_generated_gemfiles: () -> untyped

  def remove_generated_gemfile_lockfiles: () -> untyped
end


module Sequel
  module Plugins
    # Sequel::Model instrumentation for the New Relic agent.
    module NewrelicInstrumentation
      # Meta-programming for creating method tracers for the Sequel::Model plugin.
      module MethodWrapping
        # Install a method named +method_name+ that will trace execution
        # with a metric name derived from +operation_name+ (or +method_name+ if +operation_name+
        # isn't specified).
        def wrap_sequel_method: (untyped method_name, ?untyped operation_name) -> untyped
      end

      # Methods to be added to Sequel::Model instances.
      module InstanceMethods
        extend Sequel::Plugins::NewrelicInstrumentation::MethodWrapping
      end

      # Methods to be added to Sequel::Model classes.
      module ClassMethods
        extend Sequel::Plugins::NewrelicInstrumentation::MethodWrapping
      end
    end
  end
end

module Sequel
  # New Relic's Sequel instrumentation is implemented via a plugin for
  # Sequel::Models, and an extension for Sequel::Databases. Every database
  # handle that Sequel knows about when New Relic is loaded will automatically
  # be instrumented, but if you're using a version of Sequel before 3.47.0,
  # you'll need to add the extension yourself if you create any after the
  # instrumentation is loaded:
  #
  #     db = Sequel.connect( ... )
  #     db.extension :newrelic_instrumentation
  #
  # Versions 3.47.0 and later use `Database.extension` to automatically
  # install the extension for new connections.
  #
  # == Disabling
  #
  # If you don't want your models or database connections to be instrumented,
  # you can disable them by setting `disable_database_instrumentation` in
  # your `newrelic.yml` to `true`. It will also honor the
  # `disable_activerecord_instrumentation` setting.
  #
  module NewRelicInstrumentation
    module Naming
      def self.query_method_name: () -> untyped
    end

    # We notice sql through the current_segment due to the disable_all_tracing
    # block in the sequel Plugin instrumentation. A simple ORM operation from the Plugin
    # instrumentation may trigger a number of calls to this method. We want to append
    # the statements that come from the disable_all_tracing block into this node's
    # statement, otherwise we would end up ovewriting the sql statement with the
    # last one executed.
    def notice_sql: (untyped sql) -> (nil | untyped)

    THREAD_SAFE_CONNECTION_POOL_CLASSES: ::Array[untyped]

    def explainer_for: (untyped sql) -> untyped
  end
end

module NewRelic
  class Railtie < Rails::Railtie
  end
end

module NewRelic
  module SupportabilityHelper
    API_SUPPORTABILITY_PREFIX: "Supportability/API/"

    # pre-instantiate these strings as they may be used multiple times per
    # transaction, just to eke out a bit less performance hit
    #
    API_SUPPORTABILITY_METRICS: untyped

    def record_api_supportability_metric: (untyped method_name) -> (nil | untyped)

    def valid_api_argument_class?: (untyped arg, untyped name, untyped klass) -> (true | nil)
  end
end

module NewRelic
  class MetricData
    # a NewRelic::MetricSpec object
    attr_reader metric_spec: untyped

    # the actual statistics object
    attr_accessor stats: untyped

    def initialize: (untyped metric_spec, untyped stats) -> void

    def eql?: (untyped o) -> untyped

    def original_spec: () -> untyped

    # assigns a new metric spec, and retains the old metric spec as
    # @original_spec if it exists currently
    def metric_spec=: (untyped new_spec) -> untyped

    def hash: () -> untyped

    def to_json: (*untyped a) -> ::String

    def to_s: () -> ::String

    def inspect: () -> ::String

    include NewRelic::Coerce

    def to_collector_array: (?untyped? encoder) -> ::Array[untyped | ::Array[untyped]]
  end
end

# @api public
module NewRelic
  # This module contains most of the public API methods for the Ruby Agent.
  #
  # For adding custom instrumentation to method invocations, see
  # the docs for {NewRelic::Agent::MethodTracer} and
  # {NewRelic::Agent::MethodTracer::ClassMethods}.
  #
  # For information on how to trace transactions in non-Rack contexts,
  # see {NewRelic::Agent::Instrumentation::ControllerInstrumentation}.
  #
  # For general documentation about the Ruby agent, see:
  # https://docs.newrelic.com/docs/agents/ruby-agent
  #
  # @api public
  #
  module Agent
    extend ::NewRelic::Agent

    # extend Forwardable

    extend NewRelic::SupportabilityHelper

    # An exception that is thrown by the server if the agent license is invalid.
    class LicenseException < StandardError
    end

    # An exception that forces an agent to stop reporting until its mongrel is restarted.
    class ForceDisconnectException < StandardError
    end

    # An exception that forces an agent to restart.
    class ForceRestartException < StandardError
      def message: () -> ::String
    end

    # Used to blow out of a periodic task without logging a an error, such as for routine
    # failures.
    class ServerConnectionException < StandardError
    end

    # When a post is either too large or poorly formatted we should
    # drop it and not try to resend
    class UnrecoverableServerException < ServerConnectionException
    end

    # An unrecoverable client-side error that prevents the agent from continuing
    class UnrecoverableAgentException < ServerConnectionException
    end

    # An error while serializing data for the collector
    class SerializationError < StandardError
    end

    class BackgroundLoadingError < StandardError
    end

    # placeholder name used when we cannot determine a transaction's name
    UNKNOWN_METRIC: "(unknown)"

    def agent: () -> (untyped | nil)

    def agent=: (untyped new_instance) -> untyped

    alias instance agent

    # Primary interface to logging is fronted by this accessor
    # Access via ::NewRelic::Agent.logger
    def logger: () -> untyped

    def logger=: (untyped log) -> untyped

    # A third-party class may call add_method_tracer before the agent
    # is initialized; these methods enable us to defer these calls
    # until we have started up and can process them.
    #
    def add_or_defer_method_tracer: (untyped receiver, untyped method_name, untyped metric_name, untyped options) -> untyped

    def add_deferred_method_tracers_now: () -> untyped

    def config: () -> untyped

    # For testing
    # Important that we don't change the instance or we orphan callbacks
    def reset_config: () -> untyped

    def record_metric: (untyped metric_name, untyped value) -> (nil | untyped)

    SUPPORTABILITY_INCREMENT_METRIC: "Supportability/API/increment_metric"

    def increment_metric: (untyped metric_name, ?::Integer amount) -> (nil | untyped)

    # Set a filter to be applied to errors that the Ruby Agent will
    # track.  The block should evalute to the exception to track
    # (which could be different from the original exception) or nil to
    # ignore this exception.
    #
    # The block is yielded to with the exception to filter.
    #
    # Return the new block or the existing filter Proc if no block is passed.
    #
    # @api public
    #
    def ignore_error_filter: () { () -> untyped } -> untyped

    # Send an error to New Relic.
    #
    # @param [Exception] exception Error you wish to send
    # @param [Hash]      options Modify how New Relic processes the error
    # @option options [Hash]    :custom_params Custom parameters to attach to the trace
    # @option options [Boolean] :expected Only record the error trace
    #                           (do not affect error rate or Apdex status)
    # @option options [String]  :uri Request path, minus request params or query string
    #                           (usually not needed)
    # @option options [String]  :metric Metric name associated with the transaction
    #                           (usually not needed)
    #
    # Any option keys other than the ones listed here are treated as
    # <code>:custom_params</code>.
    #
    # *Note:* Previous versions of the agent allowed passing
    # <code>:request_params</code>, but those are now ignored.  If you
    # need to record the request parameters, call this method inside a
    # transaction or pass the information in
    # <code>:custom_params</code>.
    #
    # Most of the time, you do not need to specify the
    # <code>:uri</code> or <code>:metric</code> options; only pass
    # them if you are calling <code>notice_error</code> outside a
    # transaction.
    #
    # @api public
    #
    def notice_error: (untyped exception, ?::Hash[untyped, untyped] options) -> nil

    # Record a custom event to be sent to New Relic Insights.
    # The recorded event will be buffered in memory until the next time the
    # agent sends data to New Relic's servers.
    #
    # If you want to be able to tie the information recorded via this call back
    # to the web request or background job that it happened in, you may want to
    # instead use the add_custom_attributes API call to attach attributes to
    # the Transaction event that will automatically be generated for the
    # request.
    #
    # A timestamp will be automatically added to the recorded event when this
    # method is called.
    #
    # @param [Symbol or String] event_type The name of the event type to record. Event
    #                           types must consist of only alphanumeric
    #                           characters, '_', ':', or ' '.
    #
    # @param [Hash] event_attrs A Hash of attributes to be attached to the event.
    #                           Keys should be strings or symbols, and values
    #                           may be strings, symbols, numeric values or
    #                           booleans.
    #
    # @api public
    #
    def record_custom_event: (untyped event_type, untyped event_attrs) -> nil

    # Call this to manually start the Agent in situations where the Agent does
    # not auto-start.
    #
    # When the app environment loads, so does the Agent. However, the
    # Agent will only connect to the service if a web front-end is found. If
    # you want to selectively monitor ruby processes that don't use
    # web plugins, then call this method in your code and the Agent
    # will fire up and start reporting to the service.
    #
    # Options are passed in as overrides for values in the
    # newrelic.yml, such as app_name.  In addition, the option +log+
    # will take a logger that will be used instead of the standard
    # file logger.  The setting for the newrelic.yml section to use
    # (ie, RAILS_ENV) can be overridden with an :env argument.
    #
    # @api public
    #
    def manual_start: (?::Hash[untyped, untyped] options) -> untyped

    # Register this method as a callback for processes that fork
    # jobs.
    #
    # If the master/parent connects to the agent prior to forking the
    # agent in the forked process will use that agent_run.  Otherwise
    # the forked process will establish a new connection with the
    # server.
    #
    # Use this especially when you fork the process to run background
    # jobs or other work.  If you are doing this with a web dispatcher
    # that forks worker processes then you will need to force the
    # agent to reconnect, which it won't do by default.  Passenger and
    # Rainbows and Unicorn are already handled, nothing special needed for them.
    #
    # Options:
    # * <tt>:force_reconnect => true</tt> to force the spawned process to
    #   establish a new connection, such as when forking a long running process.
    #   The default is false--it will only connect to the server if the parent
    #   had not connected.
    # * <tt>:keep_retrying => false</tt> if we try to initiate a new
    #   connection, this tells me to only try it once so this method returns
    #   quickly if there is some kind of latency with the server.
    #
    # @api public
    #
    def after_fork: (?::Hash[untyped, untyped] options) -> untyped

    # Shutdown the agent.  Call this before exiting.  Sends any queued data
    # and kills the background thread.
    #
    # @param options [Hash] Unused options Hash, for back compatibility only
    #
    # @api public
    #
    def shutdown: (?::Hash[untyped, untyped] options) -> untyped

    # Clear out any data the agent has buffered but has not yet transmitted
    # to the collector.
    #
    # @api public
    def drop_buffered_data: () -> untyped

    # Add instrumentation files to the agent.  The argument should be
    # a glob matching ruby scripts which will be executed at the time
    # instrumentation is loaded.  Since instrumentation is not loaded
    # when the agent is not running it's better to use this method to
    # register instrumentation than just loading the files directly,
    # although that probably also works.
    #
    # @api public
    #
    def add_instrumentation: (untyped file_pattern) -> untyped

    # Require agent testing helper methods
    #
    # @api public
    def require_test_helper: () -> untyped

    # This method sets the block sent to this method as a sql
    # obfuscator.  The block will be called with a single String SQL
    # statement to obfuscate.  The method must return the obfuscated
    # String SQL.  If chaining of obfuscators is required, use type =
    # :before or :after
    #
    # type = :before, :replace, :after
    #
    # Example:
    #
    #    NewRelic::Agent.set_sql_obfuscator(:replace) do |sql|
    #       my_obfuscator(sql)
    #    end
    #
    # @api public
    #
    def set_sql_obfuscator: (?::Symbol `type`) { () -> untyped } -> untyped

    # This method disables the recording of the current transaction. No metrics,
    # traced errors, transaction traces, Insights events, slow SQL traces,
    # or RUM injection will happen for this transaction.
    #
    # @api public
    #
    def ignore_transaction: () -> untyped

    # This method disables the recording of Apdex metrics in the current
    # transaction.
    #
    # @api public
    #
    def ignore_apdex: () -> untyped

    # This method disables browser monitoring javascript injection in the
    # current transaction.
    #
    # @api public
    #
    def ignore_enduser: () -> untyped

    # Yield to the block without collecting any metrics or traces in
    # any of the subsequent calls.  If executed recursively, will keep
    # track of the first entry point and turn on tracing again after
    # leaving that block.  This uses the thread local Tracer::State.
    #
    # @api public
    #
    def disable_all_tracing: () { () -> untyped } -> untyped

    # This method disables the recording of transaction traces in the given
    # block.  See also #disable_all_tracing
    #
    # @api public
    #
    def disable_transaction_tracing: () { () -> untyped } -> untyped

    # This method sets the state of sql recording in the transaction
    # sampler feature. Within the given block, no sql will be recorded
    #
    # usage:
    #
    #   NewRelic::Agent.disable_sql_recording do
    #     ...
    #   end
    #
    # @api public
    #
    def disable_sql_recording: () { () -> untyped } -> untyped

    # Check to see if we are capturing metrics currently on this thread.
    def tl_is_execution_traced?: () -> untyped

    # helper method to check the thread local to determine whether sql
    # is being recorded or not
    def tl_is_sql_recorded?: () -> untyped

    def add_custom_attributes: (untyped params) -> untyped

    # Add custom attributes to the span event for the current span. Attributes will be visible on spans in the
    # New Relic Distributed Tracing UI and on span events in New Relic Insights.
    #
    # Custom attributes will not be transmitted when +high_security+ setting is enabled or
    # +custom_attributes+ setting is disabled.
    #
    # @param [Hash] params      A Hash of attributes to be attached to the span event.
    #                           Keys should be strings or symbols, and values
    #                           may be strings, symbols, numeric values or
    #                           booleans.
    #
    # @see https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary#span
    # @api public
    def add_custom_span_attributes: (untyped params) -> untyped

    # Set the name of the current running transaction.  The agent will
    # apply a reasonable default based on framework routing, but in
    # cases where this is insufficient, this can be used to manually
    # control the name of the transaction.
    #
    # The category of transaction can be specified via the +:category+ option.
    # The following are the only valid categories:
    #
    # * <tt>:category => :controller</tt> indicates that this is a
    #   controller action and will appear with all the other actions.
    # * <tt>:category => :task</tt> indicates that this is a
    #   background task and will show up in New Relic with other background
    #   tasks instead of in the controllers list
    # * <tt>:category => :middleware</tt> if you are instrumenting a rack
    #   middleware call.  The <tt>:name</tt> is optional, useful if you
    #   have more than one potential transaction in the #call.
    # * <tt>:category => :uri</tt> indicates that this is a
    #   web transaction whose name is a normalized URI, where  'normalized'
    #   means the URI does not have any elements with data in them such
    #   as in many REST URIs.
    #
    # The default category is the same as the running transaction.
    #
    # @api public
    #
    def set_transaction_name: (untyped name, ?::Hash[untyped, untyped] options) -> untyped

    def get_transaction_name: () -> untyped

    # Yield to a block that is run with a database metric name context.  This means
    # the Database instrumentation will use this for the metric name if it does not
    # otherwise know about a model.  This is re-entrant.
    #
    # @param [String,Class,#to_s] model the DB model class
    #
    # @param [String] method the name of the finder method or other method to
    # identify the operation with.
    #
    def with_database_metric_name: (untyped model, ?untyped? method, ?untyped? product) { () -> untyped } -> untyped

    # Subscribe to events of +event_type+, calling the given +handler+
    # when one is sent.
    def subscribe: (untyped event_type) { () -> untyped } -> untyped

    # Fire an event of the specified +event_type+, passing it an the given +args+
    # to any registered handlers.
    def notify: (untyped event_type, *untyped args) -> untyped

    TRACE_ID_KEY: "trace.id"

    SPAN_ID_KEY: "span.id"

    ENTITY_NAME_KEY: "entity.name"

    ENTITY_TYPE_KEY: "entity.type"

    ENTITY_GUID_KEY: "entity.guid"

    HOSTNAME_KEY: "hostname"

    ENTITY_TYPE: "SERVICE"

    # Returns a new hash containing trace and entity metadata that can be used
    # to relate data to a trace or to an entity in APM.
    #
    # This hash includes:
    # * trace.id    - The current trace id, if there is a current trace id. This
    #   value may be omitted.
    # * span.id     - The current span id, if there is a current span.  This
    #   value may be omitted.
    # * entity.name - The name of the current application. This is read from
    #   the +app_name+ key in your config.  If there are multiple application
    #   names, the first one is used.
    # * entity.type - The entity type is hardcoded to the string +'SERVICE'+.
    # * entity.guid - The guid of the current entity.
    # * hostname    - The fully qualified hostname.
    #
    # @api public
    def linking_metadata: () -> untyped

    # This method returns a string suitable for inclusion in a page - known as
    # 'manual instrumentation' for Real User Monitoring. Can return either a
    # script tag with associated javascript, or in the case of disabled Real
    # User Monitoring, an empty string
    #
    # This is the header string - it should be placed as high in the page as is
    # reasonably possible - that is, before any style or javascript inclusions,
    # but after any header-related meta tags
    #
    # In previous agents there was a corresponding footer required, but all the
    # work is now done by this single method.
    #
    # @param [String] nonce The nonce to use in the javascript tag for browser instrumentation
    #
    # @api public
    #
    def browser_timing_header: (?untyped? nonce) -> (::String | untyped)
  end
end

module NewRelic
  class CommandExecutableNotFoundError < StandardError
  end

  class CommandRunFailedError < StandardError
  end

  # A singleton for shared generic helper methods
  module Helper
    extend ::NewRelic::Helper

    # Confirm a string is correctly encoded,
    # If not force the encoding to ASCII-8BIT (binary)
    def correctly_encoded: (untyped string) -> untyped

    def instance_method_visibility: (untyped klass, untyped method_name) -> untyped

    def instance_methods_include?: (untyped klass, untyped method_name) -> untyped

    def time_to_millis: (untyped time) -> untyped

    def run_command: (untyped command) -> untyped

    # TODO: Open3 defers the actual excecution of a binary to Process.spawn,
    #       which will raise an Errno::ENOENT exception for a file that
    #       cannot be found. We might want to take the time to evaluate
    #       relying on that Process.spawn behavior instead of checking for
    #       existence ourselves. We'd need to see what it does, how efficient
    #       it is, if it differs in functionality between Ruby versions and
    #       operating systems, etc.
    def executable_in_path?: (untyped executable) -> (false | untyped)
  end
end


module NewRelic
  # This class is responsible for determining the 'dispatcher' in use by the
  # current process. The dispatcher might be a recognized web server such as
  # unicorn or passenger, a background job processor such as resque or sidekiq,
  # or nil for unknown.
  #
  # Dispatcher detection is best-effort, and serves two purposes:
  #
  # 1. For some dispatchers, we need to apply specific workarounds in order for
  #    the agent to work correctly.
  # 2. When reading logs, since multiple processes on a given host might write
  #    into the same log, it's useful to be able to identify what kind of
  #    process a given PID mapped to.
  #
  # Overriding the dispatcher is possible via the NEW_RELIC_DISPATCHER
  # environment variable, but this should not generally be necessary unless
  # you're on a dispatcher that falls into category 1 above, and our detection
  # logic isn't working correctly.
  #
  # If the environment can't be determined, it will be set to nil.
  #
  # NewRelic::LocalEnvironment should be accessed through NewRelic::Control#env (via the NewRelic::Control singleton).
  class LocalEnvironment
    def discovered_dispatcher: () -> untyped

    def initialize: () -> void

    # Runs through all the objects in ObjectSpace to find the first one that
    # match the provided class
    def find_class_in_object_space: (untyped klass) -> (untyped | nil)

    private

    def discover_dispatcher: () -> untyped

    def check_for_torquebox: () -> (nil | untyped)

    def check_for_glassfish: () -> (nil | untyped)

    def check_for_trinidad: () -> (nil | untyped)

    def jruby_rack?: () -> untyped

    def check_for_webrick: () -> (nil | untyped)

    def check_for_fastcgi: () -> (nil | untyped)

    # this case covers starting by mongrel_rails
    def check_for_mongrel: () -> (nil | untyped)

    def check_for_unicorn: () -> untyped

    def check_for_rainbows: () -> untyped

    def check_for_puma: () -> untyped

    def check_for_delayed_job: () -> untyped

    def check_for_resque: () -> untyped

    def check_for_sidekiq: () -> untyped

    def check_for_thin: () -> untyped

    def check_for_litespeed: () -> untyped

    def check_for_passenger: () -> untyped

    public

    # outputs a human-readable description
    def to_s: () -> untyped

    def executable: () -> untyped
  end
end

module NewRelic
  module LatestChanges
    def self.default_changelog: () -> untyped

    FOOTER: ::String

    def self.read: (?untyped changelog) -> untyped

    # Patches are expected to have the format of our normal item, with the
    # precise version number included in the line in parens. For example:
    #
    # * This is a patch item (3.7.1.188)
    def self.read_patch: (untyped patch_level, ?untyped changelog) -> untyped

    def self.extract_latest_changes: (untyped contents) -> untyped
  end
end

module NewRelic
  module Agent
    class DatabaseAdapter
      VERSIONS: ::Hash[::String, untyped]

      def self.value: () -> (nil | untyped)

      attr_reader env: untyped

      attr_reader version: untyped

      def initialize: (untyped env, untyped version) -> void

      def value: () -> (nil | untyped)
    end
  end
end

# This class is used by NewRelic::Agent.set_sql_obfuscator to chain multiple
# obfuscation blocks when not using the default :replace action
class NewRelic::ChainedCall
  def initialize: (untyped block1, untyped block2) -> void

  def call: (untyped sql) -> untyped
end

module NewRelic
  module Agent
    #
    # This class helps you interact with the current transaction (if
    # it exists), start new transactions/segments, etc.
    #
    # @api public
    class Tracer
      def self.state: () -> untyped

      alias self.tl_get self.state

      # Returns +true+ unless called from within an
      # +NewRelic::Agent.disable_all_tracing+ block.
      #
      # @api public
      def self.tracing_enabled?: () -> untyped

      # Returns the transaction in progress for this thread, or
      # +nil+ if none exists.
      #
      # @api public
      def self.current_transaction: () -> untyped

      # Returns the trace_id of the current_transaction, or +nil+ if
      # none exists.
      #
      # @api public
      def self.current_trace_id: () -> untyped

      alias self.trace_id self.current_trace_id

      # Returns the id of the current span, or +nil+ if none exists.
      #
      # @api public
      def self.current_span_id: () -> untyped

      alias self.span_id self.current_span_id

      # Returns a boolean indicating whether the current_transaction
      # is sampled, or +nil+ if there is no current transaction.
      #
      # @api public
      def self.transaction_sampled?: () -> untyped

      alias self.sampled? self.transaction_sampled?

      # Runs the given block of code in a transaction.
      #
      # @param [String] name reserved for New Relic internal use
      #
      # @param [String] partial_name a meaningful name for this
      #   transaction (e.g., +blogs/index+); the Ruby agent will add a
      #   New-Relic-specific prefix
      #
      # @param [Symbol] category +:web+ for web transactions or
      #   +:background+ for background transactions
      #
      # @param [Hash] options reserved for New Relic internal use
      #
      # @api public
      def self.in_transaction: (?name: untyped? name, ?partial_name: untyped? partial_name, ?category: untyped? category, ?options: ::Hash[untyped, untyped] options) { () -> untyped } -> untyped

      # Starts a segment on the current transaction (if one exists)
      # or starts a new transaction otherwise.
      #
      # @param [String] name reserved for New Relic internal use
      #
      # @param [String] partial_name a meaningful name for this
      #   transaction (e.g., +blogs/index+); the Ruby agent will add a
      #   New-Relic-specific prefix
      #
      # @param [Symbol] category +:web+ for web transactions or
      #   +:task+ for background transactions
      #
      # @param [Hash] options reserved for New Relic internal use
      #
      # @return [Object, #finish] an object that responds to
      #   +finish+; you _must_ call +finish+ on it at the end of the
      #   code you're tracing
      #
      # @api public
      def self.start_transaction_or_segment: (category: untyped category, ?name: untyped? name, ?partial_name: untyped? partial_name, ?options: ::Hash[untyped, untyped] options) -> untyped

      # Takes name or partial_name and a category.
      # Returns a transaction instance or nil
      def self.start_transaction: (category: untyped category, ?name: untyped? name, ?partial_name: untyped? partial_name, **untyped options) -> untyped

      def self.create_distributed_trace_payload: () -> (nil | untyped)

      def self.accept_distributed_trace_payload: (untyped payload) -> (nil | untyped)

      # Returns the currently active segment in the transaction in
      # progress for this thread, or +nil+ if no segment or
      # transaction exists.
      #
      # @api public
      def self.current_segment: () -> (nil | untyped)

      # Creates and starts a general-purpose segment used to time
      # arbitrary code.
      #
      # @param [String] name full name of the segment; the agent
      #   will not add a prefix. Third-party users should begin the
      #   name with +Custom/+; e.g.,
      #   +Custom/UserMailer/send_welcome_email+
      #
      # @param [optional, String, Array] unscoped_metrics additional
      #   unscoped metrics to record using this segment's timing
      #   information
      #
      # @param start_time [optional, Time] a +Time+ instance
      #   denoting the start time of the segment. Value is set by
      #   AbstractSegment#start if not given.
      #
      # @param parent [optional, Segment] Use for the rare cases
      #   (such as async) where the parent segment should be something
      #   other than the current segment
      #
      # @return [Segment] the newly created segment; you _must_ call
      #   +finish+ on it at the end of the code you're tracing
      #
      # @api public
      def self.start_segment: (name: untyped name, ?unscoped_metrics: untyped? unscoped_metrics, ?start_time: untyped? start_time, ?parent: untyped? parent) -> untyped

      UNKNOWN: "Unknown"

      OTHER: "other"

      # Creates and starts a datastore segment used to time
      # datastore operations.
      #
      # @param [String] product the datastore name for use in metric
      #   naming, e.g. "FauxDB"
      #
      # @param [String] operation the name of the operation
      #   (e.g. "select"), often named after the method that's being
      #   instrumented.
      #
      # @param [optional, String] collection the collection name for use in
      #   statement-level metrics (i.e. table or model name)
      #
      # @param [optional, String] host the host this database
      #   instance is running on
      #
      # @param [optional, String] port_path_or_id TCP port, file
      #   path, UNIX domain socket, or other connection-related info
      #
      # @param [optional, String] database_name the name of this
      #   database
      #
      # @param start_time [optional, Time] a +Time+ instance
      #   denoting the start time of the segment. Value is set by
      #   AbstractSegment#start if not given.
      #
      # @param parent [optional, Segment] Use for the rare cases
      #   (such as async) where the parent segment should be something
      #   other than the current segment
      #
      # @return [DatastoreSegment] the newly created segment; you
      #   _must_ call +finish+ on it at the end of the code you're
      #   tracing
      #
      # @api public
      def self.start_datastore_segment: (?product: untyped? product, ?operation: untyped? operation, ?collection: untyped? collection, ?host: untyped? host, ?port_path_or_id: untyped? port_path_or_id, ?database_name: untyped? database_name, ?start_time: untyped? start_time, ?parent: untyped? parent) -> untyped

      # Creates and starts an external request segment using the
      # given library, URI, and procedure. This is used to time
      # external calls made over HTTP.
      #
      # @param [String] library a string of the class name of the library used to
      #   make the external call, for example, 'Net::HTTP'.
      #
      # @param [String, URI] uri indicates the URI to which the
      #   external request is being made. The URI should begin with the protocol,
      #   for example, 'https://github.com'.
      #
      # @param [String] procedure the HTTP method being used for the external
      #   request as a string, for example, 'GET'.
      #
      # @param start_time [optional, Time] a +Time+ instance
      #   denoting the start time of the segment. Value is set by
      #   AbstractSegment#start if not given.
      #
      # @param parent [optional, Segment] Use for the rare cases
      #   (such as async) where the parent segment should be something
      #   other than the current segment
      #
      # @return [ExternalRequestSegment] the newly created segment;
      #   you _must_ call +finish+ on it at the end of the code
      #   you're tracing
      #
      # @api public
      def self.start_external_request_segment: (library: untyped library, uri: untyped uri, procedure: untyped procedure, ?start_time: untyped? start_time, ?parent: untyped? parent) -> untyped

      # Will potentially capture and notice an error at the
      # segment that was executing when error occurred.
      # if passed +segment+ is something that doesn't
      # respond to +notice_segment_error+ then this method
      # is effectively just a yield to the given &block
      def self.capture_segment_error: (untyped segment) { () -> untyped } -> untyped

      # For New Relic internal use only.
      def self.start_message_broker_segment: (action: untyped action, library: untyped library, destination_type: untyped destination_type, destination_name: untyped destination_name, ?headers: untyped? headers, ?parameters: untyped? parameters, ?start_time: untyped? start_time, ?parent: untyped? parent) -> untyped

      # This method should only be used by Tracer for access to the
      # current thread's state or to provide read-only accessors for other threads
      #
      # If ever exposed, this requires additional synchronization
      def self.state_for: (untyped thread) -> untyped

      alias self.tl_state_for self.state_for

      def self.clear_state: () -> untyped

      alias self.tl_clear self.clear_state

      private

      def self.start_and_add_segment: (untyped segment, ?untyped? parent) -> untyped

      def self.log_error: (untyped method_name, untyped exception) -> nil

      public

      # This is THE location to store thread local information during a transaction
      # Need a new piece of data? Add a method here, NOT a new thread local variable.
      class State
        def initialize: () -> void

        # This starts the timer for the transaction.
        def reset: (?untyped? transaction) -> untyped

        # Current transaction stack
        attr_reader current_transaction: untyped

        # Execution tracing on current thread
        attr_accessor untraced: untyped

        def push_traced: (untyped should_trace) -> untyped

        def pop_traced: () -> untyped

        def is_execution_traced?: () -> untyped

        alias tracing_enabled? is_execution_traced?

        # TT's and SQL
        attr_accessor record_sql: untyped

        def is_sql_recorded?: () -> untyped

        # Sql Sampler Transaction Data
        attr_accessor sql_sampler_transaction_data: untyped
      end
    end

    TransactionState: untyped
  end
end

module NewRelic
  module Agent
    module SpanEventPrimitive
      include NewRelic::Coerce

      extend ::NewRelic::Agent::SpanEventPrimitive

      # Strings for static keys of the event structure
      ELLIPSIS: "..."

      TYPE_KEY: "type"

      TRACE_ID_KEY: "traceId"

      GUID_KEY: "guid"

      PARENT_ID_KEY: "parentId"

      GRANDPARENT_ID_KEY: "grandparentId"

      TRANSACTION_ID_KEY: "transactionId"

      SAMPLED_KEY: "sampled"

      PRIORITY_KEY: "priority"

      TIMESTAMP_KEY: "timestamp"

      DURATION_KEY: "duration"

      NAME_KEY: "name"

      CATEGORY_KEY: "category"

      HTTP_URL_KEY: "http.url"

      HTTP_METHOD_KEY: "http.method"

      HTTP_STATUS_CODE_KEY: "http.statusCode"

      COMPONENT_KEY: "component"

      DB_INSTANCE_KEY: "db.instance"

      DB_STATEMENT_KEY: "db.statement"

      PEER_ADDRESS_KEY: "peer.address"

      PEER_HOSTNAME_KEY: "peer.hostname"

      SPAN_KIND_KEY: "span.kind"

      ENTRY_POINT_KEY: "nr.entryPoint"

      TRUSTED_PARENT_KEY: "trustedParentId"

      TRACING_VENDORS_KEY: "tracingVendors"

      TRANSACTION_NAME_KEY: "transaction.name"

      # Strings for static values of the event structure
      EVENT_TYPE: "Span"

      GENERIC_CATEGORY: "generic"

      HTTP_CATEGORY: "http"

      DATASTORE_CATEGORY: "datastore"

      CLIENT: "client"

      # Builds a Hash of error attributes as well as the Span ID when
      # an error is present.  Otherwise, returns nil when no error present.
      def error_attributes: (untyped segment) -> (nil | untyped)

      def for_segment: (untyped segment) -> ::Array[untyped]

      def for_external_request_segment: (untyped segment) -> ::Array[untyped]

      def for_datastore_segment: (untyped segment) -> ::Array[untyped]

      private

      def intrinsics_for: (untyped segment) -> untyped

      def custom_attributes: (untyped segment) -> untyped

      def merge_and_freeze_attributes: (untyped agent_attributes, untyped error_attributes) -> untyped

      def agent_attributes: (untyped segment) -> untyped

      def parent_guid: (untyped segment) -> untyped

      def milliseconds_since_epoch: (untyped segment) -> untyped

      def truncate: (untyped value, ?::Integer max_size) -> untyped

      def allowed?: (untyped key) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class TransactionEventAggregator < EventAggregator
      def record: (?priority: untyped? priority, ?event: untyped? event) { () -> untyped } -> (nil | untyped)

      private

      def after_harvest: (untyped metadata) -> (nil | untyped)

      def record_sampling_rate: (untyped metadata) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class InboundRequestMonitor
      attr_reader obfuscator: untyped

      def initialize: (untyped events) -> void

      def setup_obfuscator: () -> untyped

      def deserialize_header: (untyped encoded_header, untyped key) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class SyntheticsMonitor < InboundRequestMonitor
      SYNTHETICS_HEADER_KEY: "HTTP_X_NEWRELIC_SYNTHETICS"

      SUPPORTED_VERSION: 1

      EXPECTED_PAYLOAD_LENGTH: 5

      def on_finished_configuring: (untyped events) -> untyped

      def on_before_call: (untyped request) -> (nil | untyped)

      def self.is_supported_version?: (untyped incoming_payload) -> untyped

      def self.is_trusted?: (untyped incoming_payload) -> untyped

      def self.is_valid_payload?: (untyped incoming_payload) -> untyped

      def self.reject_messaging_synthetics_header: (untyped headers) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module DistributedTracing
      class CrossAppMonitor < InboundRequestMonitor
        NEWRELIC_ID_HEADER: "X-NewRelic-ID"

        NEWRELIC_TXN_HEADER: "X-NewRelic-Transaction"

        NEWRELIC_APPDATA_HEADER: "X-NewRelic-App-Data"

        NEWRELIC_ID_HEADER_KEY: "HTTP_X_NEWRELIC_ID"

        NEWRELIC_TXN_HEADER_KEY: "HTTP_X_NEWRELIC_TRANSACTION"

        CONTENT_LENGTH_HEADER_KEY: "HTTP_CONTENT_LENGTH"

        def on_finished_configuring: (untyped events) -> untyped

        def path_hash: (untyped txn_name, untyped seed) -> untyped

        private

        # Expected sequence of events:
        #   :before_call will save our cross application request id to the thread
        #   :after_call will write our response headers/metrics and clean up the thread
        def register_event_listeners: (untyped events) -> untyped

        def referring_transaction_info: (untyped state, untyped request_headers) -> (nil | untyped)

        def insert_response_header: (untyped state, untyped request_headers, untyped response_headers) -> untyped

        def should_process_request?: (untyped id) -> untyped

        def set_response_headers: (untyped transaction, untyped response_headers, untyped content_length) -> untyped

        def decoded_id: (untyped request) -> (::String | untyped)

        def content_length_from_request: (untyped request) -> untyped

        def hash_transaction_name: (untyped identifier) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module DistributedTracing
      class Monitor < InboundRequestMonitor
        def on_finished_configuring: (untyped events) -> (nil | untyped)

        def on_before_call: (untyped request) -> (nil | untyped)
      end
    end
  end
end

# A stub object that we can use in place of a real Logger instance when
# the agent is disabled.
module NewRelic
  module Agent
    class NullLogger
      def fatal: (*untyped args) -> nil

      def error: (*untyped args) -> nil

      def warn: (*untyped args) -> nil

      def info: (*untyped args) -> nil

      def debug: (*untyped args) -> nil

      def method_missing: (untyped method, *untyped args) { () -> untyped } -> nil
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class DatastoreSegment < Segment
        UNKNOWN: "unknown"

        attr_reader product: untyped

        attr_reader operation: untyped

        attr_reader collection: untyped

        attr_reader sql_statement: untyped

        attr_reader nosql_statement: untyped

        attr_reader host: untyped

        attr_reader port_path_or_id: untyped

        attr_accessor database_name: untyped

        attr_accessor record_sql: untyped

        def initialize: (untyped product, untyped operation, ?untyped? collection, ?untyped? host, ?untyped? port_path_or_id, ?untyped? database_name, ?untyped? start_time) -> void

        def set_instance_info: (?untyped? host, ?untyped? port_path_or_id) -> untyped

        def notice_sql: (untyped sql) -> nil

        # @api private
        def _notice_sql: (untyped sql, ?untyped? config, ?untyped? explainer, ?untyped? binds, ?untyped? name) -> (nil | untyped)

        def notice_nosql_statement: (untyped nosql_statement) -> nil

        def record_metrics: () -> untyped

        private

        def segment_complete: () -> untyped

        def add_instance_parameters: () -> untyped

        def add_database_name_parameter: () -> untyped

        NEWLINE: ::String

        def add_backtrace_parameter: () -> (nil | untyped)

        def notice_sql_statement: () -> untyped

        def notice_statement: () -> untyped

        def record_sql?: () -> untyped

        def record_span_event: () -> (nil | untyped)
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class RequestAttributes
        attr_reader request_path: untyped

        attr_reader referer: untyped

        attr_reader accept: untyped

        attr_reader content_length: untyped

        attr_reader content_type: untyped

        attr_reader host: untyped

        attr_reader port: untyped

        attr_reader user_agent: untyped

        attr_reader request_method: untyped

        HTTP_ACCEPT_HEADER_KEY: "HTTP_ACCEPT"

        def initialize: (untyped request) -> void

        def assign_agent_attributes: (untyped txn) -> untyped

        private

        def referer_from_request: (untyped request) -> untyped

        ROOT_PATH: "/"

        def path_from_request: (untyped request) -> untyped

        def content_length_from_request: (untyped request) -> untyped

        def port_from_request: (untyped request) -> untyped

        def attribute_from_request: (untyped request, untyped attribute_method) -> untyped

        def attribute_from_env: (untyped request, untyped key) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class Segment < AbstractSegment
        # unscoped_metrics can be nil, a string, or array. we do this to save
        # object allocations. if allocations weren't important then we would
        # initialize it as an array that would be empty, have one item, or many items.
        attr_reader unscoped_metrics: untyped

        # unscoped_metrics can be nil, a string, or array. we do this to save
        # object allocations. if allocations weren't important then we would
        # initialize it as an array that would be empty, have one item, or many items.
        attr_reader custom_transaction_attributes: untyped

        def initialize: (?untyped? name, ?untyped? unscoped_metrics, ?untyped? start_time) -> void

        def attributes: () -> untyped

        def add_agent_attribute: (untyped key, untyped value, ?untyped default_destinations) -> untyped

        def self.merge_untrusted_agent_attributes: (untyped attributes, untyped prefix, untyped default_destinations) -> untyped

        def merge_untrusted_agent_attributes: (untyped agent_attributes, untyped prefix, untyped default_destinations) -> (nil | untyped)

        def add_custom_attributes: (untyped p) -> untyped

        private

        def record_metrics: () -> untyped

        def append_unscoped_metric: (untyped metric) -> untyped

        def segment_complete: () -> untyped

        def record_span_event: () -> (nil | untyped)
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class SlowestSampleBuffer < TransactionSampleBuffer
        CAPACITY: 1

        def capacity: () -> untyped

        def allow_sample?: (untyped sample) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      #
      # This class represents an external segment in a transaction trace.
      #
      # @api public
      class ExternalRequestSegment < Segment
        NR_SYNTHETICS_HEADER: "X-NewRelic-Synthetics"

        APP_DATA_KEY: "NewRelicAppData"

        EXTERNAL_ALL: "External/all"

        EXTERNAL_ALL_WEB: "External/allWeb"

        EXTERNAL_ALL_OTHER: "External/allOther"

        MISSING_STATUS_CODE: "MissingHTTPStatusCode"

        attr_reader library: untyped

        attr_reader uri: untyped

        attr_reader procedure: untyped

        attr_reader http_status_code: untyped

        def initialize: (untyped library, untyped uri, untyped procedure, ?untyped? start_time) -> void

        def name: () -> untyped

        def host: () -> untyped

        # This method adds New Relic request headers to a given request made to an
        # external API and checks to see if a host header is used for the request.
        # If a host header is used, it updates the segment name to match the host
        # header.
        #
        # @param [NewRelic::Agent::HTTPClients::AbstractRequest] request the request
        # object (must belong to a subclass of NewRelic::Agent::HTTPClients::AbstractRequest)
        #
        # @api public
        def add_request_headers: (untyped request) -> untyped

        # This method extracts app data from an external response if present. If
        # a valid cross-app ID is found, the name of the segment is updated to
        # reflect the cross-process ID and transaction name.
        #
        # @param [Hash] response a hash of response headers
        #
        # @api public
        def read_response_headers: (untyped response) -> untyped

        def cross_app_request?: () -> untyped

        def cross_process_id: () -> untyped

        def transaction_guid: () -> untyped

        def cross_process_transaction_name: () -> untyped

        # Obtain an obfuscated +String+ suitable for delivery across public networks that identifies this application
        # and transaction to another application which is also running a New Relic agent. This +String+ can be processed
        # by +process_request_metadata+ on the receiving application.
        #
        # @return [String] obfuscated request metadata to send
        #
        # @api public
        #
        def get_request_metadata: () -> untyped

        # Process obfuscated +String+ sent from a called application that is also running a New Relic agent and
        # save information in current transaction for inclusion in a trace. This +String+ is generated by
        # +get_response_metadata+ on the receiving application.
        #
        # @param response_metadata [String] received obfuscated response metadata
        #
        # @api public
        #
        def process_response_metadata: (untyped response_metadata) -> untyped

        def record_metrics: () -> untyped

        def process_response_headers: (untyped response) -> untyped

        private

        # Only sets the http_status_code if response.status_code is non-empty value
        def set_http_status_code: (untyped response) -> untyped

        def insert_synthetics_header: (untyped request, untyped header) -> untyped

        def segment_complete: () -> untyped

        def process_host_header: (untyped request) -> untyped

        def add_unscoped_metrics: () -> untyped

        def suffixed_rollup_metric: () -> untyped

        def update_segment_name: () -> untyped

        def obfuscator: () -> untyped

        def record_span_event: () -> (nil | untyped)
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class AbstractSegment
        # This class is the base class for all segments. It is reponsible for
        # timing, naming, and defining lifecycle callbacks. One of the more
        # complex responsibilites of this class is computing exclusive duration.
        # One of the reasons for this complexity is that exclusive time will be
        # computed using time ranges or by recording an aggregate value for
        # a segments children time. The reason for this is that computing
        # exclusive duration using time ranges is expensive and it's only
        # necessary if a segment's children run concurrently, or a segment ends
        # after its parent. We will use the optimized exclusive duration
        # calculation in all other cases.
        #
        attr_reader start_time: untyped

        # This class is the base class for all segments. It is reponsible for
        # timing, naming, and defining lifecycle callbacks. One of the more
        # complex responsibilites of this class is computing exclusive duration.
        # One of the reasons for this complexity is that exclusive time will be
        # computed using time ranges or by recording an aggregate value for
        # a segments children time. The reason for this is that computing
        # exclusive duration using time ranges is expensive and it's only
        # necessary if a segment's children run concurrently, or a segment ends
        # after its parent. We will use the optimized exclusive duration
        # calculation in all other cases.
        #
        attr_reader end_time: untyped

        # This class is the base class for all segments. It is reponsible for
        # timing, naming, and defining lifecycle callbacks. One of the more
        # complex responsibilites of this class is computing exclusive duration.
        # One of the reasons for this complexity is that exclusive time will be
        # computed using time ranges or by recording an aggregate value for
        # a segments children time. The reason for this is that computing
        # exclusive duration using time ranges is expensive and it's only
        # necessary if a segment's children run concurrently, or a segment ends
        # after its parent. We will use the optimized exclusive duration
        # calculation in all other cases.
        #
        attr_reader duration: untyped

        # This class is the base class for all segments. It is reponsible for
        # timing, naming, and defining lifecycle callbacks. One of the more
        # complex responsibilites of this class is computing exclusive duration.
        # One of the reasons for this complexity is that exclusive time will be
        # computed using time ranges or by recording an aggregate value for
        # a segments children time. The reason for this is that computing
        # exclusive duration using time ranges is expensive and it's only
        # necessary if a segment's children run concurrently, or a segment ends
        # after its parent. We will use the optimized exclusive duration
        # calculation in all other cases.
        #
        attr_reader exclusive_duration: untyped

        # This class is the base class for all segments. It is reponsible for
        # timing, naming, and defining lifecycle callbacks. One of the more
        # complex responsibilites of this class is computing exclusive duration.
        # One of the reasons for this complexity is that exclusive time will be
        # computed using time ranges or by recording an aggregate value for
        # a segments children time. The reason for this is that computing
        # exclusive duration using time ranges is expensive and it's only
        # necessary if a segment's children run concurrently, or a segment ends
        # after its parent. We will use the optimized exclusive duration
        # calculation in all other cases.
        #
        attr_reader guid: untyped

        attr_accessor name: untyped

        attr_accessor parent: untyped

        attr_accessor children_time: untyped

        attr_accessor transaction: untyped

        attr_accessor transaction_name: untyped

        attr_writer record_metrics: untyped

        attr_writer record_scoped_metric: untyped

        attr_writer record_on_finish: untyped

        attr_reader noticed_error: untyped

        def initialize: (?untyped? name, ?untyped? start_time) -> void

        def start: () -> (nil | untyped)

        def finish: () -> untyped

        def finished?: () -> untyped

        def record_metrics?: () -> untyped

        def record_scoped_metric?: () -> untyped

        def record_on_finish?: () -> untyped

        def finalize: () -> untyped

        def params: () -> untyped

        def params?: () -> untyped

        def time_range: () -> ::Range[untyped]

        def children_time_ranges: () -> untyped

        def children_time_ranges?: () -> untyped

        def concurrent_children?: () -> untyped

        INSPECT_IGNORE: ::Array[:@transaction | :@transaction_state]

        def inspect: () -> untyped

        # callback for subclasses to override
        def transaction_assigned: () -> nil

        def set_noticed_error: (untyped noticed_error) -> untyped

        def notice_error: (untyped exception, ?::Hash[untyped, untyped] options) -> untyped

        def noticed_error_attributes: () -> (nil | untyped)

        attr_writer range_recorded: untyped

        def range_recorded?: () -> untyped

        def child_start: (untyped segment) -> untyped

        def child_complete: (untyped segment) -> untyped

        def descendant_complete: (untyped child, untyped descendant) -> untyped

        private

        def force_finish: () -> untyped

        def run_complete_callbacks: () -> untyped

        def record_metrics: () -> untyped

        # callback for subclasses to override
        def segment_complete: () -> nil

        def record_child_time: (untyped child) -> untyped

        def record_child_time_as_range: (untyped child) -> untyped

        def record_child_time_as_number: (untyped child) -> untyped

        def record_exclusive_duration: () -> untyped

        def metric_cache: () -> untyped

        def transaction_state: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class TransactionSampleBuffer
        attr_reader samples: untyped

        SINGLE_BUFFER_MAX: 20

        NO_SAMPLES: ::Array[untyped]

        def initialize: () -> void

        def enabled?: () -> true

        def reset!: () -> untyped

        def harvest_samples: () -> untyped

        def allow_sample?: (untyped sample) -> true

        def store: (untyped sample) -> (nil | untyped)

        def store_previous: (untyped previous_samples) -> (nil | untyped)

        def truncate_samples_if_needed: () -> untyped

        def full?: () -> untyped

        # Capacity is the desired number of samples a buffer will hold. This
        # can be user dictated via config if a feature wants.
        #
        # This value will be forcibly capped by the max_capacity
        def capacity: () -> untyped

        # Apply hard upper limit to the capacity to prevent users from
        # consuming too much memory buffering TT's.
        #
        # A typical buffer should NOT override this method (although we do for
        # odd things like dev-mode)
        def max_capacity: () -> untyped

        # Our default truncation strategy is to keep max_capacity
        # worth of the longest samples. Override this method for alternate
        # behavior.
        #
        # This doesn't use the more convenient #last and #sort_by to avoid
        # additional array allocations (and abundant alliteration)
        def truncate_samples: () -> untyped

        # When pushing a scope different sample buffers potentially want to
        # know about what's happening to annotate the incoming nodes
        def visit_node: () -> nil

        private

        # If a buffer needs to modify an added sample, override this method.
        # Bounds checking, allowing samples and truncation belongs elsewhere.
        def add_sample: (untyped sample) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class TraceNode
        attr_reader entry_timestamp: untyped

        # The exit timestamp will be relative except for the outermost sample which will
        # have a timestamp.
        attr_accessor exit_timestamp: untyped

        attr_reader parent_node: untyped

        attr_accessor metric_name: untyped

        UNKNOWN_NODE_NAME: "<unknown>"

        def initialize: (untyped metric_name, untyped relative_start, ?untyped? relative_end, ?untyped? params, ?untyped? parent) -> void

        def select_allowed_params: (untyped params) -> (nil | untyped)

        # sets the final timestamp on a node to indicate the exit
        # point of the node
        def end_trace: (untyped timestamp) -> untyped

        def to_s: () -> untyped

        def to_array: () -> untyped

        def path_string: () -> ::String

        def to_s_compact: () -> untyped

        def to_debug_str: (untyped depth) -> untyped

        def children: () -> untyped

        attr_writer children: untyped

        # return the total duration of this node
        def duration: () -> untyped

        # return the duration of this node without
        # including the time in the called nodes
        def exclusive_duration: () -> untyped

        def count_nodes: () -> untyped

        def params: () -> untyped

        attr_writer params: untyped

        def []=: (untyped key, untyped value) -> untyped

        def []: (untyped key) -> untyped

        # call the provided block for this node and each
        # of the called nodes
        def each_node: () { () -> untyped } -> untyped

        # call the provided block for this node and each
        # of the called nodes while keeping track of nested nodes
        def each_node_with_nest_tracking: () { () -> untyped } -> untyped

        def explain_sql: () -> (untyped | nil)

        def obfuscated_sql: () -> untyped

        def parent_node=: (untyped s) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class MessageBrokerSegment < Segment
        CONSUME: "Consume"

        EXCHANGE: "Exchange"

        NAMED: "Named/"

        PRODUCE: "Produce"

        QUEUE: "Queue"

        PURGE: "Purge"

        SLASH: "/"

        TEMP: "Temp"

        TOPIC: "Topic"

        UNKNOWN: "Unknown"

        DESTINATION_TYPES: ::Array[:exchange | :queue | :topic | :temporary_queue | :temporary_topic | :unknown]

        ACTIONS: { consume: untyped, produce: untyped, purge: untyped }

        TYPES: { exchange: untyped, temporary_queue: untyped, queue: untyped, temporary_topic: untyped, topic: untyped, unknown: untyped }

        METRIC_PREFIX: "MessageBroker/"

        attr_reader action: untyped

        attr_reader destination_name: untyped

        attr_reader destination_type: untyped

        attr_reader library: untyped

        attr_reader headers: untyped

        def initialize: (action: untyped action, library: untyped library, destination_type: untyped destination_type, destination_name: untyped destination_name, ?headers: untyped? headers, ?parameters: untyped? parameters, ?start_time: untyped? start_time) -> void

        def name: () -> untyped

        def transaction_assigned: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class SyntheticsSampleBuffer < TransactionSampleBuffer
        def capacity: () -> untyped

        def allow_sample?: (untyped sample) -> untyped

        def truncate_samples: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      module DistributedTracing
        attr_accessor distributed_trace_payload: untyped

        attr_writer distributed_trace_payload_created: untyped

        SUPPORTABILITY_DISTRIBUTED_TRACE: "Supportability/DistributedTrace"

        CREATE_PREFIX: ::String

        ACCEPT_PREFIX: ::String

        IGNORE_PREFIX: ::String

        CREATE_SUCCESS_METRIC: ::String

        CREATE_EXCEPTION_METRIC: ::String

        ACCEPT_SUCCESS_METRIC: ::String

        ACCEPT_EXCEPTION_METRIC: ::String

        ACCEPT_PARSE_EXCEPTION_METRIC: ::String

        IGNORE_ACCEPT_AFTER_CREATE_METRIC: ::String

        IGNORE_MULTIPLE_ACCEPT_METRIC: ::String

        IGNORE_ACCEPT_NULL_METRIC: ::String

        IGNORE_ACCEPT_MAJOR_VERSION_METRIC: ::String

        IGNORE_ACCEPT_UNTRUSTED_ACCOUNT_METRIC: ::String

        LBRACE: "{"

        NULL_PAYLOAD: "null"

        NEWRELIC_TRACE_KEY: "HTTP_NEWRELIC"

        def accept_distributed_tracing_incoming_request: (untyped request) -> (nil | untyped)

        def distributed_trace_payload_created?: () -> untyped

        def create_distributed_trace_payload: () -> untyped

        def accept_distributed_trace_payload: (untyped payload) -> untyped

        private

        def check_payload_ignored: (untyped payload) -> (true | false)

        def check_payload_present: (untyped payload) -> (nil | untyped)

        def decode_payload: (untyped payload) -> untyped

        def check_required_fields_present: (untyped payload) -> untyped

        def check_valid_version: (untyped payload) -> untyped

        def check_trusted_account: (untyped payload) -> (false | true)

        def assign_payload_and_sampling_params: (untyped payload) -> (nil | untyped)
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      module TraceContext
        include NewRelic::Coerce

        module AccountHelpers
          extend ::NewRelic::Agent::Transaction::TraceContext::AccountHelpers

          def trace_state_entry_key: () -> untyped
        end

        SUPPORTABILITY_PREFIX: "Supportability/TraceContext"

        CREATE_PREFIX: ::String

        ACCEPT_PREFIX: ::String

        TRACESTATE_PREFIX: ::String

        CREATE_SUCCESS_METRIC: ::String

        CREATE_EXCEPTION_METRIC: ::String

        ACCEPT_SUCCESS_METRIC: ::String

        ACCEPT_EXCEPTION_METRIC: ::String

        IGNORE_MULTIPLE_ACCEPT_METRIC: ::String

        IGNORE_ACCEPT_AFTER_CREATE_METRIC: ::String

        NO_NR_ENTRY_TRACESTATE_METRIC: ::String

        INVALID_TRACESTATE_PAYLOAD_METRIC: ::String

        attr_accessor trace_context_header_data: untyped

        attr_reader trace_state_payload: untyped

        def trace_parent_header_present?: (untyped request) -> untyped

        private

        def accept_trace_context_incoming_request: (untyped request) -> (nil | untyped)

        public

        def insert_trace_context_header: (untyped header, ?untyped format) -> untyped

        def create_trace_state: () -> untyped

        def create_trace_state_payload: () -> (nil | untyped)

        def assign_trace_state_payload: () -> (false | untyped)

        def accept_trace_context: (untyped header_data) -> untyped

        def ignore_trace_context?: () -> (true | false)

        def trace_context_inserted?: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class DistributedTracer
        include NewRelic::Agent::CrossAppTracing

        include DistributedTracing

        include TraceContext

        attr_reader transaction: untyped

        attr_accessor parent_transaction_id: untyped

        def parent_guid: () -> untyped

        def accept_incoming_request: (untyped request, ?untyped? transport_type) -> untyped

        def caller_transport_type: () -> untyped

        def accept_transport_type_from_api: (untyped value) -> untyped

        def accept_incoming_transport_type: (untyped request, untyped transport_type) -> untyped

        def initialize: (untyped transaction) -> void

        def record_metrics: () -> untyped

        def append_payload: (untyped payload) -> untyped

        def log_request_headers: (untyped headers, ?::String direction) -> untyped

        def insert_headers: (untyped headers) -> (nil | untyped)

        def consume_message_headers: (untyped headers, untyped tracer_state, untyped transport_type) -> untyped

        def assign_intrinsics: () -> untyped

        def insert_distributed_trace_header: (untyped headers) -> (nil | untyped)

        def insert_cat_headers: (untyped headers) -> (nil | untyped)

        private

        def consume_message_synthetics_headers: (untyped headers) -> untyped

        def consume_message_distributed_tracing_headers: (untyped headers, untyped transport_type) -> (nil | untyped)

        def consume_message_cross_app_tracing_headers: (untyped headers, untyped tracer_state) -> (nil | untyped)

        def accept_cross_app_payload: (untyped headers, untyped tracer_state) -> untyped

        def deobfuscate: (untyped message) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      module Tracing
        attr_reader current_segment: untyped

        def async?: () -> untyped

        attr_writer async: untyped

        def total_time: () -> untyped

        attr_writer total_time: untyped

        def add_segment: (untyped segment, ?untyped? parent) -> untyped

        def segment_complete: (untyped segment) -> untyped

        def segment_limit: () -> untyped

        private

        def finalize_segments: () -> untyped

        WEB_TRANSACTION_TOTAL_TIME: "WebTransactionTotalTime"

        OTHER_TRANSACTION_TOTAL_TIME: "OtherTransactionTotalTime"

        def record_total_time_metrics: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      module TraceBuilder
        extend ::NewRelic::Agent::Transaction::TraceBuilder

        def build_trace: (untyped transaction) -> untyped

        private

        # recursively builds a transaction trace from the flat list of segments
        def process_segments: (untyped transaction, untyped segment, untyped parent, untyped relationship_map) -> untyped

        def create_trace_node: (untyped transaction, untyped segment, untyped parent) -> untyped

        def copy_attributes: (untyped transaction, untyped trace) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Transaction
      class Trace
        class FinishedTraceError < StandardError
        end

        attr_reader start_time: untyped

        attr_reader root_node: untyped

        attr_accessor transaction_name: untyped

        attr_accessor guid: untyped

        attr_accessor attributes: untyped

        attr_accessor node_count: untyped

        attr_accessor finished: untyped

        attr_accessor threshold: untyped

        attr_accessor profile: untyped

        ROOT: "ROOT"

        def initialize: (untyped start_time) -> void

        def sample_id: () -> untyped

        def count_nodes: () -> untyped

        def duration: () -> untyped

        def synthetics_resource_id: () -> untyped

        def to_s_compact: () -> untyped

        def create_node: (untyped time_since_start, ?untyped? metric_name) -> untyped

        def each_node: () { () -> untyped } -> untyped

        def prepare_to_send!: () -> untyped

        def collect_explain_plans!: () -> (nil | untyped)

        def prepare_sql_for_transmission!: () -> untyped

        def strip_sql!: () -> untyped

        # Iterates recursively over each node in the entire transaction
        # sample tree while keeping track of nested nodes
        def each_node_with_nest_tracking: () { () -> untyped } -> untyped

        AGENT_ATTRIBUTES_KEY: "agentAttributes"

        USER_ATTRIBUTES_KEY: "userAttributes"

        INTRINSIC_ATTRIBUTES_KEY: "intrinsics"

        def attributes_for_tracer_destination: () -> ::Hash[untyped, untyped]

        def trace_tree: (untyped attributes_hash) -> ::Array[untyped]

        def to_collector_array: (untyped encoder) -> ::Array[untyped | nil | false]
      end
    end
  end
end

module NewRelic
  module Agent
    module Database
      module ExplainPlanHelpers
        SUPPORTED_ADAPTERS_FOR_EXPLAIN: ::Array[:postgres | :mysql2 | :mysql | :sqlite]

        SELECT: "select"

        def is_select?: (untyped sql) -> untyped

        def parameterized?: (untyped sql) -> untyped

        # SQL containing a semicolon in the middle (with something
        # other than whitespace after it) may contain two or more
        # queries.  It's not safe to EXPLAIN this kind of expression,
        # since it could lead to executing unwanted SQL.
        #
        MULTIPLE_QUERIES: untyped

        def multiple_queries?: (untyped sql) -> untyped

        def handle_exception_in_explain: () { () -> untyped } -> untyped

        def process_resultset: (untyped results, untyped adapter) -> (untyped | ::Array[untyped])

        QUERY_PLAN: "QUERY PLAN"

        def process_explain_results_postgres: (untyped results) -> ::Array[::Array[untyped] | untyped]

        # Sequel returns explain plans as just one big pre-formatted String
        # In that case, we send a nil headers array, and the single string
        # wrapped in an array for the values.
        # Note that we don't use this method for Postgres explain plans, since
        # they need to be passed through the explain plan obfuscator first.
        def string_explain_plan_results: (untyped results) -> ::Array[nil | ::Array[untyped]]

        def process_explain_results_mysql: (untyped results) -> ::Array[untyped]

        def process_explain_results_mysql2: (untyped results) -> ::Array[untyped]

        SQLITE_EXPLAIN_COLUMNS: ::Array["addr" | "opcode" | "p1" | "p2" | "p3" | "p4" | "p5" | "comment"]

        def process_explain_results_sqlite: (untyped results) -> ::Array[untyped]
      end
    end
  end
end

module NewRelic
  module Agent
    module Database
      module ObfuscationHelpers
        COMPONENTS_REGEX_MAP: { single_quotes: ::Regexp, double_quotes: ::Regexp, dollar_quotes: ::Regexp, uuids: ::Regexp, numeric_literals: ::Regexp, boolean_literals: ::Regexp, hexadecimal_literals: ::Regexp, comments: ::Regexp, multi_line_comments: ::Regexp, oracle_quoted_strings: ::Regexp }

        DIALECT_COMPONENTS: { fallback: untyped, mysql: ::Array[:single_quotes | :double_quotes | :numeric_literals | :boolean_literals | :hexadecimal_literals | :comments | :multi_line_comments], postgres: ::Array[:single_quotes | :dollar_quotes | :uuids | :numeric_literals | :boolean_literals | :comments | :multi_line_comments], sqlite: ::Array[:single_quotes | :numeric_literals | :boolean_literals | :hexadecimal_literals | :comments | :multi_line_comments], oracle: ::Array[:single_quotes | :oracle_quoted_strings | :numeric_literals | :comments | :multi_line_comments], cassandra: ::Array[:single_quotes | :uuids | :numeric_literals | :boolean_literals | :hexadecimal_literals | :comments | :multi_line_comments] }

        # We use these to check whether the query contains any quote characters
        # after obfuscation. If so, that's a good indication that the original
        # query was malformed, and so our obfuscation can't reliably find
        # literals. In such a case, we'll replace the entire query with a
        # placeholder.
        CLEANUP_REGEX: { mysql: ::Regexp, :mysql2 => ::Regexp, postgres: ::Regexp, sqlite: ::Regexp, cassandra: ::Regexp, oracle: ::Regexp, oracle_enhanced: ::Regexp }

        PLACEHOLDER: "?"

        FAILED_TO_OBFUSCATE_MESSAGE: "Failed to obfuscate SQL query - quote characters remained after obfuscation"

        def obfuscate_single_quote_literals: (untyped sql) -> untyped

        def self.generate_regex: (untyped dialect) -> untyped

        MYSQL_COMPONENTS_REGEX: untyped

        POSTGRES_COMPONENTS_REGEX: untyped

        SQLITE_COMPONENTS_REGEX: untyped

        ORACLE_COMPONENTS_REGEX: untyped

        CASSANDRA_COMPONENTS_REGEX: untyped

        FALLBACK_REGEX: untyped

        def obfuscate: (untyped sql, untyped adapter) -> untyped

        def detect_unmatched_pairs: (untyped obfuscated, untyped adapter) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Database
      class Obfuscator
        include Singleton

        include ObfuscationHelpers

        attr_reader obfuscator: untyped

        QUERY_TOO_LARGE_MESSAGE: "Query too large (over 16k characters) to safely obfuscate"

        ELLIPSIS: "..."

        def initialize: () -> void

        def reset: () -> untyped

        # Sets the sql obfuscator used to clean up sql when sending it
        # to the server. Possible types are:
        #
        # :before => sets the block to run before the existing
        # obfuscators
        #
        # :after => sets the block to run after the existing
        # obfuscator(s)
        #
        # :replace => removes the current obfuscator and replaces it
        # with the provided block
        def set_sql_obfuscator: (untyped `type`) { () -> untyped } -> untyped

        def default_sql_obfuscator: (untyped sql) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Database
      module PostgresExplainObfuscator
        extend ::NewRelic::Agent::Database::PostgresExplainObfuscator

        # Note that this regex can't be shared with the ones in the
        # Database::Obfuscator class because here we don't look for
        # backslash-escaped strings.
        QUOTED_STRINGS_REGEX: ::Regexp

        LABEL_LINE_REGEX: ::Regexp

        def obfuscate: (untyped explain) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class LogEventAggregator < EventAggregator
      # Per-message keys
      LEVEL_KEY: "log.level"

      MESSAGE_KEY: "message"

      TIMESTAMP_KEY: "timestamp"

      PRIORITY_KEY: "priority"

      # Metric keys
      LINES: "Logging/lines"

      DROPPED_METRIC: "Logging/Forwarding/Dropped"

      SEEN_METRIC: "Supportability/Logging/Forwarding/Seen"

      SENT_METRIC: "Supportability/Logging/Forwarding/Sent"

      OVERALL_SUPPORTABILITY_FORMAT: "Supportability/Logging/Ruby/Logger/%s"

      METRICS_SUPPORTABILITY_FORMAT: "Supportability/Logging/Metrics/Ruby/%s"

      FORWARDING_SUPPORTABILITY_FORMAT: "Supportability/Logging/Forwarding/Ruby/%s"

      DECORATING_SUPPORTABILITY_FORMAT: "Supportability/Logging/LocalDecorating/Ruby/%s"

      MAX_BYTES: 32768

      # Config keys
      OVERALL_ENABLED_KEY: :"application_logging.enabled"

      METRICS_ENABLED_KEY: :"application_logging.metrics.enabled"

      FORWARDING_ENABLED_KEY: :"application_logging.forwarding.enabled"

      DECORATING_ENABLED_KEY: :"application_logging.local_decorating.enabled"

      def initialize: (untyped events) -> void

      def capacity: () -> untyped

      def record: (untyped formatted_message, untyped severity) -> untyped

      def record_batch: (untyped txn, untyped logs) -> untyped

      def create_event: (untyped priority, untyped formatted_message, untyped severity) -> ::Array[::Hash[untyped, untyped] | untyped]

      # Because our transmission format (MELT) is different than historical
      # agent payloads, extract the munging here to keep the service focused
      # on the general harvest + transmit instead of the format.
      #
      # Payload shape matches the publicly documented MELT format.
      # https://docs.newrelic.com/docs/logs/log-api/introduction-log-api
      #
      # We have to keep the aggregated payloads in a separate shape, though, to
      # work with the priority sampling buffers
      def self.payload_to_melt_format: (untyped data) -> ::Array[untyped]

      def harvest!: () -> untyped

      def reset!: () -> untyped

      def enabled?: () -> untyped

      private

      # We record once-per-connect metrics for enabled/disabled state at the
      # point we consider the configuration stable (i.e. once we've gotten SSC)
      def register_for_done_configuring: (untyped events) -> untyped

      def record_configuration_metric: (untyped format, untyped key) -> untyped

      def after_harvest: (untyped metadata) -> untyped

      # To avoid paying the cost of metric recording on every line, we hold
      # these until harvest before recording them
      def record_customer_metrics: () -> (nil | untyped)

      def line_metric_name_by_severity: (untyped severity) -> untyped

      def note_dropped_events: (untyped total_count, untyped dropped_count) -> untyped

      def record_supportability_metrics: (untyped total_count, untyped captured_count, untyped dropped_count) -> (nil | untyped)

      def truncate_message: (untyped message) -> untyped
    end
  end
end

module NewRelic
  module Agent
    #
    # This module contains helper methods to facilitate instrumentation of
    # message brokers.
    #
    # @api public
    module Messaging
      extend ::NewRelic::Agent::Messaging

      RABBITMQ_TRANSPORT_TYPE: "RabbitMQ"

      ATTR_DESTINATION: untyped

      # Start a MessageBroker segment configured to trace a messaging action.
      # Finishing this segment will handle timing and recording of the proper
      # metrics for New Relic's messaging features..
      #
      # @param action [Symbol] The message broker action being traced (see
      #   NewRelic::Agent::Transaction::MessageBrokerSegment::ACTIONS) for
      #   all options.
      #
      # @param library [String] The name of the library being instrumented
      #
      # @param destination_type [Symbol] Type of destination (see
      #   NewRelic::Agent::Transaction::MessageBrokerSegment::DESTINATION_TYPES)
      #   for all options.
      #
      # @param destination_name [String] Name of destination (queue or
      #   exchange name)
      #
      # @param headers [Hash] Metadata about the message and opaque
      #   application-level data (optional)
      #
      # @param parameters [Hash] A hash of parameters to be attached to this
      #   segment (optional)
      #
      # @param start_time [Time] An instance of Time class denoting the start
      #   time of the segment. Value is set by AbstractSegment#start if not
      #   given. (optional)
      #
      # @return [NewRelic::Agent::Transaction::MessageBrokerSegment]
      #
      # @api public
      #
      def start_message_broker_segment: (?action: untyped? action, ?library: untyped? library, ?destination_type: untyped? destination_type, ?destination_name: untyped? destination_name, ?headers: untyped? headers, ?parameters: untyped? parameters, ?start_time: untyped? start_time) -> untyped

      # Wrap a MessageBroker transaction trace around a messaging handling block.
      # This API is intended to be used in library instrumentation when a "push"-
      # style callback is invoked to handle an incoming message.
      #
      # @param library [String] The name of the library being instrumented
      #
      # @param destination_type [Symbol] Type of destination (see
      #   +NewRelic::Agent::Transaction::MessageBrokerSegment::DESTINATION_TYPES+)
      #   for all options.
      #
      # @param destination_name [String] Name of destination (queue or
      #   exchange name)
      #
      # @param headers [Hash] Metadata about the message and opaque
      #   application-level data (optional)
      #
      # @param routing_key [String] Value used by AMQP message brokers to route
      #   messages to queues
      #
      # @param queue_name [String] Name of AMQP queue that received the
      #   message (optional)
      #
      # @param exchange_type [Symbol] Type of last AMQP exchange to deliver the
      #   message (optional)
      #
      # @param reply_to [String] Routing key to be used to send AMQP-based RPC
      #   response messages (optional)
      #
      # @param correlation_id [String] Application-level value used to correlate
      #   AMQP-based RPC response messages to request messages (optional)
      #
      # @param &block [Proc] The block should handle calling the original subscribed
      #   callback function
      #
      # @return return value of given block, which will be the same as the
      #   return value of an un-instrumented subscribed callback
      #
      # @api public
      #
      def wrap_message_broker_consume_transaction: (library: untyped library, destination_type: untyped destination_type, destination_name: untyped destination_name, ?headers: untyped? headers, ?routing_key: untyped? routing_key, ?queue_name: untyped? queue_name, ?exchange_type: untyped? exchange_type, ?reply_to: untyped? reply_to, ?correlation_id: untyped? correlation_id) { () -> untyped } -> untyped

      # Start a MessageBroker segment configured to trace an AMQP publish.
      # Finishing this segment will handle timing and recording of the proper
      # metrics for New Relic's messaging features. This method is a convenience
      # wrapper around NewRelic::Agent::Tracer.start_message_broker_segment.
      #
      # @param library [String] The name of the library being instrumented
      #
      # @param destination_name [String] Name of destination (exchange name)
      #
      # @param headers [Hash] The message headers
      #
      # @param routing_key [String] The routing key used for the message (optional)
      #
      # @param reply_to [String] A routing key for use in RPC-models for the
      #   receiver to publish a response to (optional)
      #
      # @param correlation_id [String] An application-generated value to link up
      #   request and responses in RPC-models (optional)
      #
      # @param exchange_type [String] Type of exchange which determines how
      #   message are routed (optional)
      #
      # @return [NewRelic::Agent::Transaction::MessageBrokerSegment]
      #
      # @api public
      #
      def start_amqp_publish_segment: (library: untyped library, destination_name: untyped destination_name, ?headers: untyped? headers, ?routing_key: untyped? routing_key, ?reply_to: untyped? reply_to, ?correlation_id: untyped? correlation_id, ?exchange_type: untyped? exchange_type) -> untyped

      # Start a MessageBroker segment configured to trace an AMQP consume.
      # Finishing this segment will handle timing and recording of the proper
      # metrics for New Relic's messaging features. This method is a convenience
      # wrapper around NewRelic::Agent::Tracer.start_message_broker_segment.
      #
      # @param library [String] The name of the library being instrumented
      #
      # @param destination_name [String] Name of destination (exchange name)
      #
      # @param delivery_info [Hash] Metadata about how the message was delivered
      #
      # @param message_properties [Hash] AMQP-specific metadata about the message
      #   including headers and opaque application-level data
      #
      # @param exchange_type [String] Type of exchange which determines how
      #   messages are routed (optional)
      #
      # @param queue_name [String] The name of the queue the message was
      #   consumed from (optional)
      #
      # @param start_time [Time] An instance of Time class denoting the start
      #   time of the segment. Value is set by AbstractSegment#start if not
      #   given. (optional)
      #
      # @return [NewRelic::Agent::Transaction::MessageBrokerSegment]
      #
      # @api public
      #
      def start_amqp_consume_segment: (library: untyped library, destination_name: untyped destination_name, delivery_info: untyped delivery_info, message_properties: untyped message_properties, ?exchange_type: untyped? exchange_type, ?queue_name: untyped? queue_name, ?start_time: untyped? start_time) -> untyped

      # Wrap a MessageBroker transaction trace around a AMQP messaging handling block.
      # This API is intended to be used in AMQP-specific library instrumentation when a
      # "push"-style callback is invoked to handle an incoming message.
      #
      # @param library [String] The name of the library being instrumented
      #
      # @param destination_name [String] Name of destination (queue or
      #   exchange name)
      #
      # @param message_properties [Hash] Metadata about the message and opaque
      #   application-level data (optional)
      #
      # @param exchange_type [Symbol] Type of AMQP exchange the message was recieved
      #   from (see NewRelic::Agent::Transaction::MessageBrokerSegment::DESTINATION_TYPES)
      #
      # @param queue_name [String] name of the AMQP queue on which the message was
      #   received
      #
      # @param &block [Proc] The block should handle calling the original subscribed
      #   callback function
      #
      # @return return value of given block, which will be the same as the
      #   return value of an un-instrumented subscribed callback
      #
      # @api public
      #
      def wrap_amqp_consume_transaction: (?library: untyped? library, ?destination_name: untyped? destination_name, ?delivery_info: untyped? delivery_info, ?message_properties: untyped? message_properties, ?exchange_type: untyped? exchange_type, ?queue_name: untyped? queue_name) { () -> untyped } -> untyped

      private

      def segment_parameters_enabled?: () -> untyped

      def transaction_name: (untyped library, untyped destination_type, untyped destination_name) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class Manager
        # Defining these explicitly saves object allocations that we incur
        # if we use Forwardable and def_delegators.
        def []: (untyped key) -> untyped

        def has_key?: (untyped key) -> untyped

        def keys: () -> untyped

        def initialize: () -> void

        def add_config_for_testing: (untyped source, ?::Integer level) -> untyped

        def remove_config_type: (untyped sym) -> untyped

        def remove_config: (untyped source) -> untyped

        def replace_or_add_config: (untyped source) -> untyped

        def source: (untyped key) -> untyped

        def fetch: (untyped key) -> (untyped | nil)

        def evaluate_procs: (untyped value) -> untyped

        def evaluate_and_apply_transformations: (untyped key, untyped value) -> untyped

        def apply_transformations: (untyped key, untyped value) -> untyped

        def transform_from_default: (untyped key) -> untyped

        def register_callback: (untyped key) { () -> untyped } -> untyped

        def invoke_callbacks: (untyped direction, untyped source) -> (nil | untyped)

        # This event is intended to be fired every time the server source is
        # applied.  This happens after the agent's initial connect, and again
        # on every forced reconnect.
        def notify_server_source_added: () -> untyped

        # This event is intended to be fired once during the entire lifespan of
        # an agent run, after the server source has been applied for the first
        # time.  This should indicate that all configuration has been applied,
        # and the main functions of the agent are safe to start.
        def notify_finished_configuring: () -> untyped

        def finished_configuring?: () -> untyped

        def flattened: () -> untyped

        def apply_mask: (untyped hash) -> untyped

        def to_collector_hash: () -> untyped

        MALFORMED_LABELS_WARNING: "Skipping malformed labels configuration"

        PARSING_LABELS_FAILURE: "Failure during parsing labels. Ignoring and carrying on with connect."

        MAX_LABEL_COUNT: 64

        MAX_LABEL_LENGTH: 255

        def parsed_labels: () -> untyped

        def parse_labels_from_string: () -> untyped

        def break_label_string_into_pairs: (untyped labels) -> untyped

        def valid_label_pairs?: (untyped label_pairs) -> untyped

        def valid_label_item?: (untyped item) -> untyped

        def make_label_hash: (untyped pairs, ?untyped? labels) -> (::Array[untyped] | untyped)

        def truncate: (untyped text, ?untyped? key) -> untyped

        def limit_number_of_labels: (untyped pairs) -> untyped

        # We only take the last value provided for a given label type key
        def remove_duplicates: (untyped pairs) -> untyped

        def parse_labels_from_dictionary: () -> untyped

        # Generally only useful during initial construction and tests
        def reset_to_defaults: () -> untyped

        def reset_cache: () -> untyped

        def log_config: (untyped direction, untyped source) -> untyped

        def delete_all_configs_for_testing: () -> untyped

        def num_configs_for_testing: () -> untyped

        def config_classes_for_testing: () -> untyped

        private

        def config_stack: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class DottedHash < ::Hash[untyped, untyped]
        def initialize: (untyped hash, ?bool keep_nesting) -> void

        def inspect: () -> ::String

        def to_hash: () -> untyped

        def self.symbolize: (untyped hash) -> untyped

        # turns {'a' => {'b' => 'c'}} into {'a.b' => 'c'}
        def dot_flattened: (untyped nested_hash, ?untyped names, ?::Hash[untyped, untyped] result) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class HighSecuritySource < DottedHash
        def initialize: (untyped local_settings) -> void

        OFF: "off"

        RAW: "raw"

        OBFUSCATED: "obfuscated"

        SET_TO_OBFUSCATED: ::Array[untyped]

        def record_sql_setting: (untyped local_settings, untyped key) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      module EventHarvestConfig
        extend ::NewRelic::Agent::Configuration::EventHarvestConfig

        EVENT_HARVEST_CONFIG_KEY_MAPPING: { analytic_event_data: :"transaction_events.max_samples_stored", custom_event_data: :"custom_insights_events.max_samples_stored", error_event_data: :"error_collector.max_event_samples_stored", log_event_data: :"application_logging.forwarding.max_samples_stored" }

        # not including span_event_data here because spans are handled separately in transform_span_event_harvest_config
        EVENT_HARVEST_EVENT_REPORT_PERIOD_KEY_MAPPING: { analytic_event_data: :transaction_event_data, custom_event_data: :custom_event_data, error_event_data: :error_event_data, log_event_data: :log_event_data }

        def from_config: (untyped config) -> { harvest_limits: untyped }

        def to_config_hash: (untyped connect_reply) -> untyped

        private

        def transform_event_harvest_config_keys: (untyped connect_reply, untyped event_harvest_interval) -> untyped

        def transform_span_event_harvest_config: (untyped config_hash, untyped connect_reply) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class ServerSource < DottedHash
        # These keys appear *outside* of the agent_config hash in the connect
        # response, but should still be merged in as config settings to the
        # main agent configuration.
        TOP_LEVEL_KEYS: ::Array["account_id" | "apdex_t" | "application_id" | "beacon" | "browser_key" | "browser_monitoring.debug" | "browser_monitoring.loader" | "browser_monitoring.loader_version" | "cross_process_id" | "data_report_period" | "encoding_key" | "entity_guid" | "error_beacon" | "js_agent_file" | "js_agent_loader" | "max_payload_size_in_bytes" | "primary_application_id" | "sampling_target" | "sampling_target_period_in_seconds" | "trusted_account_ids" | "trusted_account_key"]

        def initialize: (untyped connect_reply, ?::Hash[untyped, untyped] existing_config) -> void

        def merge_top_level_keys: (untyped merged_settings, untyped connect_reply) -> untyped

        def merge_agent_config_hash: (untyped merged_settings, untyped connect_reply) -> untyped

        def fix_transaction_threshold: (untyped merged_settings) -> untyped

        EVENT_HARVEST_CONFIG_SUPPORTABILITY_METRIC_NAMES: { :"transaction_events.max_samples_stored" => "Supportability/EventHarvest/AnalyticEventData/HarvestLimit", :"custom_insights_events.max_samples_stored" => "Supportability/EventHarvest/CustomEventData/HarvestLimit", :"error_collector.max_event_samples_stored" => "Supportability/EventHarvest/ErrorEventData/HarvestLimit", :"application_logging.forwarding.max_samples_stored" => "Supportability/EventHarvest/LogEventData/HarvestLimit", :"span_events.max_samples_stored" => "Supportability/SpanEvent/Limit", event_report_period: "Supportability/EventHarvest/ReportPeriod", :"event_report_period.span_event_data" => "Supportability/SpanEvent/ReportPeriod" }

        def add_event_harvest_config: (untyped merged_settings, untyped connect_reply) -> (nil | untyped)

        def event_harvest_config_is_valid: (untyped connect_reply) -> untyped

        def filter_keys: (untyped merged_settings) -> untyped

        # These feature gates are not intended to be bullet-proof, but only to
        # avoid the overhead of collecting and transmitting additional data if
        # the user's subscription level precludes its use. The server is the
        # ultimate authority regarding subscription levels, so we expect it to
        # do the real enforcement there.
        def apply_feature_gates: (untyped merged_settings, untyped connect_reply, untyped existing_config) -> untyped

        def ungated_value: (untyped key, untyped merged_settings, untyped existing_config) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class YamlSource < DottedHash
        attr_accessor file_path: untyped

        attr_accessor failures: untyped

        attr_reader generated_for_user: untyped

        attr_reader license_key: untyped

        # These are configuration options that have a value of a Hash
        # This is used in YamlSource#dot_flattened prevent flattening these values
        CONFIG_WITH_HASH_VALUE: ::Array["expected_messages" | "ignore_messages"]

        def initialize: (untyped path, untyped env) -> void

        def failed?: () -> untyped

        def validate_config_file_path: (untyped path) -> (nil | untyped)

        def warn_missing_config_file: (untyped path) -> untyped

        def process_erb: (untyped file) -> untyped

        def process_yaml: (untyped file, untyped env, untyped config, untyped path) -> untyped

        def substitute_transaction_threshold: (untyped config) -> untyped

        def booleanify_values: (untyped config, *untyped keys) -> untyped

        def is_boolean?: (untyped value) -> untyped

        def log_failure: (*untyped messages) -> untyped

        def dot_flattened: (untyped nested_hash, ?untyped names, ?::Hash[untyped, untyped] result) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      MASK_DEFAULTS: { thread_profiler: untyped, :"thread_profiler.enabled" => untyped }
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      # Helper since default Procs are evaluated in the context of this module
      def self.value_of: (untyped key) -> untyped

      # Combines potentially two properties into one.
      # Given the example:
      #    :disable_net_http and :prepend_net_instrumentation
      #    if :disable_net_http is true, then returned value is "disabled"
      #    if :prepend_net_instrumentation is false, then returned value is "chain"
      #    otherwise, "auto" is returned.
      #
      # Intent is:
      #     - if user sets disable_xxx property, then don't instrument
      #     - if user set prepend to `false` then we use method_alias chaining
      #     - auto, when returned means, try to use prepend unless conflicting gems discovered
      #
      def self.instrumentation_value_of: (untyped disable_key, ?untyped? prepend_key) -> untyped

      def self.instrumentation_value_from_boolean: (untyped key) -> untyped

      # Marks the config option as deprecated in the documentation once generated.
      # Does not appear in logs.
      def self.deprecated_description: (untyped new_setting, untyped description) -> ::String

      class Boolean
        def self.===: (untyped o) -> untyped
      end

      class DefaultSource
        attr_reader defaults: untyped

        # extend Forwardable

        def initialize: () -> void

        def default_values: () -> untyped

        def self.transform_for: (untyped key) -> untyped

        def self.config_search_paths: () -> untyped

        def self.config_path: () -> untyped

        def self.framework: () -> untyped

        def self.agent_enabled: () -> untyped

        DEFAULT_LOG_DIR: "log/"

        def self.audit_log_path: () -> untyped

        def self.app_name: () -> untyped

        def self.dispatcher: () -> untyped

        def self.thread_profiler_enabled: () -> untyped

        # This check supports the js_errors_beta key we've asked clients to
        # set. Once JS errors are GA, browser_monitoring.loader can stop
        # being dynamic.
        def self.browser_monitoring_loader: () -> untyped

        def self.transaction_tracer_transaction_threshold: () -> untyped

        def self.profiling_available: () -> untyped

        def self.host: () -> untyped

        def self.api_host: () -> untyped

        def self.convert_to_regexp_list: (untyped raw_value) -> untyped

        def self.convert_to_list: (untyped value) -> untyped

        SEMICOLON: ";"

        def self.convert_to_list_on_semicolon: (untyped value) -> untyped

        def self.convert_to_constant_list: (untyped raw_value) -> untyped

        def self.enforce_fallback: (?allowed_values: untyped? allowed_values, ?fallback: untyped? fallback) -> untyped
      end

      AUTOSTART_DENYLISTED_RAKE_TASKS: untyped

      DEFAULTS: { license_key: { default: ::String, public: true, type: untyped, allowed_from_server: false, description: "Your New Relic [license key](/docs/apis/intro-apis/new-relic-api-keys/#ingest-license-key)." }, agent_enabled: { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, allows the Ruby agent to run." }, enabled: { default: true, public: false, type: untyped, aliases: ::Array[:enable], allowed_from_server: false, description: "Enable or disable the agent." }, app_name: { default: untyped, public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Specify the [application name](/docs/apm/new-relic-apm/installation-configuration/name-your-application) used to aggregate data in the New Relic UI. To report data to [multiple apps at the same time](/docs/apm/new-relic-apm/installation-configuration/using-multiple-names-app), specify a list of names separated by a semicolon `;`. For example, `MyApp` or `MyStagingApp;Instance1`." }, entity_guid: { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: true, description: "The [Entity GUID](/attribute-dictionary/span/entityguid) for the entity running your agent." }, monitor_mode: { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: false, description: "When `true`, the agent transmits data about your app to the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector)." }, test_mode: { default: false, public: false, type: untyped, allowed_from_server: false, description: "Used in tests for the agent to start up, but not connect to the collector. Formerly used `developer_mode` in test config for this purpose." }, log_level: { default: "info", public: true, type: untyped, allowed_from_server: false, description: "Sets the level of detail of log messages. Possible log levels, in increasing verbosity, are: `error`, `warn`, `info` or `debug`." }, high_security: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, enables [high security mode](/docs/accounts-partnerships/accounts/security/high-security). Ensure you understand the implications of high security mode before enabling this setting." }, security_policies_token: { default: ::String, public: true, type: untyped, allowed_from_server: false, description: "Applies Language Agent Security Policy settings." }, proxy_host: { default: nil, allow_nil: true, public: true, type: untyped, allowed_from_server: false, description: "Defines a host for communicating with the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector) via a proxy server." }, proxy_port: { default: 8080, allow_nil: true, public: true, type: untyped, allowed_from_server: false, description: "Defines a port for communicating with the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector) via a proxy server." }, proxy_user: { default: nil, allow_nil: true, public: true, type: untyped, allowed_from_server: false, exclude_from_reported_settings: true, description: "Defines a user for communicating with the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector) via a proxy server." }, proxy_pass: { default: nil, allow_nil: true, public: true, type: untyped, allowed_from_server: false, exclude_from_reported_settings: true, description: "Defines a password for communicating with the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector) via a proxy server." }, capture_params: { default: false, public: true, type: untyped, allowed_from_server: false, description: ::String }, config_path: { default: untyped, public: true, type: untyped, allowed_from_server: false, description: "Path to <b>newrelic.yml</b>. If undefined, the agent checks the following directories (in order): <b>config/newrelic.yml</b>, <b>newrelic.yml</b>, <b>$HOME/.newrelic/newrelic.yml</b> and <b>$HOME/newrelic.yml</b>." }, config_search_paths: { default: untyped, public: false, type: untyped, allowed_from_server: false, description: "An array of candidate locations for the agent's configuration file." }, dispatcher: { default: untyped, public: false, type: untyped, allowed_from_server: false, description: "Autodetected application component that reports metrics to New Relic." }, framework: { default: untyped, public: false, type: untyped, allowed_from_server: false, description: "Autodetected application framework used to enable framework-specific functionality." }, :"autostart.denylisted_constants" => { default: "Rails::Console", public: true, type: untyped, allowed_from_server: false, description: "Specify a list of constants that should prevent the agent from starting automatically. Separate individual constants with a comma `,`. For example, `Rails::Console,UninstrumentedBackgroundJob`." }, :"autostart.denylisted_executables" => { default: "irb,rspec", public: true, type: untyped, allowed_from_server: false, description: "Defines a comma-delimited list of executables that the agent should not instrument. For example, `rake,my_ruby_script.rb`." }, :"autostart.denylisted_rake_tasks" => { default: untyped, public: true, type: untyped, allowed_from_server: false, description: "Defines a comma-delimited list of Rake tasks that the agent should not instrument. For example, `assets:precompile,db:migrate`." }, disable_rake: { default: false, public: true, type: untyped, allowed_from_server: false, deprecated: true, description: untyped }, disable_rake_instrumentation: { default: false, public: false, type: untyped, allowed_from_server: false, deprecated: true, description: untyped }, :"rake.tasks" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Specify an array of Rake tasks to automatically instrument." }, :"rake.connect_timeout" => { default: 10, public: true, type: untyped, allowed_from_server: false, description: "Timeout for waiting on connect to complete before a rake task" }, apdex_t: { default: ::Float, public: true, type: untyped, allowed_from_server: true, deprecated: true, description: "For agent versions 3.5.0 or higher, [set your Apdex T via the New Relic UI](/docs/apm/new-relic-apm/apdex/changing-your-apdex-settings)." }, :"strip_exception_messages.enabled" => { default: untyped, documentation_default: false, public: true, type: untyped, allowed_from_server: false, description: "If true, the agent strips messages from all exceptions except those in the [allowlist](#strip_exception_messages-allowlist). Enabled automatically in [high security mode](/docs/accounts-partnerships/accounts/security/high-security)." }, :"strip_exception_messages.allowed_classes" => { default: ::String, public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Specify a list of exceptions you do not want the agent to strip when [strip_exception_messages](#strip_exception_messages-enabled) is `true`. Separate exceptions with a comma. For example, `\"ImportantException,PreserveMessageException\"`." }, host: { default: untyped, public: false, type: untyped, allowed_from_server: false, description: "URI for the New Relic data collection service." }, api_host: { default: untyped, public: false, type: untyped, allowed_from_server: false, description: "API host for New Relic." }, port: { default: 443, public: false, type: untyped, allowed_from_server: false, description: "Port for the New Relic data collection service." }, api_port: { default: untyped, public: false, type: untyped, allowed_from_server: false, description: "Port for the New Relic API host." }, sync_startup: { default: false, public: true, type: untyped, allowed_from_server: false, description: "When set to `true`, forces a synchronous connection to the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector) during application startup. For very short-lived processes, this helps ensure the New Relic agent has time to report." }, send_data_on_exit: { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, enables the exit handler that sends data to the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector) before shutting down." }, max_payload_size_in_bytes: { default: 1000000, public: false, type: untyped, allowed_from_server: true, description: "Maximum number of bytes to send to the New Relic data collection service." }, put_for_data_send: { default: false, public: false, type: untyped, allowed_from_server: false, description: "Use HTTP PUT requests instead of POST." }, compressed_content_encoding: { default: "gzip", public: false, type: untyped, allowed_from_server: false, description: "Encoding to use if data needs to be compressed. The options are deflate and gzip." }, simple_compression: { default: false, public: false, type: untyped, allowed_from_server: false, description: "When enabled the agent will compress payloads destined for the collector, but will not pre-compress parts of the payload." }, timeout: { default: untyped, public: true, type: untyped, allowed_from_server: false, description: "Defines the maximum number of seconds the agent should spend attempting to connect to the collector." }, send_environment_info: { default: true, public: false, type: untyped, allowed_from_server: false, description: "Enable or disable transmission of application environment information to the New Relic data collection service." }, data_report_period: { default: 60, public: false, type: untyped, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic data collection service." }, event_report_period: { default: 60, public: false, type: untyped, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic event collection services." }, :"event_report_period.analytic_event_data" => { default: 60, public: false, type: untyped, dynamic_name: true, deprecated: true, allowed_from_server: true, description: untyped }, :"event_report_period.transaction_event_data" => { default: untyped, public: false, type: untyped, dynamic_name: true, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic transaction event collection services." }, :"event_report_period.custom_event_data" => { default: 60, public: false, type: untyped, dynamic_name: true, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic custom event collection services." }, :"event_report_period.error_event_data" => { default: 60, public: false, type: untyped, dynamic_name: true, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic error event collection services." }, :"event_report_period.log_event_data" => { default: 60, public: false, type: untyped, dynamic_name: true, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic log event collection services." }, :"event_report_period.span_event_data" => { default: 60, public: false, type: untyped, dynamic_name: true, allowed_from_server: true, description: "Number of seconds betwixt connections to the New Relic span event collection services." }, keep_retrying: { default: true, public: false, type: untyped, deprecated: true, allowed_from_server: false, description: "Enable or disable retrying failed connections to the New Relic data collection service." }, force_install_exit_handler: { default: false, public: true, type: untyped, allowed_from_server: false, description: "Forces the exit handler that sends all cached data to collector before shutting down to be installed regardless of detecting scenarios where it generally should not be. Known use-case for this option is where Sinatra is running as an embedded service within another framework and the agent is detecting the Sinatra app and skipping the `at_exit` handler as a result. Sinatra classically runs the entire application in an `at_exit` block and would otherwise misbehave if the Agent's `at_exit` handler was also installed in those circumstances.  Note: `send_data_on_exit` should also be set to `true` in  tandem with this setting." }, force_reconnect: { default: false, public: false, type: untyped, allowed_from_server: false, description: "Force a new connection to the server before running the worker loop. Creates a separate agent run and is recorded as a separate instance by the New Relic data collection service." }, report_instance_busy: { default: true, public: false, type: untyped, allowed_from_server: false, description: "Enable or disable transmission of metrics recording the percentage of time application instances spend servicing requests (duty cycle metrics)." }, log_file_name: { default: "newrelic_agent.log", public: true, type: untyped, allowed_from_server: false, description: "Defines a name for the log file." }, log_file_path: { default: untyped, public: true, type: untyped, allowed_from_server: false, description: "Defines a path to the agent log file, excluding the filename." }, :"audit_log.enabled" => { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, enables an audit log which logs communications with the New Relic [collector](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#collector)." }, :"audit_log.path" => { default: untyped, documentation_default: "config/newrelic_audit.log", public: true, type: untyped, allowed_from_server: false, description: "Specifies a path to the audit log file (including the filename)." }, :"audit_log.endpoints" => { default: ::Array[".*"], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "List of allowed endpoints to include in audit log" }, disable_samplers: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables the collection of sampler metrics. Sampler metrics are metrics that are not event-based (such as CPU time or memory usage)." }, disable_resque: { default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_sidekiq: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables [Sidekiq instrumentation](/docs/agents/ruby-agent/background-jobs/sidekiq-instrumentation)." }, disable_dj: { default: false, public: true, deprecated: true, type: untyped, allowed_from_server: false, description: untyped }, disable_sinatra: { default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_sinatra_auto_middleware: { default: false, public: true, type: untyped, allowed_from_server: false, description: ::String }, disable_view_instrumentation: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables view instrumentation." }, disable_harvest_thread: { default: false, public: false, type: untyped, allowed_from_server: false, description: "Enable or disable the harvest thread." }, skip_ar_instrumentation: { default: false, public: false, type: untyped, allowed_from_server: false, description: "Enable or disable active record instrumentation." }, disable_activerecord_instrumentation: { default: untyped, documentation_default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables active record instrumentation." }, prepend_active_record_instrumentation: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, uses `Module#prepend` rather than `alias_method` for ActiveRecord instrumentation." }, prepend_net_instrumentation: { default: true, public: false, type: untyped, allowed_from_server: false, deprecated: true, description: untyped }, :"instrumentation.net_http" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Net::HTTP at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.typhoeus" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Typhoeus at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.bunny" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of bunny at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.httprb" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of http.rb gem at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.resque" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of resque at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.redis" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Redis at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.rake" => { default: untyped, documentation_default: "auto", public: :true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of rake at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.mongo" => { default: untyped, documentation_default: "enabled", public: :true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Mongo at start up.  May be one of [enabled|disabled]." }, :"instrumentation.delayed_job" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Delayed Job at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.httpclient" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of HTTPClient at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.curb" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Curb at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.sinatra" => { default: untyped, documentation_default: "auto", public: :true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Sinatra at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.rack" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Rack. When enabled, the agent hooks into the `to_app` method in Rack::Builder to find gems to instrument during application startup.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.rack_urlmap" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Rack::URLMap at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.puma_rack" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Puma::Rack. When enabled, the agent hooks into the `to_app` method in Puma::Rack::Builder to find gems to instrument during application startup.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.puma_rack_urlmap" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Puma::Rack::URLMap at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.memcached" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of memcached gem for Memcache at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.memcache_client" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of memcache-client gem for Memcache at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.memcache" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of dalli gem for Memcache at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.logger" => { default: untyped, documentation_default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Ruby standard library Logger at start up.  May be one of [auto|prepend|chain|disabled]." }, :"instrumentation.tilt" => { default: "auto", public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of the Tilt template rendering library at start up. May be one of [auto|prepend|chain|disabled]." }, disable_data_mapper: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables DataMapper instrumentation." }, disable_activejob: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, disables ActiveJob instrumentation." }, disable_action_cable_instrumentation: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, disables Action Cable instrumentation." }, disable_active_storage: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, disables ActiveStorage instrumentation." }, disable_memcached: { default: untyped, documentation_default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_memcache_client: { default: untyped, documentation_default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_dalli: { default: untyped, documentation_default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_dalli_cas_client: { default: untyped, documentation_default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_memcache_instrumentation: { default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_gc_profiler: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables the use of GC::Profiler to measure time spent in garbage collection" }, :"sidekiq.capture_params" => { default: false, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, deprecated: true, description: "If `true`, enables the capture of job arguments for transaction traces and traced errors in Sidekiq." }, :"resque.capture_params" => { default: false, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, deprecated: true, description: "If `true`, enables the capture of job arguments for transaction traces and traced errors in Resque." }, :"resque.use_ruby_dns" => { default: true, public: false, type: untyped, allowed_from_server: false, description: "Replace the libc DNS resolver with the all Ruby resolver Resolv" }, capture_memcache_keys: { default: false, public: true, type: untyped, allowed_from_server: true, description: "Enable or disable the capture of memcache keys from transaction traces." }, :"transaction_tracer.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, enables collection of [transaction traces](/docs/apm/traces/transaction-traces/transaction-traces)." }, :"transaction_tracer.transaction_threshold" => { default: untyped, public: true, type: untyped, allowed_from_server: true, description: "Specify a threshold in seconds. Transactions with a duration longer than this threshold are eligible for transaction traces. Specify a float value or the string `apdex_f`." }, :"transaction_tracer.record_sql" => { default: "obfuscated", public: true, type: untyped, allowed_from_server: true, description: ::String }, :"transaction_tracer.record_redis_arguments" => { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent records Redis command arguments in transaction traces." }, :"transaction_tracer.capture_attributes" => { default: true, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: "Use [`transaction_tracer.attributes.enabled`](#transaction_tracer-attributes-enabled) instead." }, :"transaction_tracer.explain_threshold" => { default: ::Float, public: true, type: untyped, allowed_from_server: true, description: "Threshold (in seconds) above which the agent will collect explain plans. Relevant only when [`explain_enabled`](#transaction_tracer.explain_enabled) is true." }, :"transaction_tracer.explain_enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if [`slow_sql.explain_enabled`](#slow_sql-explain_enabled) is not set separately." }, :"transaction_tracer.stack_trace_threshold" => { default: ::Float, public: true, type: untyped, allowed_from_server: true, description: "Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold." }, :"transaction_tracer.limit_segments" => { default: 4000, public: true, type: untyped, allowed_from_server: true, description: "Maximum number of transaction trace nodes to record in a single transaction trace." }, disable_sequel_instrumentation: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, disables [Sequel instrumentation](/docs/agents/ruby-agent/frameworks/sequel-instrumentation)." }, disable_database_instrumentation: { default: false, public: true, type: untyped, allowed_from_server: false, deprecated: true, description: "Use [`disable_sequel_instrumentation`](#disable_sequel_instrumentation) instead." }, disable_mongo: { default: false, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, deprecated: true, description: untyped }, disable_redis: { default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, disable_redis_instrumentation: { default: false, public: false, type: untyped, deprecated: true, allowed_from_server: false, description: untyped }, :"message_tracer.segment_parameters.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent will collect metadata about messages and attach them as segment parameters." }, :"slow_sql.enabled" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent collects [slow SQL queries](/docs/apm/applications-menu/monitoring/viewing-slow-query-details)." }, :"slow_sql.explain_threshold" => { default: untyped, documentation_default: ::Float, public: true, type: untyped, allowed_from_server: true, description: "Specify a threshold in seconds. The agent collects [slow SQL queries](/docs/apm/applications-menu/monitoring/viewing-slow-query-details) and explain plans that exceed this threshold." }, :"slow_sql.explain_enabled" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent collects explain plans in slow SQL queries. If this setting is omitted, the [`transaction_tracer.explain_enabled`](#transaction_tracer-explain_enabled) setting will be applied as the default setting for explain plans in slow SQL as well." }, :"slow_sql.record_sql" => { default: untyped, documentation_default: "obfuscated", public: true, type: untyped, allowed_from_server: true, description: "Defines an obfuscation level for slow SQL queries. Valid options are `obfuscated`, `raw`, or `none`)." }, :"slow_sql.use_longer_sql_id" => { default: false, public: true, type: untyped, allowed_from_server: true, description: "Generate a longer sql_id for slow SQL traces. sql_id is used for aggregation of similar queries." }, :"mongo.capture_queries" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent captures Mongo queries in transaction traces." }, :"mongo.obfuscate_queries" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent obfuscates Mongo queries in transaction traces." }, :"error_collector.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent captures traced errors and error count metrics." }, :"error_collector.capture_attributes" => { default: true, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: "Use [`error_collector.attributes.enabled`](#error_collector-attributes-enabled) instead." }, :"error_collector.ignore_errors" => { default: "ActionController::RoutingError,Sinatra::NotFound", public: true, type: untyped, deprecated: true, allowed_from_server: true, dynamic_name: true, description: ::String }, :"error_collector.ignore_classes" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: ::String }, :"error_collector.ignore_messages" => { default: ::Hash[untyped, untyped], public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: ::String }, :"error_collector.ignore_status_codes" => { default: ::String, public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: "A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be ignored." }, :"error_collector.expected_classes" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: ::String }, :"error_collector.expected_messages" => { default: ::Hash[untyped, untyped], public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: ::String }, :"error_collector.expected_status_codes" => { default: ::String, public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: "A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be treated as expected." }, :"error_collector.max_backtrace_frames" => { default: 50, public: true, type: untyped, allowed_from_server: false, description: "Defines the maximum number of frames in an error backtrace. Backtraces over this amount are truncated at the beginning and end." }, :"error_collector.capture_events" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: true, dynamic_name: true, description: "If `true`, the agent collects [TransactionError events](/docs/insights/new-relic-insights/decorating-events/error-event-default-attributes-insights)." }, :"error_collector.max_event_samples_stored" => { default: 100, public: true, type: untyped, allowed_from_server: true, description: "Defines the maximum number of [TransactionError events](/docs/insights/new-relic-insights/decorating-events/error-event-default-attributes-insights) reported per harvest cycle." }, :"rum.enabled" => { default: true, public: false, type: untyped, allowed_from_server: true, description: "Enable or disable page load timing (sometimes referred to as real user monitoring or RUM)." }, browser_key: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Real user monitoring license key for the browser timing header." }, beacon: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Beacon for real user monitoring." }, error_beacon: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Error beacon for real user monitoring." }, application_id: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Application ID for real user monitoring." }, js_agent_file: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Javascript agent file for real user monitoring." }, :"browser_monitoring.auto_instrument" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, enables [auto-injection](/docs/browser/new-relic-browser/installation-configuration/adding-apps-new-relic-browser#select-apm-app) of the JavaScript header for page load timing (sometimes referred to as real user monitoring or RUM)." }, :"browser_monitoring.capture_attributes" => { default: false, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: "Use [`browser_monitoring.attributes.enabled`](#browser_monitoring-attributes-enabled) instead." }, :"browser_monitoring.loader" => { default: untyped, public: false, type: untyped, allowed_from_server: true, description: "Type of JavaScript agent loader to use for browser monitoring instrumentation." }, :"browser_monitoring.loader_version" => { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Version of JavaScript agent loader (returned from the New Relic [collector](/docs/apm/new-relic-apm/getting-started/glossary#collector).)" }, :"browser_monitoring.debug" => { default: false, public: false, type: untyped, allowed_from_server: true, description: "Enable or disable debugging version of JavaScript agent loader for browser monitoring instrumentation." }, :"browser_monitoring.ssl_for_http" => { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: true, description: "Enable or disable HTTPS instrumentation by JavaScript agent on HTTP pages." }, js_agent_loader: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "JavaScript agent loader content." }, js_errors_beta: { default: false, public: false, type: untyped, allowed_from_server: false, deprecated: true, description: "Enable or disable beta JavaScript error reporting." }, trusted_account_ids: { default: ::Array[untyped], public: false, type: untyped, allowed_from_server: true, description: "List of trusted New Relic account IDs for the purposes of cross-application tracing. Inbound requests from applications including cross-application headers that do not come from an account in this list will be ignored." }, :"cross_application_tracer.enabled" => { default: false, public: true, type: untyped, allowed_from_server: true, deprecated: true, description: untyped }, cross_application_tracing: { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: false, deprecated: true, description: "Deprecated in favor of distributed_tracing.enabled" }, encoding_key: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Encoding key for cross-application tracing." }, cross_process_id: { default: ::String, public: false, type: untyped, allowed_from_server: true, description: "Cross process ID for cross-application tracing." }, :"thread_profiler.enabled" => { default: untyped, documentation_default: false, public: true, type: untyped, allowed_from_server: true, description: "If `true`, enables use of the [thread profiler](/docs/apm/applications-menu/events/thread-profiler-tool)." }, :"thread_profiler.max_profile_overhead" => { default: ::Float, public: false, type: untyped, allowed_from_server: true, description: "Maximum overhead percentage for thread profiling before agent reduces polling frequency" }, marshaller: { default: "json", public: true, type: untyped, allowed_from_server: false, description: "Specifies a marshaller for transmitting data to the New Relic [collector](/docs/apm/new-relic-apm/getting-started/glossary#collector). Currently `json` is the only valid value for this setting." }, :"analytics_events.enabled" => { default: true, public: true, type: untyped, deprecated: true, allowed_from_server: true, description: untyped }, :"analytics_events.max_samples_stored" => { default: 1200, public: true, type: untyped, deprecated: true, allowed_from_server: true, description: untyped }, :"transaction_events.enabled" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, enables transaction event sampling." }, :"transaction_events.max_samples_stored" => { default: untyped, documentation_default: 1200, public: true, type: untyped, allowed_from_server: true, description: "Defines the maximum number of transaction events reported from a single harvest." }, :"analytics_events.capture_attributes" => { default: true, public: true, type: untyped, deprecated: true, allowed_from_server: false, description: "Use [`transaction_events.attributes.enabled`](#transaction_events-attributes-enabled) instead." }, restart_thread_in_children: { default: true, public: false, type: untyped, allowed_from_server: false, description: "Controls whether to check on running a transaction whether to respawn the harvest thread." }, normalize_json_string_encodings: { default: true, public: false, type: untyped, allowed_from_server: false, description: "Controls whether to normalize string encodings prior to serializing data for the collector to JSON." }, backport_fast_active_record_connection_lookup: { default: false, public: true, type: untyped, allowed_from_server: false, description: "Backports the faster ActiveRecord connection lookup introduced in Rails 6, which improves agent performance when instrumenting ActiveRecord. Note that this setting may not be compatible with other gems that patch ActiveRecord." }, disable_vm_sampler: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, the agent won't [sample performance measurements from the Ruby VM](/docs/agents/ruby-agent/features/ruby-vm-measurements)." }, disable_memory_sampler: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, the agent won't sample the memory usage of the host process." }, disable_cpu_sampler: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, the agent won't sample the CPU usage of the host process." }, disable_delayed_job_sampler: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, the agent won't measure the depth of Delayed Job queues." }, disable_active_record_notifications: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "If `true`, disables instrumentation for ActiveRecord 4, 5, and 6." }, disable_bunny: { default: false, public: true, type: untyped, deprecated: true, dynamic_name: true, allowed_from_server: false, description: untyped }, disable_curb: { default: false, public: true, type: untyped, deprecated: true, dynamic_name: true, allowed_from_server: false, description: untyped }, disable_excon: { default: false, public: true, type: untyped, dynamic_name: true, deprecated: true, allowed_from_server: false, description: untyped }, :"instrumentation.excon" => { default: untyped, documentation_default: "enabled", public: :true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Excon at start up.  May be one of [enabled|disabled]." }, disable_httpclient: { default: false, public: true, type: untyped, dynamic_name: true, deprecated: true, allowed_from_server: false, description: untyped }, disable_net_http: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, deprecated: true, description: untyped }, disable_rack: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, deprecated: true, description: untyped }, disable_rack_urlmap: { default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, deprecated: true, description: untyped }, disable_puma_rack: { default: untyped, documentation_default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, deprecated: true, description: untyped }, disable_puma_rack_urlmap: { default: untyped, documentation_default: false, public: true, type: untyped, dynamic_name: true, allowed_from_server: false, deprecated: true, description: untyped }, disable_typhoeus: { default: false, public: true, type: untyped, dynamic_name: true, deprecated: true, allowed_from_server: false, description: untyped }, disable_httprb: { default: false, public: true, type: untyped, dynamic_name: true, deprecated: true, allowed_from_server: false, description: untyped }, disable_middleware_instrumentation: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent won't wrap third-party middlewares in instrumentation (regardless of whether they are installed via Rack::Builder or Rails)." }, disable_rails_middleware: { default: false, public: false, type: untyped, allowed_from_server: false, description: "Internal name for controlling Rails 3+ middleware instrumentation" }, :"heroku.use_dyno_names" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent uses Heroku dyno names as the hostname." }, :"heroku.dyno_name_prefixes_to_shorten" => { default: ::Array["scheduler" | "run"], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Ordinarily the agent reports dyno names with a trailing dot and process ID (for example, <b>worker.3</b>). You can remove this trailing data by specifying the prefixes you want to report without trailing data (for example, <b>worker</b>)." }, :"process_host.display_name" => { default: untyped, public: true, type: untyped, allowed_from_server: false, description: "Specify a custom host name for [display in the New Relic UI](/docs/apm/new-relic-apm/maintenance/add-rename-remove-hosts#display_name)." }, labels: { default: ::String, public: true, type: untyped, allowed_from_server: false, description: "A dictionary of [label names](/docs/data-analysis/user-interface-functions/labels-categories-organize-your-apps-servers) and values that will be applied to the data sent from this agent. May also be expressed as a semicolon-delimited `;` string of colon-separated `:` pairs. For example, `<var>Server</var>:<var>One</var>;<var>Data Center</var>:<var>Primary</var>`." }, aggressive_keepalive: { default: true, public: false, type: untyped, allowed_from_server: true, description: "If true, attempt to keep the TCP connection to the collector alive between harvests." }, keep_alive_timeout: { default: 60, public: false, type: untyped, allowed_from_server: true, description: "Timeout for keep alive on TCP connection to collector if supported by Ruby version. Only used in conjunction when aggressive_keepalive is enabled." }, ca_bundle_path: { default: nil, allow_nil: true, public: true, type: untyped, allowed_from_server: false, description: "Manual override for the path to your local CA bundle. This CA bundle will be used to validate the SSL certificate presented by New Relic's data collection service." }, :"rules.ignore_url_regexes" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: true, transform: untyped, description: "Define transactions you want the agent to ignore, by specifying a list of patterns matching the URI you want to ignore. See documentation on (ignoring specific transactions)[https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ignoring-specific-transactions/#config-ignoring] for more details." }, :"synthetics.traces_limit" => { default: 20, public: false, type: untyped, allowed_from_server: true, description: "Maximum number of synthetics transaction traces to hold for a given harvest" }, :"synthetics.events_limit" => { default: 200, public: false, type: untyped, allowed_from_server: true, description: "Maximum number of synthetics transaction events to hold for a given harvest" }, :"custom_insights_events.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent captures [custom events](/docs/insights/new-relic-insights/adding-querying-data/inserting-custom-events-new-relic-apm-agents)." }, :"custom_insights_events.max_samples_stored" => { default: 1000, public: true, type: untyped, allowed_from_server: true, description: "Specify a maximum number of custom events to buffer in memory at a time.", dynamic_name: true }, :"application_logging.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, enables log decoration and the collection of log events and metrics." }, :"application_logging.forwarding.enabled" => { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures log records emitted by your application." }, :"application_logging.forwarding.max_samples_stored" => { default: 10000, public: true, type: untyped, allowed_from_server: true, description: "Defines the maximum number of log records to buffer in memory at a time.", dynamic_name: true }, :"application_logging.metrics.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, the agent captures metrics related to logging for your application." }, :"application_logging.local_decorating.enabled" => { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent decorates logs with metadata to link to entities, hosts, traces, and spans." }, :"instrumentation.active_support_logger" => { default: untyped, documentation_default: "auto", dynamic_name: true, public: true, type: untyped, allowed_from_server: false, description: "Controls auto-instrumentation of ActiveSupport::Logger at start up.  May be one of [auto|prepend|chain|disabled]." }, disable_grape_instrumentation: { default: false, public: false, type: untyped, allowed_from_server: false, deprecated: true, description: untyped }, disable_grape: { default: false, public: true, type: untyped, allowed_from_server: false, deprecated: true, description: untyped }, :"instrumentation.grape" => { default: untyped, documentation_default: "auto", public: :true, type: untyped, dynamic_name: true, allowed_from_server: false, description: "Controls auto-instrumentation of Grape at start up.  May be one of [auto|prepend|chain|disabled]." }, :"attributes.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, enables capture of attributes for all destinations." }, :"transaction_tracer.attributes.enabled" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures attributes from transaction traces." }, :"transaction_events.attributes.enabled" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures attributes from transaction events." }, :"error_collector.attributes.enabled" => { default: untyped, documentation_default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures attributes from error collection." }, :"browser_monitoring.attributes.enabled" => { default: untyped, documentation_default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures attributes from browser monitoring." }, :"span_events.attributes.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures attributes on span events." }, :"transaction_segments.attributes.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent captures attributes on transaction segments." }, :"attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from all destinations. Allows `*` as wildcard at end." }, :"transaction_tracer.attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from transaction traces. Allows `*` as wildcard at end." }, :"transaction_events.attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from transaction events. Allows `*` as wildcard at end." }, :"error_collector.attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from error collection. Allows `*` as wildcard at end." }, :"browser_monitoring.attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from browser monitoring. Allows `*` as wildcard at end." }, :"span_events.attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from span events. Allows `*` as wildcard at end." }, :"transaction_segments.attributes.exclude" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to exclude from transaction segments. Allows `*` as wildcard at end." }, :"attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include in all destinations. Allows `*` as wildcard at end." }, :"transaction_tracer.attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include in transaction traces. Allows `*` as wildcard at end." }, :"transaction_events.attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include in transaction events. Allows `*` as wildcard at end." }, :"error_collector.attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include in error collection. Allows `*` as wildcard at end." }, :"browser_monitoring.attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include in browser monitoring. Allows `*` as wildcard at end." }, :"span_events.attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include on span events. Allows `*` as wildcard at end." }, :"transaction_segments.attributes.include" => { default: ::Array[untyped], public: true, type: untyped, allowed_from_server: false, transform: untyped, description: "Prefix of attributes to include on transaction segments. Allows `*` as wildcard at end." }, :"custom_attributes.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `false`, custom attributes will not be sent on events." }, :"utilization.detect_aws" => { default: true, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, description: "If `true`, the agent automatically detects that it is running in an AWS environment." }, :"utilization.detect_azure" => { default: true, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, description: "If `true`, the agent automatically detects that it is running in an Azure environment." }, :"utilization.detect_gcp" => { default: true, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, description: "If `true`, the agent automatically detects that it is running in an Google Cloud Platform environment." }, :"utilization.detect_pcf" => { default: true, public: true, type: untyped, allowed_from_server: false, dynamic_name: true, description: "If `true`, the agent automatically detects that it is running in a Pivotal Cloud Foundry environment." }, :"utilization.detect_docker" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent automatically detects that it is running in Docker." }, :"utilization.detect_kubernetes" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent automatically detects that it is running in Kubernetes." }, :"utilization.billing_hostname" => { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: false, description: "The configured server name by a customer." }, :"utilization.logical_processors" => { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: false, description: "The total number of hyper-threaded execution contexts available." }, :"utilization.total_ram_mib" => { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: false, description: "This value represents the total amount of memory available to the host (not the process), in mebibytes (1024 squared or 1,048,576 bytes)." }, :"datastore_tracer.instance_reporting.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `false`, the agent will not report datastore instance metrics, nor add `host` or `port_path_or_id` parameters to transaction or slow SQL traces." }, :"datastore_tracer.database_name_reporting.enabled" => { default: true, public: true, type: untyped, allowed_from_server: false, description: "If `false`, the agent will not add `database_name` parameter to transaction or slow sql traces." }, clear_transaction_state_after_fork: { default: false, public: true, type: untyped, allowed_from_server: false, description: "If `true`, the agent will clear `Tracer::State` in `Agent.drop_buffered_data`." }, account_id: { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: true, description: "The account id associated with your application." }, primary_application_id: { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: true, description: "The primary id associated with your application." }, :"distributed_tracing.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "Distributed tracing lets you see the path that a request takes through your distributed system. Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the [transition guide](/docs/transition-guide-distributed-tracing) before you enable this feature." }, trusted_account_key: { default: nil, allow_nil: true, public: false, type: untyped, allowed_from_server: true, description: "A shared key to validate that a distributed trace payload came from a trusted account." }, sampling_target: { default: 10, public: false, type: untyped, allowed_from_server: true, description: "The target number of transactions to mark as sampled during a sampled period." }, sampling_target_period_in_seconds: { default: 60, public: false, type: untyped, allowed_from_server: true, description: "The period during which a target number of transactions should be marked as sampled." }, :"span_events.enabled" => { default: true, public: true, type: untyped, allowed_from_server: true, description: "If `true`, enables span event sampling." }, :"span_events.queue_size" => { default: 10000, public: true, type: untyped, allowed_from_server: false, external: :infinite_tracing, description: "Sets the maximum number of span events to buffer when streaming to the trace observer." }, :"span_events.max_samples_stored" => { default: 2000, public: true, type: untyped, allowed_from_server: true, description: "Defines the maximum number of span events reported from a single harvest. Any Integer between 1 and 10000 is valid." }, exclude_newrelic_header: { default: false, public: true, type: untyped, allowed_from_server: true, description: "Allows newrelic distributed tracing headers to be suppressed on outbound requests." }, :"infinite_tracing.trace_observer.host" => { default: ::String, public: true, type: untyped, allowed_from_server: false, external: :infinite_tracing, description: "Configures the hostname for the Trace Observer Host. When configured, enables tail-based sampling by sending all recorded spans to a Trace Observer for further sampling decisions, irrespective of any usual agent sampling decision." }, :"infinite_tracing.trace_observer.port" => { default: 443, public: true, type: untyped, allowed_from_server: false, external: :infinite_tracing, description: "Configures the TCP/IP port for the Trace Observer Host" } }
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class SecurityPolicySource < DottedHash
        def self.enabled?: (untyped option) -> untyped

        def self.record_sql_enabled?: (untyped option) -> untyped

        def self.not_empty?: (untyped option) -> untyped

        def self.change_setting: (untyped policies, untyped option, untyped new_value) -> untyped

        SECURITY_SETTINGS_MAP: ::Hash[::String, ::Array[{ option: :"transaction_tracer.record_sql", supported: true, enabled_fn: untyped, disabled_value: "off", permitted_fn: untyped } | { option: :"slow_sql.record_sql", supported: true, enabled_fn: untyped, disabled_value: "off", permitted_fn: untyped } | { option: :"mongo.capture_queries", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: untyped } | { option: :"transaction_tracer.record_redis_arguments", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil }] | ::Array[{ option: :"attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil } | { option: :"transaction_tracer.attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil } | { option: :"transaction_events.attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil } | { option: :"error_collector.attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil } | { option: :"browser_monitoring.attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil } | { option: :"span_events.attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil } | { option: :"transaction_segments.attributes.include", supported: true, enabled_fn: untyped, disabled_value: ::Array[untyped], permitted_fn: nil }] | ::Array[{ option: :"strip_exception_messages.enabled", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil }] | ::Array[{ option: :"custom_insights_events.enabled", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil }] | ::Array[{ option: :"custom_attributes.enabled", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil }] | ::Array[{ option: nil, supported: false, enabled_fn: nil, disabled_value: nil, permitted_fn: nil }] | ::Array[{ option: :"message_tracer.segment_parameters.enabled", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil }] | ::Array[{ option: :"resque.capture_params", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil } | { option: :"sidekiq.capture_params", supported: true, enabled_fn: untyped, disabled_value: false, permitted_fn: nil }]]

        def initialize: (untyped security_policies) -> void

        ENABLED: "enabled"

        COLON_COLON: "::"

        def build_overrides: (untyped security_policies) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class EnvironmentSource < DottedHash
        SUPPORTED_PREFIXES: ::Regexp

        SPECIAL_CASE_KEYS: ::Array["NEW_RELIC_ENV" | "NEW_RELIC_LOG" | ::Regexp]

        attr_accessor alias_map: untyped

        attr_accessor type_map: untyped

        def initialize: () -> void

        def set_aliases: (untyped config_setting, untyped value) -> (nil | untyped)

        def set_dotted_alias: (untyped original_config_setting) -> untyped

        def set_log_file: () -> untyped

        def set_config_file: () -> untyped

        def set_values_from_new_relic_environment_variables: () -> untyped

        def set_value_from_environment_variable: (untyped key) -> untyped

        def set_key_by_type: (untyped config_key, untyped environment_key) -> untyped

        def convert_environment_key_to_config_key: (untyped key) -> untyped

        def collect_new_relic_environment_variable_keys: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Configuration
      class ManualSource < DottedHash
        def initialize: (untyped hash) -> void
      end
    end
  end
end

module NewRelic
  module Agent
    module Hostname
      def self.get: () -> untyped

      # Pass '-f' to the external executable 'hostname' to request the fully
      # qualified domain name (fqdn). For implementations of 'hostname' that
      # do not support '-f' (such as the one OpenBSD ships with), fall back
      # to calling 'hostname' without the '-f'. If both ways of calling
      # 'hostname' fail, or in a context where 'hostname' is not even
      # available (within an AWS Lambda function, for example), call the
      # 'get' method which uses Socket instead of an external executable.
      def self.get_fqdn: () -> untyped

      def self.heroku_dyno_name_prefix: (untyped dyno_name) -> untyped

      def self.get_dyno_prefixes: () -> untyped

      LOCALHOST: ::Array["localhost" | "0.0.0.0" | "127.0.0.1" | "0:0:0:0:0:0:0:1" | "0:0:0:0:0:0:0:0" | "::1" | "::"]

      def self.local?: (untyped host_or_ip) -> untyped

      def self.get_external: (untyped host_or_ip) -> untyped
    end
  end
end

module NewRelic
  module Agent
    # This class contains the logic for recording and storing transaction
    # traces (sometimes referred to as 'transaction samples').
    #
    # A transaction trace is a detailed timeline of the events that happened
    # during the processing of a single transaction, including database calls,
    # template rendering calls, and other instrumented method calls.
    #
    # @api public
    class TransactionSampler
      attr_reader last_sample: untyped

      def initialize: () -> void

      def enabled?: () -> untyped

      def on_finishing_transaction: (untyped txn) -> (nil | untyped)

      def store_sample: (untyped sample) -> untyped

      # Gather transaction traces that we'd like to transmit to the server.
      def harvest!: () -> (::Array[untyped] | untyped)

      def prepare_samples: (untyped samples) -> untyped

      def merge!: (untyped previous) -> untyped

      def count: () -> untyped

      def harvest_from_sample_buffers: () -> untyped

      # reset samples without rebooting the web server (used by dev mode)
      def reset!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    #
    # This module contains helper methods related to gathering linking
    # metadata for use with logs in context.
    module LinkingMetadata
      extend ::NewRelic::Agent::LinkingMetadata

      def append_service_linking_metadata: (untyped metadata) -> untyped

      def append_trace_linking_metadata: (untyped metadata) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class JavascriptInstrumentor
      include NewRelic::Coerce

      RUM_KEY_LENGTH: 13

      def initialize: (untyped event_listener) -> void

      def log_configuration: () -> untyped

      def enabled?: () -> untyped

      def obfuscator: () -> untyped

      def js_enabled_and_ready?: () -> untyped

      def insert_js?: (untyped state) -> untyped

      def missing_config?: (untyped key) -> untyped

      def browser_timing_header: (?untyped? nonce) -> untyped

      def browser_timing_loader: (?untyped? nonce) -> untyped

      def browser_timing_config: (untyped state, ?untyped? nonce) -> (::String | untyped)

      def create_nonce: (?untyped? nonce) -> ::String

      BEACON_KEY: "beacon"

      ERROR_BEACON_KEY: "errorBeacon"

      LICENSE_KEY_KEY: "licenseKey"

      APPLICATIONID_KEY: "applicationID"

      TRANSACTION_NAME_KEY: "transactionName"

      QUEUE_TIME_KEY: "queueTime"

      APPLICATION_TIME_KEY: "applicationTime"

      AGENT_KEY: "agent"

      SSL_FOR_HTTP_KEY: "sslForHttp"

      ATTS_KEY: "atts"

      ATTS_USER_SUBKEY: "u"

      ATTS_AGENT_SUBKEY: "a"

      # NOTE: Internal prototyping may override this, so leave name stable!
      def data_for_js_agent: (untyped transaction) -> untyped

      def add_ssl_for_http: (untyped data) -> untyped

      def add_attributes: (untyped data, untyped txn) -> (nil | untyped)

      def append_custom_attributes!: (untyped txn, untyped atts) -> untyped

      def append_agent_attributes!: (untyped txn, untyped atts) -> untyped

      def html_safe_if_needed: (untyped string) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module TransactionEventPrimitive
      include NewRelic::Coerce

      extend ::NewRelic::Agent::TransactionEventPrimitive

      COMMA: ","

      # The type field of the sample
      SAMPLE_TYPE: "Transaction"

      # Strings for static keys of the sample structure
      TYPE_KEY: "type"

      TIMESTAMP_KEY: "timestamp"

      NAME_KEY: "name"

      DURATION_KEY: "duration"

      ERROR_KEY: "error"

      SAMPLED_KEY: "sampled"

      PRIORITY_KEY: "priority"

      GUID_KEY: "nr.guid"

      REFERRING_TRANSACTION_GUID_KEY: "nr.referringTransactionGuid"

      CAT_PATH_HASH_KEY: "nr.pathHash"

      CAT_REFERRING_PATH_HASH_KEY: "nr.referringPathHash"

      CAT_ALTERNATE_PATH_HASHES_KEY: "nr.alternatePathHashes"

      APDEX_PERF_ZONE_KEY: "nr.apdexPerfZone"

      SYNTHETICS_RESOURCE_ID_KEY: "nr.syntheticsResourceId"

      SYNTHETICS_JOB_ID_KEY: "nr.syntheticsJobId"

      SYNTHETICS_MONITOR_ID_KEY: "nr.syntheticsMonitorId"

      def create: (untyped payload) -> ::Array[untyped]

      private

      def append_optional_attributes: (untyped sample, untyped payload) -> untyped

      def append_cat_alternate_path_hashes: (untyped sample, untyped payload) -> untyped

      def optionally_append: (untyped sample_key, untyped payload_key, untyped sample, untyped payload) -> untyped

      def custom_attributes: (untyped attributes) -> untyped

      def agent_attributes: (untyped attributes) -> untyped
    end
  end
end

module NewRelic
  module Agent
    # This class handles all the statistics gathering for the agent
    class StatsEngine
      attr_accessor metric_rules: untyped

      def initialize: () -> void

      # All access to the @stats_hash ivar should be funnelled through this
      # method to ensure thread-safety.
      def with_stats_lock: () { () -> untyped } -> untyped

      # Update the unscoped metrics given in metric_names.
      # metric_names may be either a single name, or an array of names.
      #
      # This is an internal method, subject to change at any time. Client apps
      # and gems should use the public API (NewRelic::Agent.record_metric)
      # instead.
      #
      # There are four ways to use this method:
      #
      # 1. With a numeric value, it will update the Stats objects associated
      #    with the given metrics by calling record_data_point(value, aux).
      #    aux will be treated in this case as the exclusive time associated
      #    with the call being recorded.
      #
      # 2. With a value of :apdex_s, :apdex_t, or :apdex_f, it will treat the
      #    associated stats as an Apdex metric, updating it to reflect the
      #    occurrence of a transaction falling into the given category.
      #    The aux value in this case should be the apdex threshold used in
      #    bucketing the request.
      #
      # 3. If a block is given, value and aux will be ignored, and instead the
      #    Stats object associated with each named unscoped metric will be
      #    yielded to the block for customized update logic.
      #
      # 4. If value is a Stats instance, it will be merged into the Stats
      #    associated with each named unscoped metric.
      #
      # If this method is called during a transaction, the metrics will be
      # attached to the Transaction, and not merged into the global set until
      # the end of the transaction.
      #
      # Otherwise, the metrics will be recorded directly into the global set
      # of metrics, under a lock.
      #
      # @api private
      #
      def tl_record_unscoped_metrics: (untyped metric_names, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      def record_unscoped_metrics: (untyped state, untyped metric_names, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      # Like tl_record_unscoped_metrics, but records a scoped metric as well.
      #
      # This is an internal method, subject to change at any time. Client apps
      # and gems should use the public API (NewRelic::Agent.record_metric)
      # instead.
      #
      # The given scoped_metric will be recoded as both a scoped *and* an
      # unscoped metric. The summary_metrics will be recorded as unscoped
      # metrics only.
      #
      # If called during a transaction, all metrics will be attached to the
      # Transaction, and not merged into the global set of metrics until the
      # end of the transaction.
      #
      # If called outside of a transaction, only the *unscoped* metrics will
      # be recorded, directly into the global set of metrics (under a lock).
      #
      # @api private
      #
      def tl_record_scoped_and_unscoped_metrics: (untyped scoped_metric, ?untyped? summary_metrics, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      def record_scoped_and_unscoped_metrics: (untyped state, untyped scoped_metric, ?untyped? summary_metrics, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      # Helper for recording a straight value into the count
      def tl_record_supportability_metric_count: (untyped metric, untyped value) -> untyped

      def reset!: () -> untyped

      # merge data from previous harvests into this stats engine
      def merge!: (untyped other_stats_hash) -> untyped

      def merge_transaction_metrics!: (untyped txn_metrics, untyped scope) -> untyped

      def harvest!: () -> untyped

      def apply_rules_to_metric_data: (untyped rules_engine, untyped stats_hash) -> untyped

      def coerce_to_metric_spec_array: (untyped metric_names_or_specs, untyped scope) -> untyped

      # For use by test code only.
      def clear_stats: () -> untyped

      # For use by test code only.
      def to_h: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class RulesEngine
      SEGMENT_SEPARATOR: "/"

      LEADING_SLASH_REGEX: ::Regexp

      # include Enumerable[untyped]

      # extend Forwardable

      def self.create_metric_rules: (untyped connect_response) -> untyped

      def self.create_transaction_rules: (untyped connect_response) -> untyped

      # When multiple rules share the same prefix,
      # only apply the rule with the last instance of the prefix.
      # Note that the incoming rules are in reverse order to facilitate this.
      def self.reject_rules_with_duplicate_prefixes!: (untyped rules) -> untyped

      def initialize: (?untyped rules, ?untyped segment_term_rules) -> void

      def apply_rules: (untyped rules, untyped string) -> untyped

      def rename: (untyped original_string) -> (nil | untyped)
    end
  end
end

module NewRelic
  module Agent
    class PrioritySampledBuffer < EventBuffer
      PRIORITY_KEY: "priority"

      attr_reader seen_lifetime: untyped

      attr_reader captured_lifetime: untyped

      def initialize: (untyped capacity) -> void

      def heapify_items_array: () -> untyped

      # expects priority and a block, or an event as a hash with a `priority` key.
      def append: (?priority: untyped? priority, ?event: untyped? event) { () -> untyped } -> (nil | untyped)

      alias append_event append

      def capacity=: (untyped new_capacity) -> untyped

      def to_a: () -> untyped

      def decrement_lifetime_counts_by: (untyped n) -> untyped

      def sample_rate_lifetime: () -> untyped

      def metadata: () -> untyped

      private

      def increment_seen: () -> untyped

      def priority_for: (untyped event) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class SamplerCollection
      # include Enumerable[untyped]

      def initialize: (untyped event_listener) -> void

      def each: () { () -> untyped } -> untyped

      def clear: () -> untyped

      def sampler_class_registered?: (untyped sampler_class) -> untyped

      # adds samplers to the sampler collection so that they run every
      # minute. This is dynamically recognized by any class that
      # subclasses NewRelic::Agent::Sampler
      def load_samplers: () -> untyped

      def poll_samplers: () -> untyped

      def add_sampler: (untyped sampler_class) -> untyped
    end
  end
end

module NewRelic
  module Agent
    #
    # This module contains helper methods to facilitate
    # instrumentation of external requests not directly supported by
    # the Ruby agent. It is intended to be primarily used by authors
    # of 3rd-party instrumentation.
    #
    # @api public
    module External
      extend ::NewRelic::Agent::External

      NON_HTTP_CAT_ID_HEADER: "NewRelicID"

      NON_HTTP_CAT_TXN_HEADER: "NewRelicTransaction"

      NON_HTTP_CAT_SYNTHETICS_HEADER: "NewRelicSynthetics"

      NON_HTTP_CAT_CONTENT_LENGTH: -1

      # Process obfuscated +String+ indentifying a calling application and transaction that is also running a
      # New Relic agent and save information in current transaction for inclusion in a trace. The +String+ is
      # generated by +get_request_metadata+ on the calling application.
      #
      # @param request_metadata [String] received obfuscated request metadata
      #
      # @api public
      #
      def process_request_metadata: (untyped request_metadata) -> untyped

      # Obtain an obfuscated +String+ suitable for delivery across public networks that carries transaction
      # information from this application to a calling application which is also running a New Relic agent.
      # This +String+ can be processed by +process_response_metadata+ on the calling application.
      #
      # @return [String] obfuscated response metadata to send
      #
      # @api public
      #
      def get_response_metadata: () -> untyped

      private

      def obfuscator: () -> untyped
    end
  end
end

# encoding: utf-8
# This file is distributed under New Relic's license terms.
# See https://github.com/newrelic/newrelic-ruby-agent/blob/main/LICENSE for complete details.
#
# A Sampler is used to capture meaningful metrics in a background thread
# periodically.  They will be invoked about once a minute, each time the agent
# sends data to New Relic's servers.
#
# Samplers can be added to New Relic by subclassing NewRelic::Agent::Sampler.
# Instances are created when the agent is enabled and installed.  Subclasses
# are registered for instantiation automatically.
module NewRelic
  module Agent
    class Sampler
      # Exception denotes a sampler is not available and it will not be registered.
      class Unsupported < StandardError
      end

      attr_reader id: untyped

      attr_reader self.shorthand_name: untyped

      def self.named: (untyped new_name) -> untyped

      def self.inherited: (untyped subclass) -> untyped

      # Override with check.  Called before instantiating.
      def self.supported_on_this_platform?: () -> true

      def self.enabled?: () -> untyped

      def self.sampler_classes: () -> untyped

      # The ID passed in here is unused by our code, but is preserved in case
      # we have clients who are defining their own subclasses of this class, and
      # expecting to be able to call super with an ID.
      def initialize: (?untyped? id) -> void

      def poll: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Datastores
      module MetricHelper
        ROLLUP_METRIC: "Datastore/all"

        WEB_ROLLUP_METRIC: "Datastore/allWeb"

        OTHER_ROLLUP_METRIC: "Datastore/allOther"

        DEFAULT_PRODUCT_NAME: "ActiveRecord"

        OTHER: "Other"

        ALL: "all"

        ALL_WEB: "allWeb"

        ALL_OTHER: "allOther"

        def self.statement_metric_for: (untyped product, untyped collection, untyped operation) -> ::String

        def self.operation_metric_for: (untyped product, untyped operation) -> ::String

        def self.instance_metric_for: (untyped product, untyped host, untyped port_path_or_id) -> ::String

        def self.product_suffixed_rollup: (untyped product, untyped suffix) -> ::String

        def self.product_rollup: (untyped product) -> ::String

        def self.suffixed_rollup: (untyped suffix) -> ::String

        def self.all_suffix: () -> untyped

        def self.scoped_metric_for: (untyped product, untyped operation, ?untyped? collection) -> untyped

        def self.unscoped_metrics_for: (untyped product, untyped operation, ?untyped? collection, ?untyped? host, ?untyped? port_path_or_id) -> untyped

        def self.product_operation_collection_for: (untyped product, untyped operation, ?untyped? collection, ?untyped? generic_product) -> ::Array[untyped]

        def self.metrics_for: (untyped product, untyped operation, ?untyped? collection, ?untyped? generic_product, ?untyped? host, ?untyped? port_path_or_id) -> untyped

        def self.metrics_from_sql: (untyped product, untyped sql) -> untyped

        def self.operation_from_sql: (untyped sql) -> untyped

        def self.overridden_operation_and_collection: () -> untyped

        # If the override declared a product affiliation, abide by that
        # ActiveRecord has database-specific product names, so we recognize
        # it by the generic_product it passes.
        def self.should_override?: (untyped overrides, untyped product, untyped generic_product) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Datastores
      module Redis
        BINARY_DATA_PLACEHOLDER: "<binary data>"

        MAXIMUM_COMMAND_LENGTH: 1000

        MAXIMUM_ARGUMENT_LENGTH: 64

        CHUNK_SIZE: untyped

        PREFIX_RANGE: ::Range[::Integer]

        SUFFIX_RANGE: ::Range[::Integer]

        OBFUSCATE_ARGS: " ?"

        ELLIPSES: "..."

        NEWLINE: ::String

        SPACE: " "

        QUOTE: "\""

        ALL_BUT_FIRST: ::Range[::Integer]

        STRINGS_SUPPORT_ENCODING: untyped

        def self.format_command: (untyped command_with_args) -> untyped

        def self.format_pipeline_commands: (untyped commands_with_args) -> untyped

        def self.append_pipeline_command: (untyped result, untyped command_with_args) -> untyped

        def self.append_command_with_args: (untyped result, untyped command_with_args) -> untyped

        def self.append_command_with_no_args: (untyped result, untyped command_with_args) -> untyped

        def self.is_supported_version?: () -> untyped

        def self.ellipsize: (untyped result, untyped string) -> untyped

        def self.safe_from_third_party_gem?: () -> untyped

        def self.trim_result: (untyped result) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Datastores
      module Mongo
        module Obfuscator
          ALLOWLIST: ::Array[:operation]

          def self.obfuscate_statement: (untyped source, ?untyped allowlist) -> untyped

          QUESTION_MARK: "?"

          def self.obfuscate_value: (untyped value, ?untyped allowlist) -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module Datastores
      module Mongo
        module MetricTranslator
          def self.operation_and_collection_for: (untyped name, untyped payload) -> untyped

          MONGO_PRODUCT_NAME: "MongoDB"

          def self.collection_in_selector?: (untyped payload) -> untyped

          NAMES_IN_SELECTOR: ::Array[:findandmodify | "aggregate" | "count" | "group" | "mapreduce" | :distinct | :createIndexes | :deleteIndexes | :reIndex | :collstats | :renameCollection | :drop]

          def self.command_key_from_selector: (untyped payload) -> untyped

          def self.get_name_from_selector: (untyped command_key, untyped payload) -> untyped

          CMD_COLLECTION: "$cmd"

          def self.get_collection_from_selector: (untyped command_key, untyped payload) -> untyped

          def self.find_one?: (untyped name, untyped payload) -> untyped

          def self.find_and_modify?: (untyped name, untyped payload) -> untyped

          def self.find_and_remove?: (untyped name, untyped payload) -> untyped

          def self.create_indexes?: (untyped name, untyped paylod) -> untyped

          def self.create_index?: (untyped name, untyped payload) -> untyped

          def self.drop_indexes?: (untyped name, untyped payload) -> untyped

          def self.drop_index?: (untyped name, untyped payload) -> untyped

          def self.re_index?: (untyped name, untyped payload) -> untyped

          def self.group?: (untyped name, untyped payload) -> untyped

          def self.rename_collection?: (untyped name, untyped payload) -> untyped

          def self.collection_name_from_index: (untyped payload) -> (untyped | "system.indexes")

          def self.collection_name_from_group_selector: (untyped payload) -> untyped

          def self.collection_name_from_rename_selector: (untyped payload) -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module Datastores
      module Mongo
        module EventFormatter
          # Keys that will get their values replaced with '?'.
          OBFUSCATE_KEYS: ::Array["filter" | "query" | "pipeline"]

          # Keys that will get completely removed from the statement.
          DENYLISTED_KEYS: ::Array["deletes" | "documents" | "updates"]

          def self.format: (untyped command_name, untyped database_name, untyped command) -> (nil | untyped)

          def self.obfuscate: (untyped statement) -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module Datastores
      module Mongo
        def self.is_supported_version?: () -> untyped

        def self.is_unsupported_2x?: () -> untyped

        def self.is_monitoring_enabled?: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module MethodTracerHelpers
      MAX_ALLOWED_METRIC_DURATION: 1000000000

      extend ::NewRelic::Agent::MethodTracerHelpers

      def trace_execution_scoped: (untyped metric_names, ?untyped options) { () -> untyped } -> untyped
    end
  end
end

module NewRelic
  module Agent
    class Monitors
      attr_reader cross_app_monitor: untyped

      attr_reader synthetics_monitor: untyped

      attr_reader distributed_tracing_monitor: untyped

      def initialize: (untyped events) -> void
    end
  end
end

module NewRelic
  module Agent
    module GuidGenerator
      # This method intentionally does not use SecureRandom, because it relies
      # on urandom, which raises an exception in MRI when the interpreter runs
      # out of allocated file descriptors.
      # The guids generated by this method may not be _secure_, but they are
      # random enough for our purposes.
      def self?.generate_guid: (?::Integer length) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class InternalAgentError < StandardError
      def initialize: (?untyped? msg) -> void
    end
  end
end

module NewRelic
  module Agent
    module Deprecator
      def self.deprecate: (untyped method_name, ?untyped? new_method_name, ?untyped? version) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module AttributeProcessing
      EMPTY_HASH_STRING_LITERAL: "{}"

      EMPTY_ARRAY_STRING_LITERAL: "[]"

      def self?.flatten_and_coerce: (untyped object, ?untyped? prefix, ?::Hash[untyped, untyped] result) { () -> untyped } -> untyped

      def self?.flatten_and_coerce_hash: (untyped hash, untyped prefix, untyped result) { () -> untyped } -> untyped

      def self?.flatten_and_coerce_array: (untyped array, untyped prefix, untyped result) { () -> untyped } -> untyped
    end
  end
end

module NewRelic
  module Agent
    # This class collects errors from the parent application, storing
    # them until they are harvested and transmitted to the server
    class ErrorCollector
      # Maximum possible length of the queue - defaults to 20, may be
      # made configurable in the future. This is a tradeoff between
      # memory and data retention
      MAX_ERROR_QUEUE_LENGTH: 20

      EXCEPTION_TAG_IVAR: :@__nr_seen_exception

      attr_reader error_trace_aggregator: untyped

      attr_reader error_event_aggregator: untyped

      # Returns a new error collector
      def initialize: (untyped events) -> void

      def enabled?: () -> untyped

      def disabled?: () -> untyped

      # We store the passed block in both an ivar on the class, and implicitly
      # within the body of the ignore_filter_proc method intentionally here.
      # The define_method trick is needed to get around the fact that users may
      # call 'return' from within their filter blocks, which would otherwise
      # result in a LocalJumpError.
      #
      # The raw block is also stored in an instance variable so that we can
      # return it later in its original form.
      #
      # This is all done at the class level in order to avoid the case where
      # the user sets up an ignore filter on one instance of the ErrorCollector,
      # and then that instance subsequently gets discarded during agent startup.
      # (For example, if the agent is initially disabled, and then gets enabled
      # via a call to manual_start later on.)
      #
      def self.ignore_error_filter=: (untyped block) -> untyped

      def self.ignore_error_filter: () -> untyped

      def ignore: (untyped errors) -> untyped

      def ignore?: (untyped ex, ?untyped? status_code) -> untyped

      def expect: (untyped errors) -> untyped

      def expected?: (untyped ex, ?untyped? status_code) -> untyped

      def load_error_filters: () -> untyped

      def reset_error_filters: () -> untyped

      # Checks the provided error against the error filter, if there
      # is an error filter
      def ignored_by_filter_proc?: (untyped error) -> untyped

      # an error is ignored if it is nil or if it is filtered
      def error_is_ignored?: (untyped error, ?untyped? status_code) -> untyped

      # Calling instance_variable_set on a wrapped Java object in JRuby will
      # generate a warning unless that object's class has already been marked
      # as persistent, so we skip tagging of exception objects that are actually
      # wrapped Java objects on JRuby.
      #
      # See https://github.com/jruby/jruby/wiki/Persistence
      #
      def exception_is_java_object?: (untyped exception) -> untyped

      def exception_tagged_with?: (untyped ivar, untyped exception) -> (false | untyped)

      def tag_exception_using: (untyped ivar, untyped exception) -> (nil | untyped)

      def tag_exception: (untyped exception) -> (nil | untyped)

      def blamed_metric_name: (untyped txn, untyped options) -> untyped

      def aggregated_metric_names: (untyped txn) -> untyped

      # Increments a statistic that tracks total error rate
      def increment_error_count!: (untyped state, untyped exception, ?::Hash[untyped, untyped] options) -> untyped

      def increment_expected_error_count!: (untyped state, untyped exception) -> untyped

      def skip_notice_error?: (untyped exception, ?untyped? status_code) -> untyped

      # calls a method on an object, if it responds to it - used for
      # detection and soft fail-safe. Returns nil if the method does
      # not exist
      def sense_method: (untyped object, untyped method) -> untyped

      # extracts a stack trace from the exception for debugging purposes
      def extract_stack_trace: (untyped exception) -> untyped

      def notice_segment_error: (untyped segment, untyped exception, ?::Hash[untyped, untyped] options) -> untyped

      # See NewRelic::Agent.notice_error for options and commentary
      def notice_error: (untyped exception, ?::Hash[untyped, untyped] options, ?untyped? span_id) -> untyped

      def truncate_trace: (untyped trace, ?untyped? keep_frames) -> untyped

      def create_noticed_error: (untyped exception, untyped options) -> untyped

      # *Use sparingly for difficult to track bugs.*
      #
      # Track internal agent errors for communication back to New Relic.
      # To use, make a specific subclass of NewRelic::Agent::InternalAgentError,
      # then pass an instance of it to this method when your problem occurs.
      #
      # Limits are treated differently for these errors. We only gather one per
      # class per harvest, disregarding (and not impacting) the app error queue
      # limit.
      def notice_agent_error: (untyped exception) -> untyped

      def drop_buffered_data: () -> nil
    end
  end
end

module NewRelic
  module Agent
    class Harvester
      attr_accessor starting_pid: untyped

      # Inject target for after_fork call to avoid spawning thread in tests
      def initialize: (untyped events, ?untyped after_forker) -> void

      def on_transaction: (*untyped _) -> (nil | untyped)

      def mark_started: (?untyped pid) -> untyped

      def needs_restart?: (?untyped pid) -> untyped

      def restart_in_children_enabled?: () -> untyped

      def harvest_thread_enabled?: () -> untyped

      def restart_harvest_thread: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class CustomEventAggregator < EventAggregator
      include NewRelic::Coerce

      TYPE: "type"

      TIMESTAMP: "timestamp"

      PRIORITY: "priority"

      EVENT_TYPE_REGEX: ::Regexp

      def record: (untyped `type`, untyped attributes) -> (nil | false | untyped)

      private

      def create_event: (untyped `type`, untyped priority, untyped attributes) -> ::Array[::Hash[untyped, untyped] | untyped]

      def after_initialize: () -> untyped

      def after_harvest: (untyped metadata) -> untyped

      def note_dropped_events: (untyped total_count, untyped dropped_count) -> untyped

      def record_supportability_metrics: (untyped total_count, untyped captured_count, untyped dropped_count) -> untyped

      def note_dropped_event: (untyped `type`) -> untyped
    end
  end
end

# encoding: utf-8
# This file is distributed under New Relic's license terms.
# See https://github.com/newrelic/newrelic-ruby-agent/blob/main/LICENSE for complete details.
module NewRelic
  module Agent
    class Stats
      attr_accessor call_count: untyped

      attr_accessor min_call_time: untyped

      attr_accessor max_call_time: untyped

      attr_accessor total_call_time: untyped

      attr_accessor total_exclusive_time: untyped

      attr_accessor sum_of_squares: untyped

      def initialize: () -> void

      def reset: () -> untyped

      def is_reset?: () -> untyped

      def merge: (untyped other_stats) -> untyped

      def merge!: (untyped other) -> untyped

      def to_s: () -> ::String

      def to_json: (*untyped _) -> untyped

      def record: (?untyped? value, ?untyped? aux) { (untyped) -> untyped } -> untyped

      # record a single data point into the statistical gatherer.  The gatherer
      # will aggregate all data points collected over a specified period and upload
      # its data to the NewRelic server
      def record_data_point: (untyped value, ?untyped exclusive_time) -> untyped

      alias trace_call record_data_point

      # increments the call_count by one
      def increment_count: (?::Integer value) -> untyped

      # Concerned about implicit usage of inspect relying on stats format, so
      # putting back a version to get full inspection as separate method
      def inspect_full: () -> ::String

      def ==: (untyped other) -> untyped

      # Apdex-related accessors
      alias apdex_s call_count

      alias apdex_t total_call_time

      alias apdex_f total_exclusive_time

      def record_apdex: (untyped bucket, untyped apdex_t) -> untyped

      def min_time_less?: (untyped other) -> untyped
    end
  end
end

module NewRelic
  module Agent
    # The Agent is a singleton that is instantiated when the plugin is
    # activated.  It collects performance data from ruby applications
    # in realtime as the application runs, and periodically sends that
    # data to the NewRelic server.
    class Agent
      def self.config: () -> untyped

      def initialize: () -> void

      def setup_attribute_filter: () -> untyped

      def refresh_attribute_filter: () -> untyped

      # contains all the class-level methods for NewRelic::Agent::Agent
      module ClassMethods
        # Should only be called by NewRelic::Control - returns a
        # memoized singleton instance of the agent, creating one if needed
        def instance: () -> untyped
      end

      # Holds all the methods defined on NewRelic::Agent::Agent
      # instances
      module InstanceMethods
        # the statistics engine that holds all the timeslice data
        attr_reader stats_engine: untyped

        # the transaction sampler that handles recording transactions
        attr_reader transaction_sampler: untyped

        attr_reader sql_sampler: untyped

        # manages agent commands we receive from the collector, and the handlers
        attr_reader agent_command_router: untyped

        # error collector is a simple collection of recorded errors
        attr_reader error_collector: untyped

        attr_reader harvest_samplers: untyped

        # whether we should record raw, obfuscated, or no sql
        attr_reader record_sql: untyped

        # builder for JS agent scripts to inject
        attr_reader javascript_instrumentor: untyped

        # cross application tracing ids and encoding
        attr_reader cross_process_id: untyped

        attr_reader cross_app_encoding_bytes: untyped

        # service for communicating with collector
        attr_accessor service: untyped

        # Global events dispatcher. This will provides our primary mechanism
        # for agent-wide events, such as finishing configuration, error notification
        # and request before/after from Rack.
        attr_reader events: untyped

        # listens and responds to events that need to process headers
        # for synthetics and distributed tracing
        attr_reader monitors: untyped

        # Transaction and metric renaming rules as provided by the
        # collector on connect.  The former are applied during txns,
        # the latter during harvest.
        attr_accessor transaction_rules: untyped

        # Responsbile for restarting the harvest thread
        attr_reader harvester: untyped

        # GC::Profiler.total_time is not monotonic so we wrap it.
        attr_reader monotonic_gc_profiler: untyped

        attr_reader custom_event_aggregator: untyped

        attr_reader span_event_aggregator: untyped

        attr_reader log_event_aggregator: untyped

        attr_reader transaction_event_recorder: untyped

        attr_reader attribute_filter: untyped

        attr_reader adaptive_sampler: untyped

        attr_reader environment_report: untyped

        def transaction_event_aggregator: () -> untyped

        def synthetics_event_aggregator: () -> untyped

        def agent_id=: (untyped agent_id) -> untyped

        # This method should be called in a forked process after a fork.
        # It assumes the parent process initialized the agent, but does
        # not assume the agent started.
        #
        # The call is idempotent, but not re-entrant.
        #
        # * It clears any metrics carried over from the parent process
        # * Restarts the sampler thread if necessary
        # * Initiates a new agent run and worker loop unless that was done
        #   in the parent process and +:force_reconnect+ is not true
        #
        # Options:
        # * <tt>:force_reconnect => true</tt> to force the spawned process to
        #   establish a new connection, such as when forking a long running process.
        #   The default is false--it will only connect to the server if the parent
        #   had not connected.
        # * <tt>:keep_retrying => false</tt> if we try to initiate a new
        #   connection, this tells me to only try it once so this method returns
        #   quickly if there is some kind of latency with the server.
        def after_fork: (?::Hash[untyped, untyped] options) -> (nil | untyped)

        def install_pipe_service: (untyped channel_id) -> untyped

        # True if we have initialized and completed 'start'
        def started?: () -> untyped

        # Attempt a graceful shutdown of the agent, flushing any remaining
        # data.
        def shutdown: () -> (nil | untyped)

        def revert_to_default_configuration: () -> untyped

        # If the @worker_thread encounters an error during the attempt to connect to the collector
        # then the connect attempts enter an exponential backoff retry loop.  To avoid potential
        # race conditions with shutting down while also attempting to reconnect, we join the
        # @worker_thread with a timeout threshold.  This allows potentially connecting and flushing
        # pending data to the server, but without waiting indefinitely for a reconnect to succeed.
        # The use-case where this typically arises is in cronjob scheduled rake tasks where there's
        # also some network stability/latency issues happening.
        def stop_event_loop: () -> untyped

        def trap_signals_for_litespeed: () -> untyped

        def untraced_graceful_disconnect: () -> untyped

        def set_record_sql: (untyped should_record) -> untyped

        def push_trace_execution_flag: (?bool should_trace) -> untyped

        def pop_trace_execution_flag: () -> untyped

        # Herein lies the corpse of the former 'start' method. May
        # its unmatched flog score rest in pieces.
        module Start
          # Check whether we have already started, which is an error condition
          def already_started?: () -> untyped

          # The agent is disabled when it is not force enabled by the
          # 'agent_enabled' option (e.g. in a manual start), or
          # enabled normally through the configuration file
          def disabled?: () -> untyped

          # Log startup information that we almost always want to know
          def log_startup: () -> untyped

          # Log the environment the app thinks it's running in.
          # Useful in debugging, as this is the key for config YAML lookups.
          def log_environment: () -> untyped

          # Logs the dispatcher to the log file to assist with
          # debugging. When no debugger is present, logs this fact to
          # assist with proper dispatcher detection
          def log_dispatcher: () -> untyped

          def log_app_name: () -> untyped

          def log_ignore_url_regexes: () -> untyped

          # Logs the configured application names
          def app_name_configured?: () -> untyped

          # Connecting in the foreground blocks further startup of the
          # agent until we have a connection - useful in cases where
          # you're trying to log a very-short-running process and want
          # to get statistics from before a server connection
          # (typically 20 seconds) exists
          def connect_in_foreground: () -> untyped

          # This matters when the following three criteria are met:
          #
          # 1. A Sinatra 'classic' application is being run
          # 2. The app is being run by executing the main file directly, rather
          #    than via a config.ru file.
          # 3. newrelic_rpm is required *after* sinatra
          #
          # In this case, the entire application runs from an at_exit handler in
          # Sinatra, and if we were to install ours, it would be executed before
          # the one in Sinatra, meaning that we'd shutdown the agent too early
          # and never collect any data.
          def sinatra_classic_app?: () -> untyped

          def should_install_exit_handler?: () -> (false | untyped)

          def install_exit_handler: () -> (nil | untyped)

          # Classy logging of the agent version and the current pid,
          # so we can disambiguate processes in the log file and make
          # sure they're running a reasonable version
          def log_version_and_pid: () -> untyped

          # Warn the user if they have configured their agent not to
          # send data, that way we can see this clearly in the log file
          def monitoring?: () -> untyped

          # Tell the user when the license key is missing so they can
          # fix it by adding it to the file
          def has_license_key?: () -> untyped

          # A correct license key exists and is of the proper length
          def has_correct_license_key?: () -> untyped

          # A license key is an arbitrary 40 character string,
          # usually looks something like a SHA1 hash
          def correct_license_length: () -> untyped

          # If we're using a dispatcher that forks before serving
          # requests, we need to wait until the children are forked
          # before connecting, otherwise the parent process sends useless data
          def using_forking_dispatcher?: () -> untyped

          # Return true if we're using resque and it hasn't had a chance to (potentially)
          # daemonize itself. This avoids hanging when there's a Thread started
          # before Resque calls Process.daemon (Jira RUBY-857)
          def defer_for_resque?: () -> untyped

          def in_resque_child_process?: () -> untyped

          # Sanity-check the agent configuration and start the agent,
          # setting up the worker thread and the exit handler to shut
          # down the agent
          def check_config_and_start_agent: () -> (nil | untyped)

          # This is the shared method between the main agent startup and the
          # after_fork call restarting the thread in deferred dispatchers.
          #
          # Treatment of @started and env report is important to get right.
          def setup_and_start_agent: (?::Hash[untyped, untyped] options) -> untyped
        end

        include Start

        def defer_for_delayed_job?: () -> untyped

        # Check to see if the agent should start, returning +true+ if it should.
        def agent_should_start?: () -> (false | true)

        # Logs a bunch of data and starts the agent, if needed
        def start: () -> (nil | untyped)

        # Clear out the metric data, errors, and transaction traces, etc.
        def drop_buffered_data: () -> untyped

        # Clear out state for any objects that we know lock from our parents
        # This is necessary for cases where we're in a forked child and Ruby
        # might be holding locks for background thread that aren't there anymore.
        def reset_objects_with_locks: () -> untyped

        def flush_pipe_data: () -> untyped

        private

        # All of this module used to be contained in the
        # start_worker_thread method - this is an artifact of
        # refactoring and can be moved, renamed, etc at will
        module StartWorkerThread
          def create_event_loop: () -> untyped

          LOG_ONCE_KEYS_RESET_PERIOD: ::Float

          # Certain event types may sometimes need to be on the same interval as metrics,
          # so we will check config assigned in EventHarvestConfig to determine the interval
          # on which to report them
          def interval_for: (untyped event_type) -> ::Symbol

          ANALYTIC_EVENT_DATA: "analytic_event_data"

          CUSTOM_EVENT_DATA: "custom_event_data"

          ERROR_EVENT_DATA: "error_event_data"

          SPAN_EVENT_DATA: "span_event_data"

          LOG_EVENT_DATA: "log_event_data"

          def create_and_run_event_loop: () -> untyped

          # Handles the case where the server tells us to restart -
          # this clears the data, clears connection attempts, and
          # waits a while to reconnect.
          def handle_force_restart: (untyped error) -> untyped

          # when a disconnect is requested, stop the current thread, which
          # is the worker thread that gathers data and talks to the
          # server.
          def handle_force_disconnect: (untyped error) -> untyped

          # Handles an unknown error in the worker thread by logging
          # it and disconnecting the agent, since we are now in an
          # unknown state.
          def handle_other_error: (untyped error) -> untyped

          # a wrapper method to handle all the errors that can happen
          # in the connection and worker thread system. This
          # guarantees a no-throw from the background thread.
          def catch_errors: () { () -> untyped } -> untyped

          # This is the method that is run in a new thread in order to
          # background the harvesting and sending of data during the
          # normal operation of the agent.
          #
          # Takes connection options that determine how we should
          # connect to the server, and loops endlessly - typically we
          # never return from this method unless we're shutting down
          # the agent
          def deferred_work!: (untyped connection_options) -> untyped
        end

        include StartWorkerThread

        # Try to launch the worker thread and connect to the server.
        #
        # See #connect for a description of connection_options.
        def start_worker_thread: (?::Hash[untyped, untyped] connection_options) -> (nil | untyped)

        # A shorthand for NewRelic::Control.instance
        def control: () -> untyped

        # This module is an artifact of a refactoring of the connect
        # method - all of its methods are used in that context, so it
        # can be refactored at will. It should be fully tested
        module Connect
          # number of attempts we've made to contact the server
          attr_accessor connect_attempts: untyped

          # Disconnect just sets the connect state to disconnected, preventing
          # further retries.
          def disconnect: () -> true

          def connected?: () -> untyped

          def disconnected?: () -> untyped

          # Don't connect if we're already connected, or if we tried to connect
          # and were rejected with prejudice because of a license issue, unless
          # we're forced to by force_reconnect.
          def should_connect?: (?bool force) -> untyped

          # Per the spec at
          # /agents/agent-specs/Collector-Response-Handling.md, retry
          # connections after a specific backoff sequence to prevent
          # hammering the server.
          def connect_retry_period: () -> untyped

          def note_connect_failure: () -> untyped

          # When we have a problem connecting to the server, we need
          # to tell the user what happened, since this is not an error
          # we can handle gracefully.
          def log_error: (untyped error) -> untyped

          # When the server sends us an error with the license key, we
          # want to tell the user that something went wrong, and let
          # them know where to go to get a valid license key
          #
          # After this runs, it disconnects the agent so that it will
          # no longer try to connect to the server, saving the
          # application and the server load
          def handle_license_error: (untyped error) -> untyped

          def handle_unrecoverable_agent_error: (untyped error) -> untyped

          # Checks whether we should send environment info, and if so,
          # returns the snapshot from the local environment.
          # Generating the EnvironmentReport has the potential to trigger
          # require calls in Rails environments, so this method should only
          # be called synchronously from on the main thread.
          def environment_for_connect: () -> untyped

          # Constructs and memoizes an event_harvest_config hash to be used in
          # the payload sent during connect (and reconnect)
          def event_harvest_config: () -> untyped

          # Builds the payload to send to the connect service,
          # connects, then configures the agent using the response from
          # the connect service
          def connect_to_server: () -> untyped

          # Logs when we connect to the server, for debugging purposes
          # - makes sure we know if an agent has not connected
          def log_connection: (untyped config_data) -> untyped

          def log_collector_messages: (untyped messages) -> untyped

          # apdex_f is always 4 times the apdex_t
          def apdex_f: () -> untyped

          class WaitOnConnectTimeout < StandardError
          end

          # Used for testing to let us know we've actually started to wait
          def waited_on_connect?: () -> untyped

          def signal_connected: () -> untyped

          def wait_on_connect: (untyped timeout) -> (nil | untyped)
        end

        include Connect

        def container_for_endpoint: (untyped endpoint) -> untyped

        public

        def merge_data_for_endpoint: (untyped endpoint, untyped data) -> untyped

        private

        # Establish a connection to New Relic servers.
        #
        # By default, if a connection has already been established, this method
        # will be a no-op.
        #
        # @param [Hash] options
        # @option options [Boolean] :keep_retrying (true)
        #   If true, this method will block until a connection is successfully
        #   established, continuing to retry upon failure. If false, this method
        #   will return after either successfully connecting, or after failing
        #   once.
        #
        # @option options [Boolean] :force_reconnect (false)
        #   If true, this method will force establishment of a new connection
        #   with New Relic, even if there is already an existing connection.
        #   This is useful primarily when re-establishing a new connection after
        #   forking off from a parent process.
        #
        def connect: (?::Hash[untyped, untyped] options) -> untyped

        # Delegates to the control class to determine the root
        # directory of this project
        def determine_home_directory: () -> untyped

        # Harvests data from the given container, sends it to the named endpoint
        # on the service, and automatically merges back in upon a recoverable
        # failure.
        #
        # The given container should respond to:
        #
        #  #harvest!
        #    returns a payload that contains enumerable collection of data items and
        #    optional metadata to be sent to the collector.
        #
        #  #reset!
        #    drop any stored data and reset to a clean state.
        #
        #  #merge!(payload)
        #    merge the given payload back into the internal buffer of the
        #    container, so that it may be harvested again later.
        #
        def harvest_and_send_from_container: (untyped container, untyped endpoint) -> untyped

        def harvest_size: (untyped container, untyped items) -> untyped

        def harvest_from_container: (untyped container, untyped endpoint) -> untyped

        def send_data_to_endpoint: (untyped endpoint, untyped payload, untyped container) -> untyped

        def harvest_and_send_timeslice_data: () -> untyped

        def harvest_and_send_slowest_sql: () -> untyped

        # This handles getting the transaction traces and then sending
        # them across the wire.  This includes gathering SQL
        # explanations, stripping out stack traces, and normalizing
        # SQL.  note that we explain only the sql statements whose
        # nodes' execution times exceed our threshold (to avoid
        # unnecessary overhead of running explains on fast queries.)
        def harvest_and_send_transaction_traces: () -> untyped

        def harvest_and_send_for_agent_commands: () -> untyped

        def harvest_and_send_errors: () -> untyped

        def harvest_and_send_analytic_event_data: () -> untyped

        def harvest_and_send_custom_event_data: () -> untyped

        def harvest_and_send_error_event_data: () -> untyped

        def harvest_and_send_span_event_data: () -> untyped

        def harvest_and_send_log_event_data: () -> untyped

        def check_for_and_handle_agent_commands: () -> untyped

        def log_remote_unavailable: (untyped endpoint, untyped e) -> untyped

        TRANSACTION_EVENT: "TransactionEvent"

        def transmit_analytic_event_data: () -> untyped

        CUSTOM_EVENT: "CustomEvent"

        def transmit_custom_event_data: () -> untyped

        ERROR_EVENT: "ErrorEvent"

        def transmit_error_event_data: () -> untyped

        SPAN_EVENT: "SpanEvent"

        def transmit_span_event_data: () -> untyped

        LOG_EVENT: "LogEvent"

        def transmit_log_event_data: () -> untyped

        def transmit_single_data_type: (untyped harvest_method, untyped supportability_name) -> untyped

        def transmit_data: () -> untyped

        # This method contacts the server to send remaining data and
        # let the server know that the agent is shutting down - this
        # allows us to do things like accurately set the end of the
        # lifetime of the process
        #
        # If this process comes from a parent process, it will not
        # disconnect, so that the parent process can continue to send data
        def graceful_disconnect: () -> untyped
      end

      extend ClassMethods

      include InstanceMethods
    end
  end
end

module NewRelic::Agent
  # Basic mechanism for the agent instance to provide agent-wide eventing.
  # It is intended to keep different pieces of the app decoupled from each other.
  #
  # While an EventListener could be used elsewhere, it's strongly expected
  # your eventing needs should be met by the agent's instance.
  class EventListener
    attr_accessor runaway_threshold: untyped

    def initialize: () -> void

    def subscribe: (untyped event) { () -> untyped } -> untyped

    def check_for_runaway_subscriptions: (untyped event) -> untyped

    def clear: () -> untyped

    def notify: (untyped event, *untyped args) -> (nil | untyped)
  end
end

# This module powers the Busy calculation for the Capacity report in
# APM (https://rpm.newrelic.com/accounts/.../applications/.../optimize/capacity_analysis).
#
#               total time spent in transactions this harvest across all threads
# Busy time = ------------------------------------------------------------------------
#             (elapsed time for this harvest cycle) * (# threads that had transactions)
#
module NewRelic
  module Agent
    module TransactionTimeAggregator
      TransactionStats: untyped

      def self?.reset!: (?untyped timestamp) -> untyped

      def self?.transaction_start: (?untyped timestamp) -> untyped

      def self?.transaction_stop: (?untyped timestamp, ?untyped starting_thread_id) -> untyped

      INSTANCE_BUSY_METRIC: "Instance/Busy"

      def self?.harvest!: (?untyped timestamp) -> untyped

      private

      def self.record_elapsed_transaction_time_until: (untyped timestamp, ?untyped thread_id) -> untyped

      def self.in_transaction?: (?untyped thread_id) -> untyped

      def self.current_thread: () -> untyped

      def self.thread_is_alive?: (untyped thread_id) -> untyped

      def self.thread_by_id: (untyped thread_id) -> untyped

      def self.set_transaction_start_time: (untyped timestamp, ?untyped thread_id) -> untyped

      def self.split_transaction_at_harvest: (untyped timestamp, ?untyped? thread_id) -> untyped

      def self.transaction_time_in_thread: (untyped timestamp, untyped thread_id, untyped entry) -> untyped

      def self.log_missing_elapsed_transaction_time: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    # -
    # Manages the registering and servicing of pipes used by child
    # processes to report data to their parent, rather than directly
    # to the collector.
    module PipeChannelManager
      extend ::NewRelic::Agent::PipeChannelManager

      def register_report_channel: (untyped id) -> untyped

      def channels: () -> untyped

      def listener: () -> untyped

      # Expected initial sequence of events for Pipe usage:
      #
      # 1. Pipe is created in parent process (read and write ends open)
      # 2. Parent process forks
      # 3. An after_fork hook is invoked in the child
      # 4. From after_fork hook, child closes read end of pipe, and
      #    writes a ready marker on the pipe (after_fork_in_child).
      # 5. The parent receives the ready marker, and closes the write end of the
      #    pipe in response (after_fork_in_parent).
      #
      # After this sequence of steps, an exit (whether clean or not) of the
      # child will result in the pipe being marked readable again, and giving an
      # EOF marker (nil) when read. Note that closing of the unused ends of the
      # pipe in the parent and child processes is essential in order for the EOF
      # to be correctly triggered. The ready marker mechanism is used because
      # there's no easy hook for after_fork in the parent process.
      #
      # This class provides message framing (separation of individual messages),
      # but not serialization. Serialization / deserialization is the
      # responsibility of clients.
      #
      # Message framing works like this:
      #
      # Each message sent across the pipe is preceded by a length tag that
      # specifies the length of the message that immediately follows, in bytes.
      # The length tags are serialized as unsigned big-endian long values, (4
      # bytes each). This means that the maximum theoretical message size is
      # 4 GB - much larger than we'd ever need or want for this application.
      #
      class Pipe
        READY_MARKER: "READY"

        NUM_LENGTH_BYTES: 4

        attr_accessor in: untyped

        attr_accessor out: untyped

        attr_reader last_read: untyped

        attr_reader parent_pid: untyped

        def initialize: () -> void

        def close: () -> untyped

        def serialize_message_length: (untyped data) -> untyped

        def deserialize_message_length: (untyped data) -> untyped

        def write: (untyped data) -> untyped

        def read: () -> untyped

        def eof?: () -> untyped

        def after_fork_in_child: () -> untyped

        def after_fork_in_parent: () -> untyped

        def closed?: () -> untyped
      end

      class Listener
        attr_reader thread: untyped

        # This attr_accessor intentionally provides unsynchronized access to the
        # @pipes hash. It is used to look up the write end of the pipe from
        # within the Resque child process, and must be unsynchronized in order
        # to avoid a potential deadlock in which the PipeChannelManager::Listener
        # thread in the parent process is holding the @pipes_lock at the time of
        # the fork.
        attr_accessor pipes: untyped

        # This attr_accessor intentionally provides unsynchronized access to the
        # @pipes hash. It is used to look up the write end of the pipe from
        # within the Resque child process, and must be unsynchronized in order
        # to avoid a potential deadlock in which the PipeChannelManager::Listener
        # thread in the parent process is holding the @pipes_lock at the time of
        # the fork.
        attr_accessor timeout: untyped

        # This attr_accessor intentionally provides unsynchronized access to the
        # @pipes hash. It is used to look up the write end of the pipe from
        # within the Resque child process, and must be unsynchronized in order
        # to avoid a potential deadlock in which the PipeChannelManager::Listener
        # thread in the parent process is holding the @pipes_lock at the time of
        # the fork.
        attr_accessor select_timeout: untyped

        def initialize: () -> void

        def wakeup: () -> untyped

        def register_pipe: (untyped id) -> untyped

        def start: () -> (nil | untyped)

        def stop_listener_thread: () -> untyped

        def stop: () -> (nil | untyped)

        def close_all_pipes: () -> untyped

        def wake: () -> untyped

        def started?: () -> untyped

        def merge_data_from_pipe: (untyped pipe_handle) -> untyped

        def unmarshal: (untyped data) -> untyped

        def should_keep_listening?: () -> untyped

        def clean_up_pipes: () -> untyped

        def find_pipe_for_handle: (untyped out_handle) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    # Handles loading of ignored and expected errors from the agent configuration, and
    # determining at runtime whether an exception is ignored or expected.
    class ErrorFilter
      def initialize: () -> void

      def reset: () -> untyped

      def load_all: () -> untyped

      def load_from_config: (untyped setting, ?untyped? value) -> (nil | untyped)

      def ignore?: (untyped ex, ?untyped? status_code) -> untyped

      def expected?: (untyped ex, ?untyped? status_code) -> untyped

      def fetch_agent_config: (untyped cfg) -> untyped

      # A generic method for adding ignore filters manually. This is kept for compatibility
      # with the previous ErrorCollector#ignore method, and adds some flexibility for adding
      # different ignore/expected error types by examining each argument.
      def ignore: (*untyped args) -> untyped

      # See #ignore above.
      def expect: (*untyped args) -> untyped

      private

      def log_filter: (untyped setting, untyped errors) -> untyped

      def parse_status_codes: (untyped codes) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class UtilizationData
      METADATA_VERSION: 5

      VENDORS: ::Hash[untyped, :"utilization.detect_aws" | :"utilization.detect_gcp" | :"utilization.detect_azure" | :"utilization.detect_pcf"]

      def hostname: () -> untyped

      def fqdn: () -> untyped

      def ip_addresses: () -> untyped

      def container_id: () -> untyped

      def cpu_count: () -> untyped

      def ram_in_mib: () -> untyped

      def configured_hostname: () -> untyped

      # this is slightly ugly, but if a string value is passed in
      # for the env var: NEW_RELIC_UTILIZATION_LOGICAL_PROCESSORS the
      # coercion from EnvironmentSource will turn that into a numerical 0,
      # which is not a reasonable value for logical_processes and should
      # not be sent up
      def configured_logical_processors: () -> untyped

      # see comment above as the situation is the same for:
      # NEW_RELIC_UTILIZATION_TOTAL_RAM_MIB
      def configured_total_ram_mib: () -> untyped

      def to_collector_hash: () -> untyped

      def append_vendor_info: (untyped collector_hash) -> untyped

      def append_docker_info: (untyped collector_hash) -> (nil | untyped)

      def append_configured_values: (untyped collector_hash) -> untyped

      def append_boot_id: (untyped collector_hash) -> untyped

      def append_ip_address: (untyped collector_hash) -> untyped

      KUBERNETES_SERVICE_HOST: "KUBERNETES_SERVICE_HOST"

      def append_kubernetes_info: (untyped collector_hash) -> (nil | untyped)

      def append_full_hostname: (untyped collector_hash) -> (nil | untyped)

      def config_hash: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    # This is responsibile for recording transaction events and managing
    # the relationship between events generated from synthetics requests
    # vs normal requests.
    class TransactionEventRecorder
      attr_reader transaction_event_aggregator: untyped

      attr_reader synthetics_event_aggregator: untyped

      def initialize: (untyped events) -> void

      def record: (untyped payload) -> (nil | untyped)

      def create_event: (untyped payload) -> untyped

      def synthetics_event?: (untyped payload) -> untyped

      def drop_buffered_data: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class EventLoop
      class Timer
        attr_reader next_fire_time: untyped

        attr_reader event: untyped

        attr_reader interval: untyped

        attr_reader last_fired_at: untyped

        def initialize: (untyped interval, untyped event, ?bool repeat) -> void

        def reschedule: () -> untyped

        def advance: (untyped amount) -> untyped

        def last_interval_start: () -> untyped

        def calculate_next_fire_time: () -> untyped

        def set_fired_time: () -> untyped

        def due?: (?untyped now) -> untyped

        def finished?: () -> untyped
      end

      def initialize: () -> void

      def set_timer: (untyped timer) -> untyped

      def next_timeout: () -> (nil | untyped)

      def stopped?: () -> untyped

      def stop: () -> untyped

      def run: () -> untyped

      def run_once: (?bool nonblock) -> untyped

      def wait_to_run: (untyped nonblock) -> untyped

      def fire_timers: () -> untyped

      def fire_timer: (untyped timer) -> untyped

      def prune_timers: () -> untyped

      def dispatch_event: (untyped event, untyped args) -> untyped

      def reschedule_timer_for_event: (untyped e) -> untyped

      def on: (untyped event) { () -> untyped } -> untyped

      def fire: (untyped event, *untyped args) -> untyped

      def fire_every: (untyped interval, untyped event) -> untyped

      def fire_after: (untyped interval, untyped event) -> untyped

      def wakeup: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class Obfuscator
      attr_reader key_bytes: untyped

      EMPTY_KEY_BYTES: ::Array[0]

      PACK_FORMAT: "m"

      # RUM uses a shortened key, so just trim it up front
      def initialize: (untyped key, ?untyped? length) -> void

      def obfuscate: (untyped text) -> untyped

      def deobfuscate: (untyped text) -> untyped

      def encode: (untyped text) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module LogOnce
      NUM_LOG_ONCE_KEYS: 1000

      def log_once: (untyped level, untyped key, *untyped msgs) -> (nil | untyped)

      def clear_already_logged: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class AuditLogger
      def initialize: () -> void

      attr_writer enabled: untyped

      def enabled?: () -> untyped

      def setup?: () -> untyped

      def log_request_headers: (untyped uri, untyped headers) -> untyped

      def log_request: (untyped uri, untyped data, untyped marshaller) -> untyped

      def allowed_endpoint?: (untyped uri) -> untyped

      def setup_logger: () -> untyped

      def ensure_log_path: () -> untyped

      def wants_stdout?: () -> untyped

      def create_log_formatter: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      class NetHTTPResponse < AbstractResponse
        def []: (untyped key) -> untyped

        def to_hash: () -> untyped
      end

      class NetHTTPRequest < AbstractRequest
        def initialize: (untyped connection, untyped request) -> void

        NET_HTTP: "Net::HTTP"

        def type: () -> untyped

        HOST: "host"

        COLON: ":"

        def host_from_header: () -> untyped

        def host: () -> untyped

        def method: () -> untyped

        def []: (untyped key) -> untyped

        def []=: (untyped key, untyped value) -> untyped

        def uri: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      class HTTPClientResponse < AbstractResponse
        def []: (untyped key) -> (untyped | nil)

        def to_hash: () -> untyped
      end

      class HTTPClientRequest < AbstractRequest
        attr_reader request: untyped

        HTTP_CLIENT: "HTTPClient"

        LHOST: "host"

        UHOST: "Host"

        COLON: ":"

        def initialize: (untyped request) -> void

        def type: () -> untyped

        def method: () -> untyped

        def host_from_header: () -> untyped

        def host: () -> untyped

        def uri: () -> untyped

        def []: (untyped key) -> untyped

        def []=: (untyped key, untyped value) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      class CurbRequest
        CURB: "Curb"

        LHOST: "host"

        UHOST: "Host"

        def initialize: (untyped curlobj) -> void

        def type: () -> untyped

        def host_from_header: () -> untyped

        def host: () -> untyped

        def method: () -> untyped

        def []: (untyped key) -> untyped

        def []=: (untyped key, untyped value) -> untyped

        def uri: () -> untyped
      end

      class CurbResponse < AbstractResponse
        def initialize: (untyped wrapped_response) -> void

        def []: (untyped key) -> untyped

        def to_hash: () -> untyped

        def append_header_data: (untyped data) -> untyped

        private

        def get_status_code: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      class TyphoeusHTTPResponse < AbstractResponse
        def []: (untyped key) -> untyped

        def to_hash: () -> untyped

        private

        def headers: () -> untyped
      end

      class TyphoeusHTTPRequest < AbstractRequest
        def initialize: (untyped request) -> void

        TYPHOEUS: "Typhoeus"

        def type: () -> untyped

        LHOST: "host"

        UHOST: "Host"

        def host_from_header: () -> untyped

        def host: () -> untyped

        GET: "GET"

        def method: () -> untyped

        def []: (untyped key) -> (nil | untyped)

        def []=: (untyped key, untyped value) -> untyped

        def uri: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      class ExconHTTPResponse < AbstractResponse
        def initialize: (untyped wrapped_response) -> void

        def []: (untyped key) -> untyped

        def to_hash: () -> untyped

        private

        def get_attribute: (untyped name) -> untyped

        def get_status_code: () -> untyped
      end

      class ExconHTTPRequest < AbstractRequest
        attr_reader method: untyped

        EXCON: "Excon"

        LHOST: "host"

        UHOST: "Host"

        COLON: ":"

        def initialize: (untyped datum) -> void

        def type: () -> untyped

        def host_from_header: () -> untyped

        def host: () -> untyped

        def []: (untyped key) -> untyped

        def []=: (untyped key, untyped value) -> untyped

        def uri: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      class HTTPResponse < AbstractResponse
        def []: (untyped key) -> untyped

        def to_hash: () -> untyped
      end

      class HTTPRequest < AbstractRequest
        HTTP_RB: "http.rb"

        HOST: "host"

        COLON: ":"

        def initialize: (untyped wrapped_request) -> void

        def uri: () -> untyped

        def type: () -> untyped

        def host_from_header: () -> untyped

        def host: () -> untyped

        def method: () -> untyped

        def []: (untyped key) -> untyped

        def []=: (untyped key, untyped value) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      MUST_IMPLEMENT_ERROR: "Subclasses of %s must implement a :%s method"

      WHINY_NIL_ERROR: "%s cannot initialize with a nil wrapped_response object."

      # This class provides a public interface for wrapping HTTP requests. This
      # may be used to create wrappers that are compatible with New Relic's
      # external request API.
      #
      # @api public
      class AbstractRequest
        def []: () -> untyped

        def []=: () -> untyped

        def type: () -> untyped

        def host_from_header: () -> untyped

        def host: () -> untyped

        def method: () -> untyped
      end

      class AbstractResponse
        # This class implements the adaptor pattern and is used internally provide
        # uniform access to the underlying HTTP Client's response object
        # NOTE: response_object should be non-nil!
        # :nodoc:
        def initialize: (untyped wrapped_response) -> void

        def has_status_code?: () -> untyped

        # most HTTP client libraries report the HTTP status code as an integer, so
        # we expect status_code to be set only if a non-zero value is present
        def status_code: () -> untyped

        private

        def get_status_code_using: (untyped method_name) -> (nil | untyped)

        # Override this method to memoize a non-zero Integer representation
        # of HTTP status code from the response object
        def get_status_code: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module HTTPClients
      module URIUtil
        def self.obfuscated_uri: (untyped url) -> untyped

        # There are valid URI strings that some HTTP client libraries will
        # accept that the stdlib URI module doesn't handle. If we find that
        # Addressable is around, use that to normalize out our URL's.
        def self.parse_and_normalize_url: (untyped url) -> untyped

        QUESTION_MARK: "?"

        def self.strip_query_string: (untyped fragment) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module PrependSupportability
      def self.record_metrics_for: (*untyped classes) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module EncodingNormalizer
      def self.normalize_string: (untyped raw_string) -> untyped

      def self.normalize_object: (untyped object) -> untyped

      module EncodingNormalizer
        def self.normalize: (untyped raw_string) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module ParameterFiltering
      extend ::NewRelic::Agent::ParameterFiltering

      ACTION_DISPATCH_PARAMETER_FILTER: "action_dispatch.parameter_filter"

      RAILS_FILTER_CLASS: untyped

      def apply_filters: (untyped env, untyped params) -> untyped

      def filter_using_rails: (untyped params, untyped filters) -> untyped

      def filter_rack_file_data: (untyped env, untyped params) -> untyped

      def filter_rails_request_parameters: (untyped params) -> untyped
    end
  end
end

module NewRelic
  module Agent
    # A singleton responsible for determining if the agent should start
    # monitoring.
    #
    # If the agent is in a monitored environment (e.g. production) it will
    # attempt to avoid starting at "inappropriate" times, for example in an IRB
    # session.  On Heroku, logs typically go to STDOUT so agent logs can spam
    # the console during interactive sessions.
    #
    # It should be possible to override Autostart logic with an explicit
    # configuration, for example the NEW_RELIC_AGENT_ENABLED environment variable or
    # agent_enabled key in newrelic.yml
    module Autostart
      extend ::NewRelic::Agent::Autostart

      # The constants, executables (i.e. $0) and rake tasks used can be
      # configured with the config keys 'autostart.denylisted_constants',
      # 'autostart.denylisted_executables' and
      # 'autostart.denylisted_rake_tasks'
      def agent_should_start?: () -> untyped

      COMMA: ","

      def denylisted_constants?: () -> untyped

      def denylisted_executables?: () -> untyped

      # Lookup whether namespaced constants (e.g. ::Foo::Bar::Baz) are in the
      # environment.
      def constant_is_defined?: (untyped const_name) -> untyped

      def denylisted?: (untyped value) { () -> untyped } -> untyped

      def in_denylisted_rake_task?: () -> untyped
    end
  end
end

# Listen for ActiveSupport::Notifications events for ActionView render
# events.  Write metric data and transaction trace nodes for each event.
module NewRelic
  module Agent
    module Instrumentation
      class ActionViewSubscriber < NotificationsSubscriber
        def start: (untyped name, untyped id, untyped payload) -> untyped

        def finish: (untyped name, untyped id, untyped payload) -> untyped

        def format_metric_name: (untyped event_name, untyped payload, untyped parent) -> (untyped | ::String)

        # Nearly every "render_blah.action_view" event has a child
        # in the form of "!render_blah.action_view".  The children
        # are the ones we want to record.  There are a couple
        # special cases of events without children.
        def recordable?: (untyped event_name, untyped metric_name) -> untyped

        RENDER_TEMPLATE_EVENT_NAME: "render_template.action_view"

        RENDER_PARTIAL_EVENT_NAME: "render_partial.action_view"

        RENDER_COLLECTION_EVENT_NAME: "render_collection.action_view"

        def metric_action: (untyped name) -> untyped

        def metric_path: (untyped name, untyped identifier) -> untyped
      end

      # This class holds state information between calls to `start`
      # and `finish` for ActiveSupport events that we do not want to track
      # as a transaction or segment.
      class ActionViewEvent
        attr_reader name: untyped

        attr_reader identifier: untyped

        attr_accessor finishable: untyped

        def initialize: (untyped name, untyped identifier) -> void

        def finish: () -> untyped

        def notice_error: (untyped error) -> untyped
      end
    end
  end
end


class Object
  public
end

module NewRelic::Agent::Instrumentation
  module HTTPClient
    module Prepend
      include NewRelic::Agent::Instrumentation::HTTPClient::Instrumentation

      def do_get_block: (untyped req, untyped proxy, untyped conn) { () -> untyped } -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module HTTPClient
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module HTTPClient
    module Instrumentation
      def with_tracing: (untyped request, untyped connection) { () -> untyped } -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module DelayedJob
        module Naming
          CLASS_METHOD_DELIMITER: "."

          INSTANCE_METHOD_DELIMITER: "#"

          LEGACY_DJ_FORMAT_DELIMITER: ";"

          LEGACY_DJ_FORMAT_PREFIX: "LOAD"

          LEGACY_DJ_DEFAULT_CLASS: "(unknown class)"

          def self?.name_from_payload: (untyped payload_object) -> untyped

          # Older versions of Delayed Job use a semicolon-delimited string to stash the class name.
          # The format of this string is "LOAD;<class name>;<ORM ID>"
          def self?.legacy_performable_method?: (untyped payload_object) -> untyped

          # If parsing for the class name fails, return a sensible default
          def self?.class_name_from_legacy_performable_method: (untyped payload_object) -> untyped

          def self?.object_name: (untyped payload_object) -> untyped

          def self?.delimiter: (untyped payload_object) -> untyped

          # DelayedJob's interface for the async method's name varies across the gem's versions
          def self?.method_name: (untyped payload_object) -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      class MongodbCommandSubscriber
        MONGODB: "MongoDB"

        COLLECTION: "collection"

        def started: (untyped event) -> untyped

        ERROR_KEYS: ::Array["writeErrors" | "writeConcernError" | "writeConcernErrors"]

        def error_key_present?: (untyped event) -> untyped

        def completed: (untyped event) -> untyped

        alias succeeded completed

        alias failed completed

        private

        def start_segment: (untyped event) -> untyped

        def operation: (untyped command_name) -> untyped

        def collection: (untyped event) -> untyped

        def log_notification_error: (untyped event_type, untyped error) -> untyped

        def segments: () -> untyped

        def generate_statement: (untyped event) -> untyped

        UNKNOWN: "unknown"

        LOCALHOST: "localhost"

        def host_from_address: (untyped address) -> untyped

        def port_path_or_id_from_address: (untyped address) -> untyped

        SLASH: "/"

        def unix_domain_socket?: (untyped host) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      class ActionControllerSubscriber < NotificationsSubscriber
        def start: (untyped name, untyped id, untyped payload) -> untyped

        def finish: (untyped name, untyped id, untyped payload) -> untyped

        def start_transaction_or_segment: (untyped payload, untyped request, untyped controller_class) -> untyped

        def format_metric_name: (untyped metric_action, untyped controller_name) -> ::String

        def controller_class: (untyped payload) -> untyped

        def should_ignore: (untyped payload, untyped controller_class) -> untyped

        def queue_start: (untyped request) -> untyped
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Sinatra
    module Prepend
      include ::NewRelic::Agent::Instrumentation::Sinatra::Tracer

      def dispatch!: () -> untyped

      def process_route: (*untyped args) { () -> untyped } -> untyped

      def route_eval: (*untyped args) { () -> untyped } -> untyped
    end

    module Build
      module Prepend
        include ::NewRelic::Agent::Instrumentation::Sinatra::Tracer

        def build: (*untyped args) { () -> untyped } -> untyped
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Sinatra
    module Ignorer
      def self.should_ignore?: (untyped app, untyped `type`) -> (false | untyped)

      def newrelic_ignore: (*untyped routes) -> untyped

      def newrelic_ignore_apdex: (*untyped routes) -> untyped

      def newrelic_ignore_enduser: (*untyped routes) -> untyped

      private

      def set_newrelic_ignore: (untyped `type`, *untyped routes) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Sinatra
    module Chain
      def self.instrument!: () -> untyped
    end

    module Build
      module Chain
        def self.instrument!: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Sinatra
        module TransactionNamer
          extend ::NewRelic::Agent::Instrumentation::Sinatra::TransactionNamer

          SINATRA_ROUTE: "sinatra.route"

          def transaction_name_for_route: (untyped env, untyped request) -> untyped

          def initial_transaction_name: (untyped request) -> untyped

          ROOT: "/"

          def transaction_name: (untyped route_text, untyped request) -> untyped

          def http_verb: (untyped request) -> untyped

          # For bare Sinatra, our override on process_route captures the last
          # route into the environment for us to use later on
          def route_for_sinatra: (untyped env) -> untyped

          # For Padrino, the request object has a copy of the matched route
          # on it when we go to evaluating, so we can just retrieve that
          def route_name_for_padrino: (untyped request) -> untyped
        end
      end
    end
  end
end

# NewRelic instrumentation for Sinatra applications.  Sinatra actions will
# appear in the UI similar to controller actions, and have breakdown charts
# and transaction traces.
#
# The actions in the UI will correspond to the pattern expression used
# to match them, not directly to full URL's.
module NewRelic::Agent::Instrumentation
  module Sinatra
    module Tracer
      # include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation

      def self.included: (untyped clazz) -> untyped

      # Expected method for supporting ControllerInstrumentation
      def newrelic_request_headers: (untyped _) -> untyped

      def newrelic_middlewares: () -> untyped

      def build_with_tracing: (*untyped args) { () -> untyped } -> untyped

      def install_lock: () -> untyped

      def try_to_use: (untyped app, untyped clazz) -> untyped

      # Capture last route we've seen. Will set for transaction on route_eval
      def process_route_with_tracing: (*untyped args) { () -> untyped } -> untyped

      # If a transaction name is already set, this call will tromple over it.
      # This is intentional, as typically passing to a separate route is like
      # an entirely separate transaction, so we pick up the new name.
      #
      # If we're ignored, this remains safe, since set_transaction_name
      # care for the gating on the transaction's existence for us.
      def route_eval_with_tracing: (*untyped args) { () -> untyped } -> untyped

      def get_request_params: () -> untyped

      def dispatch_with_tracing: () { () -> untyped } -> untyped

      def do_not_trace?: () -> untyped

      # Overrides ControllerInstrumentation implementation
      def ignore_apdex?: () -> untyped

      # Overrides ControllerInstrumentation implementation
      def ignore_enduser?: () -> untyped
    end
  end
end


module NewRelic::Agent::Instrumentation
  module Logger::Prepend
    include NewRelic::Agent::Instrumentation::Logger

    def format_message: (untyped severity, untyped datetime, untyped progname, untyped msg) -> untyped
  end
end

module NewRelic::Agent::Instrumentation
  module Logger
    def self.instrument!: () -> untyped
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Logger
        def skip_instrumenting?: () -> untyped

        # We support setting this on loggers which might not have
        # instrumentation installed yet. This lets us disable in AgentLogger
        # and AuditLogger without them having to know the inner details.
        def self.mark_skip_instrumenting: (untyped logger) -> untyped

        def self.clear_skip_instrumenting: (untyped logger) -> untyped

        def mark_skip_instrumenting: () -> untyped

        def clear_skip_instrumenting: () -> untyped

        def self.enabled?: () -> untyped

        def format_message_with_tracing: (untyped severity, untyped datetime, untyped progname, untyped msg) { () -> untyped } -> untyped
      end
    end
  end
end

module NewRelic
  module Instrumentation
    module ActsAsSolrInstrumentation
      # module ParserMethodsInstrumentation
      #   def parse_query_with_newrelic: (*untyped args) -> untyped
      # end
    end
  end
end

class Object
  # include NewRelic::Instrumentation::ActsAsSolrInstrumentation::ParserMethodsInstrumentation

  # alias parse_query_without_newrelic parse_query

  # alias parse_query parse_query_with_newrelic
end

module NewRelic
  module Agent
    module Instrumentation
      class NotificationsSubscriber
        def initialize: () -> void

        def self.subscribed?: () -> untyped

        def self.find_all_subscribers: () -> untyped

        def self.subscribe: (untyped pattern) -> untyped

        def log_notification_error: (untyped error, untyped name, untyped event_type) -> untyped

        def push_segment: (untyped id, untyped segment) -> untyped

        def pop_segment: (untyped id) -> untyped

        def segment_stack: () -> untyped

        def state: () -> untyped

        def define_exception_method: () -> (nil | untyped)
      end
    end
  end
end



module NewRelic::Agent::Instrumentation
  module Redis
    module Prepend
      include NewRelic::Agent::Instrumentation::Redis

      def call: (*untyped args) { () -> untyped } -> untyped

      def call_pipeline: (*untyped args) { () -> untyped } -> untyped

      def connect: (*untyped args) { () -> untyped } -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Redis
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Redis
    PRODUCT_NAME: "Redis"

    CONNECT: "connect"

    UNKNOWN: "unknown"

    LOCALHOST: "localhost"

    MULTI_OPERATION: "multi"

    PIPELINE_OPERATION: "pipeline"

    def call_with_tracing: (untyped command) { () -> untyped } -> untyped

    def call_pipeline_with_tracing: (untyped pipeline) { () -> untyped } -> untyped

    def connect_with_tracing: () { () -> untyped } -> untyped

    private

    def with_tracing: (untyped operation, ?untyped? statement) { () -> untyped } -> untyped

    def _nr_hostname: () -> untyped

    def _nr_port_path_or_id: () -> untyped
  end
end



class Object
  public
end

module NewRelic::Agent::Instrumentation
  module ActiveSupportLogger::Prepend
    include NewRelic::Agent::Instrumentation::ActiveSupportLogger

    def broadcast: (untyped logger) -> untyped
  end
end

module NewRelic::Agent::Instrumentation
  module ActiveSupportLogger
    module Chain
      def instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module ActiveSupportLogger
        # Mark @skip_instrumenting on any broadcasted loggers to instrument Rails.logger only
        def broadcast_with_tracing: (untyped logger) { () -> untyped } -> untyped
      end
    end
  end
end


module NewRelic
  module Agent
    module DataMapperTracing
      def self.add_tracer: (untyped clazz, untyped method_name, ?bool operation_only) -> untyped

      DATA_MAPPER: "DataMapper"

      PASSWORD_REGEX: ::Regexp

      AMPERSAND: "&"

      PASSWORD_PARAM: "&password="

      def self.method_body: (untyped clazz, untyped method_name, untyped operation_only) -> untyped
    end

    module Instrumentation
      # module DataMapperInstrumentation
      #   def log: (untyped msg) -> untyped
      # end
    end
  end
end

class Object
  # include ::NewRelic::Agent::Instrumentation::DataMapperInstrumentation
end

module NewRelic::Agent::Instrumentation
  module Rake
    module Prepend
      include NewRelic::Agent::Instrumentation::Rake::Tracer

      def invoke: (*untyped args) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Rake
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Rake
        module Tracer
          def invoke_with_newrelic_tracing: (*untyped args) { () -> untyped } -> untyped
        end

        def self?.should_install?: () -> untyped

        def self?.safe_from_third_party_gem?: () -> (true | false)

        def self?.should_trace?: (untyped name) -> untyped

        def self?.instrument_execute_on_prereqs: (untyped task) -> untyped

        def self?.instrument_execute: (untyped task) -> (nil | untyped)

        def self?.instrument_invoke_prerequisites_concurrently: (untyped task) -> untyped

        def self?.before_invoke_transaction: (untyped task) -> untyped

        def self?.record_attributes: (untyped args, untyped task) -> untyped

        # Expects literal args passed to the task and array of task names
        # If names are present without matching args, still sets them with nils
        def self?.name_the_args: (untyped args, untyped names) -> untyped

        def self?.ensure_at_exit: () -> (nil | untyped)
      end
    end
  end
end

class Object
  # include NewRelic::Agent::Instrumentation::ControllerInstrumentation
end



# class ActiveMerchant::Billing::Gateway
#   include NewRelic::Agent::MethodTracer
# end

module NewRelic::Agent::Instrumentation
  module Bunny::Prepend
    module Exchange
      include NewRelic::Agent::Instrumentation::Bunny::Exchange

      def publish: (untyped payload, ?::Hash[untyped, untyped] opts) -> untyped
    end

    module Queue
      include NewRelic::Agent::Instrumentation::Bunny::Queue

      def pop: (?::Hash[untyped, untyped] opts) { () -> untyped } -> untyped

      def purge: (*untyped args) -> untyped
    end

    module Consumer
      include NewRelic::Agent::Instrumentation::Bunny::Consumer

      def call: (*untyped args) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Bunny
    def self.instrument!: () -> untyped
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Bunny
        LIBRARY: "RabbitMQ"

        DEFAULT_NAME: "Default"

        DEFAULT_TYPE: :direct

        SLASH: "/"

        def self?.exchange_name: (untyped name) -> untyped

        def self?.exchange_type: (untyped delivery_info, untyped channel) -> untyped

        module Exchange
          include Bunny

          def publish_with_tracing: (untyped payload, ?::Hash[untyped, untyped] opts) { () -> untyped } -> untyped
        end

        module Queue
          include Bunny

          def pop_with_tracing: () { () -> untyped } -> untyped

          def purge_with_tracing: () { () -> untyped } -> untyped
        end

        module Consumer
          include Bunny

          def call_with_tracing: (*untyped args) { () -> untyped } -> untyped
        end
      end
    end
  end
end


module NewRelic
  module Agent
    module Instrumentation
      module ActiveRecordHelper
        # Used by both the AR 3.x and 4.x instrumentation
        def self?.instrument_additional_methods: () -> untyped

        def self?.instrument_save_methods: () -> untyped

        def self?.instrument_relation_methods: () -> untyped

        ACTIVE_RECORD: "ActiveRecord"

        OTHER: "other"

        def self?.product_operation_collection_for: (untyped name, untyped sql, untyped adapter_name) -> untyped

        SPACE: " "

        EMPTY: ::Array[untyped]

        def self?.split_name: (untyped name) -> untyped

        def self?.model_from_splits: (untyped splits) -> untyped

        def self?.operation_from_splits: (untyped splits, untyped sql) -> untyped

        # These are used primarily to optimize and avoid allocation on well
        # known operations coming in. Anything not matching the list is fine,
        # it just needs to get downcased directly for use.
        OPERATION_NAMES: ::Hash[::String, "find" | "create" | "columns" | "indexes" | "destroy" | "update" | "save"]

        def self?.map_operation: (untyped raw_operation) -> untyped

        PRODUCT_NAMES: ::Hash[::String, "MySQL" | "Postgres" | "SQLite" | "Derby" | "JDBC" | "MSSQL" | "ODBC" | "Oracle"]

        ACTIVE_RECORD_DEFAULT_PRODUCT_NAME: "ActiveRecord"

        def self?.map_product: (untyped adapter_name) -> untyped

        module InstanceIdentification
          extend ::NewRelic::Agent::Instrumentation::ActiveRecordHelper::InstanceIdentification

          PRODUCT_SYMBOLS: ::Hash[::String, :mysql | :postgres]

          DATASTORE_DEFAULT_PORTS: { mysql: "3306", postgres: "5432" }

          DEFAULT: "default"

          UNKNOWN: "unknown"

          SLASH: "/"

          LOCALHOST: "localhost"

          def host: (untyped config) -> untyped

          def port_path_or_id: (untyped config) -> untyped

          SUPPORTED_ADAPTERS: ::Array[:mysql | :postgres]

          def supported_adapter?: (untyped config) -> untyped

          private

          def postgres_unix_domain_socket_case?: (untyped host, untyped adapter) -> untyped

          def mysql_default_case?: (untyped config, untyped adapter) -> untyped
        end
      end
    end
  end
end




module NewRelic
  module Agent
    module Instrumentation
      class ActionCableSubscriber < NotificationsSubscriber
        PERFORM_ACTION: "perform_action.action_cable"

        def start: (untyped name, untyped id, untyped payload) -> untyped

        def finish: (untyped name, untyped id, untyped payload) -> untyped

        private

        def transaction_name_from_payload: (untyped payload) -> ::String

        def metric_name_from_payload: (untyped name, untyped payload) -> ::String

        DOT_ACTION_CABLE: ".action_cable"

        def action_name: (untyped name) -> untyped
      end
    end
  end
end

# Provides a way to send :connection through ActiveSupport notifications to avoid
# looping through connection handlers to locate a connection by connection_id
# This is not needed in Rails 6+: https://github.com/rails/rails/pull/34602
module NewRelic
  module Agent
    module Instrumentation
      module ActiveRecordNotifications
        SQL_ACTIVE_RECORD: "sql.active_record"

        module BaseExtensions4x
          # https://github.com/rails/rails/blob/4-1-stable/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L371
          def log: (untyped sql, ?::String name, ?untyped binds, ?untyped? statement_name) { () -> untyped } -> untyped
        end

        module BaseExtensions50
          # https://github.com/rails/rails/blob/5-0-stable/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L582
          def log: (untyped sql, ?::String name, ?untyped binds, ?untyped type_casted_binds, ?untyped? statement_name) { () -> untyped } -> untyped
        end

        module BaseExtensions51
          def log: (untyped sql, ?::String name, ?untyped binds, ?untyped type_casted_binds, ?untyped? statement_name) { () -> untyped } -> untyped
        end
      end
    end
  end
end

module NewRelic::SidekiqInstrumentation
  class Server
    # include NewRelic::Agent::Instrumentation::ControllerInstrumentation

    # Client middleware has additional parameters, and our tests use the
    # middleware client-side to work inline.
    def call: (untyped worker, untyped msg, untyped queue, *untyped _) { () -> untyped } -> untyped

    def self.default_trace_args: (untyped msg) -> { name: "perform", class_name: untyped, category: "OtherTransaction/SidekiqJob" }
  end

  class Client
    def call: (untyped _worker_class, untyped job, *untyped _) { () -> untyped } -> untyped

    def distributed_tracing_headers: () -> untyped
  end
end

# class Sidekiq::Extensions::DelayedClass
#   def newrelic_trace_args: (untyped msg, untyped queue) -> untyped
# end



module NewRelic
  module Agent
    module Instrumentation
      module Resque
        module Helper
          extend ::NewRelic::Agent::Instrumentation::Resque::Helper

          def resque_fork_per_job?: () -> untyped
        end
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Resque
    module Prepend
      include NewRelic::Agent::Instrumentation::Resque

      def perform: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Resque
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Resque
    # include NewRelic::Agent::Instrumentation::ControllerInstrumentation

    def with_tracing: () { () -> untyped } -> untyped
  end
end

class Object
  def supported_sequel_version?: () -> untyped
end

module NewRelic
  module Agent
    module Instrumentation
      module Curb
        module Easy
          module Prepend
            include NewRelic::Agent::Instrumentation::Curb::Easy

            def http_head: (*untyped args) { () -> untyped } -> untyped

            def http_post: (*untyped args) { () -> untyped } -> untyped

            def http_put: (*untyped args) { () -> untyped } -> untyped

            def http: (untyped verb) -> untyped

            def perform: () -> untyped

            def method: (untyped verb) -> untyped

            def header_str: () -> untyped
          end
        end

        module Multi
          module Prepend
            include NewRelic::Agent::Instrumentation::Curb::Multi

            def add: (untyped curl) -> untyped

            def perform: () { () -> untyped } -> untyped
          end
        end
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Curb
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Curb
        module Easy
          attr_accessor _nr_instrumented: untyped

          attr_accessor _nr_failure_instrumented: untyped

          attr_accessor _nr_http_verb: untyped

          attr_accessor _nr_header_str: untyped

          attr_accessor _nr_original_on_header: untyped

          attr_accessor _nr_original_on_complete: untyped

          attr_accessor _nr_original_on_failure: untyped

          attr_accessor _nr_serial: untyped

          # We have to hook these three methods separately, as they don't use
          # Curl::Easy#http
          def http_head_with_tracing: () { () -> untyped } -> untyped

          def http_post_with_tracing: () { () -> untyped } -> untyped

          def http_put_with_tracing: () { () -> untyped } -> untyped

          # Hook the #http method to set the verb.
          def http_with_tracing: (untyped verb) { () -> untyped } -> untyped

          # Hook the #perform method to mark the request as non-parallel.
          def perform_with_tracing: () { () -> untyped } -> untyped

          # Record the HTTP verb for future #perform calls
          def method_with_tracing: (untyped verb) { () -> untyped } -> untyped

          # We override this method in order to ensure access to header_str even
          # though we use an on_header callback
          def header_str_with_tracing: () { () -> untyped } -> untyped
        end

        module Multi
          # include NewRelic::Agent::MethodTracer

          # Add CAT with callbacks if the request is serial
          def add_with_tracing: (untyped curl) { () -> untyped } -> untyped

          # Trace as an External/Multiple call if the first request isn't serial.
          def perform_with_tracing: () { () -> untyped } -> untyped

          # Instrument the specified +request+ (a Curl::Easy object)
          # and set up cross-application tracing if it's enabled.
          def hook_pending_request: (untyped request) -> untyped

          # Create request and response adapter objects for the specified +request+
          # NOTE: Although strange to wrap request and response at once, it works
          # because curb's callback mechanism updates the instantiated wrappers
          # during the life-cycle of external request
          def wrap_request: (untyped request) -> untyped

          # Install a callback that will record the response headers
          # to enable CAT linking
          def install_header_callback: (untyped request, untyped wrapped_response) -> untyped

          # Install a callback that will finish the trace.
          def install_completion_callback: (untyped request, untyped wrapped_response, untyped segment) -> untyped

          # Install a callback that will fire on failures
          # NOTE:  on_failure is not always called, so we're not always
          # unhooking the callback.  No harm/no foul in production, but
          # definitely something to beware of if debugging callback issues
          # _nr_failure_instrumented exists to prevent infinitely chaining
          # our on_failure callback hook.
          def install_failure_callback: (untyped request, untyped wrapped_response, untyped segment) -> (nil | untyped)

          # on_failure callbacks cannot be removed in the on_complete
          # callback where this method is invoked because on_complete
          # fires before the on_failure!
          def remove_instrumentation_callbacks: (untyped request) -> untyped

          # We execute customer's on_failure callback (if any) and
          # uninstall our hook here since the on_complete callback
          # fires before the on_failure callback.
          def remove_failure_callback: (untyped request) -> untyped

          private

          def first_request_is_serial?: () -> (false | untyped)
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Memcache
        module Dalli
          extend Helper

          def self?.instrument!: () -> untyped

          def self?.instrument_multi_method: (untyped method_name) -> untyped

          def self?.instrument_server_for_key: () -> untyped

          def self?.instrument_send_multiget: () -> untyped
        end

        module DalliCAS
          extend Dalli

          extend Helper

          def self?.should_instrument?: () -> untyped

          def self?.instrument!: () -> untyped
        end
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Memcache
    module Helper
      DATASTORE_INSTANCES_SUPPORTED_VERSION: untyped

      BINARY_PROTOCOL_SUPPORTED_VERSION: untyped

      def supports_datastore_instances?: () -> untyped

      def supports_binary_protocol?: () -> untyped

      def client_methods: () -> ::Array[:get | :get_multi | :set | :add | :incr | :decr | :delete | :replace | :append | :prepend | :cas | :single_get | :multi_get | :single_cas | :multi_cas]

      def dalli_methods: () -> ::Array[:get | :set | :add | :incr | :decr | :delete | :replace | :append | :prepend | :cas]

      def dalli_cas_methods: () -> ::Array[:get_cas | :set_cas | :replace_cas | :delete_cas]

      def supported_methods_for: (untyped client_class, untyped methods) -> untyped

      def instrument_methods: (untyped client_class, ?untyped requested_methods) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Memcache
    module Prepend
      extend Helper

      def self?.client_prepender: (untyped client_class) -> untyped

      def self?.dalli_cas_prependers: () { (untyped, untyped) -> untyped } -> untyped

      def self?.dalli_prependers: () { (untyped, untyped) -> untyped } -> untyped

      def self?.dalli_client_prepender: (untyped supported_methods) -> untyped

      def self?.dalli_get_multi_prepender: (untyped method_name) -> untyped

      def self?.dalli_ring_prepender: () -> untyped

      def self?.dalli_server_prepender: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Memcache
    module Chain
      extend Helper

      def self.instrument!: (untyped target_class) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Memcache
    module Tracer
      SLASH: "/"

      UNKNOWN: "unknown"

      LOCALHOST: "localhost"

      MULTIGET_METRIC_NAME: "get_multi_request"

      MEMCACHED: "Memcached"

      def with_newrelic_tracing: (untyped operation, *untyped args) { () -> untyped } -> untyped

      def server_for_key_with_newrelic_tracing: () { () -> untyped } -> untyped

      def get_multi_with_newrelic_tracing: (untyped method_name) { () -> untyped } -> untyped

      def send_multiget_with_newrelic_tracing: (untyped keys) { () -> untyped } -> untyped

      def assign_instance_to: (untyped segment, untyped server) -> untyped
    end
  end
end

EXCON_MIN_VERSION: untyped

class Object
  def install_excon_instrumentation: (untyped excon_version) -> untyped

  def install_middleware_excon_instrumentation: () -> untyped
end

module NewRelic
  module Agent
    module Instrumentation
      module SequelHelper
        extend ::NewRelic::Agent::Instrumentation::SequelHelper

        # Fallback if the product cannot be determined
        DEFAULT_PRODUCT_NAME: "Sequel"

        # A Sequel adapter is called an "adapter_scheme" and can be accessed from
        # the database:
        #
        #   DB.adapter_scheme
        PRODUCT_NAMES: { ibmdb: "IBMDB2", firebird: "Firebird", informix: "Informix", jdbc: "JDBC", mysql: "MySQL", :mysql2 => "MySQL", oracle: "Oracle", postgres: "Postgres", sqlite: "SQLite" }

        def product_name_from_adapter: (untyped adapter) -> untyped
      end
    end
  end
end

module ActionDispatch
  class MiddlewareStack
    class Middleware
      def build_with_new_relic: (untyped app) -> untyped

      alias build_without_new_relic build

      alias build build_with_new_relic
    end
  end
end

CURB_MIN_VERSION: untyped


module NewRelic
  module Agent
    module Instrumentation
      module NetHTTP
        module Prepend
          include NewRelic::Agent::Instrumentation::NetHTTP

          def request: (untyped request, *untyped args) { () -> untyped } -> untyped
        end
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module NetHTTP
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module NetHTTP
        def request_with_tracing: (untyped request) { () -> untyped } -> untyped
      end
    end
  end
end


module NewRelic
  module Agent
    module Instrumentation
      module ActiveRecordPrepend
        ACTIVE_RECORD: "ActiveRecord"

        module BaseExtensions
          # def save: (*untyped args) { () -> untyped } -> untyped

          # def save!: (*untyped args) { () -> untyped } -> untyped

          def save: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

          def save!: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped
        end

        module BaseExtensions516
          def touch: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped
        end

        module RelationExtensions
          def update_all: (*untyped args) { () -> untyped } -> untyped

          def delete_all: (*untyped args) { () -> untyped } -> untyped

          def destroy_all: (*untyped args) { () -> untyped } -> untyped

          def calculate: (*untyped args) { () -> untyped } -> untyped

          def pluck: (*untyped args) { () -> untyped } -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module MiddlewareTracing
        TXN_STARTED_KEY: "newrelic.transaction_started"

        CONTENT_TYPE: "Content-Type"

        CONTENT_LENGTH: "Content-Length"

        def _nr_has_middleware_tracing: () -> true

        def build_transaction_options: (untyped env, untyped first_middleware) -> untyped

        def merge_first_middleware_options: (untyped opts, untyped env) -> untyped

        def note_transaction_started: (untyped env) -> untyped

        def capture_http_response_code: (untyped state, untyped result) -> untyped

        def capture_response_content_type: (untyped state, untyped result) -> untyped

        def capture_response_content_length: (untyped state, untyped result) -> untyped

        def capture_response_attributes: (untyped state, untyped result) -> untyped

        def call: (untyped env) -> untyped

        def events: () -> untyped
      end
    end
  end
end


module NewRelic::Agent::Instrumentation
  module RackHelpers
    def self.version_supported?: () -> untyped

    def self.rack_version_supported?: () -> (false | untyped)

    def self.puma_rack_version_supported?: () -> (false | untyped)

    def self.middleware_instrumentation_enabled?: () -> untyped
  end
end

module NewRelic::Agent::Instrumentation
  module Rack
    module URLMap
      module Prepend
        def initialize: (?::Hash[untyped, untyped] map) -> void
      end
    end

    module Prepend
      include ::NewRelic::Agent::Instrumentation::RackBuilder

      def self.prepended: (untyped builder_class) -> untyped

      def to_app: () -> untyped

      def run: (untyped app, *untyped args) -> untyped

      def use: (untyped middleware_class, *untyped args) { () -> untyped } -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Rack
    module Chain
      def self.instrument!: (untyped builder_class) -> untyped
    end

    module URLMap
      module Chain
        def self.instrument!: (untyped url_map_class) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module RackBuilder
        def self.track_deferred_detection: (untyped builder_class) -> untyped

        def deferred_dependency_check: () -> (nil | untyped)

        def check_for_late_instrumentation: (untyped app) -> (nil | untyped)

        # We patch the #to_app method for a reason that actually has nothing to do with
        # instrumenting rack itself. It happens to be a convenient and
        # easy-to-hook point that happens late in the startup sequence of almost
        # every application, making it a good place to do a final call to
        # DependencyDetection.detect!, since all libraries are likely loaded at
        # this point.
        def with_deferred_dependency_detection: () { () -> untyped } -> untyped

        def middleware_instrumentation_enabled?: () -> untyped

        def run_with_tracing: (untyped app) { (untyped) -> untyped } -> untyped

        def use_with_tracing: (untyped middleware_class) { (untyped) -> untyped } -> (nil | untyped)
      end

      module RackURLMap
        def self.generate_traced_map: (untyped map) -> untyped
      end
    end
  end
end


module NewRelic
  module Agent
    module Instrumentation
      class ActiveStorageSubscriber < NotificationsSubscriber
        def start: (untyped name, untyped id, untyped payload) -> untyped

        def finish: (untyped name, untyped id, untyped payload) -> untyped

        def start_segment: (untyped name, untyped id, untyped payload) -> untyped

        def finish_segment: (untyped id, untyped payload) -> untyped

        def metric_name: (untyped name, untyped payload) -> ::String

        PATTERN: ::Regexp

        UNKNOWN: "unknown"

        METHOD_NAME_MAPPING: untyped

        def method_from_name: (untyped name) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module ActiveRecord
        EXPLAINER: untyped

        def self.insert_instrumentation: () -> untyped

        def self.included: (untyped instrumented_class) -> untyped

        # def log_with_newrelic_instrumentation: (*untyped args) { () -> untyped } -> untyped

        def log_with_newrelic_instrumentation: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped
      end
    end
  end
end

HTTPCLIENT_MIN_VERSION: "2.2.0"

module NewRelic::Agent::Instrumentation
  module Typhoeus
    module Prepend
      include NewRelic::Agent::Instrumentation::Typhoeus

      def run: (*untyped args) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Typhoeus
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Typhoeus
        HYDRA_SEGMENT_NAME: "External/Multiple/Typhoeus::Hydra/run"

        NOTICIBLE_ERROR_CLASS: "Typhoeus::Errors::TyphoeusError"

        EARLIEST_VERSION: untyped

        def self.is_supported_version?: () -> untyped

        def self.request_is_hydra_enabled?: (untyped request) -> untyped

        def self.response_message: (untyped response) -> untyped

        def with_tracing: () { () -> untyped } -> untyped

        def self.trace: (untyped request) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      # https://newrelic.com/docs/features/tracking-front-end-time
      # Record queue time metrics based on any of three headers
      # which can be set on the request.
      module QueueTime
        REQUEST_START_HEADER: "HTTP_X_REQUEST_START"

        QUEUE_START_HEADER: "HTTP_X_QUEUE_START"

        MIDDLEWARE_START_HEADER: "HTTP_X_MIDDLEWARE_START"

        ALL_QUEUE_METRIC: "WebFrontend/QueueTime"

        # any timestamps before this are thrown out and the parser
        # will try again with a larger unit (2000/1/1 UTC)
        EARLIEST_ACCEPTABLE_TIME: untyped

        CANDIDATE_HEADERS: ::Array[untyped]

        DIVISORS: ::Array[1000000 | 1000 | 1]

        def self?.parse_frontend_timestamp: (untyped headers, ?untyped now) -> untyped

        def self?.timestamp_string_from_header_value: (untyped value) -> untyped

        def self?.parse_timestamp: (untyped string) -> (untyped | nil)
      end
    end
  end
end

module ::Excon
  module Middleware
    class NewRelicCrossAppTracing
      TRACE_DATA_IVAR: :@newrelic_trace_data

      def initialize: (untyped stack) -> void

      def request_call: (untyped datum) -> untyped

      def response_call: (untyped datum) -> untyped

      def error_call: (untyped datum) -> untyped

      def finish_trace: (untyped datum) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Grape
    module Prepend
      def call: (untyped env) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Grape
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Grape
    module Instrumentation
      extend ::NewRelic::Agent::Instrumentation::Grape::Instrumentation

      # Since 1.2.0, the class `Grape::API` no longer refers to an API instance, rather, what used to be `Grape::API` is `Grape::API::Instance`
      # https://github.com/ruby-grape/grape/blob/c20a73ac1e3f3ba1082005ed61bf69452373ba87/UPGRADING.md#upgrading-to--120
      def instrumented_class: () -> untyped

      def capture_transaction: (untyped env, untyped context) -> untyped

      def prepare!: () -> untyped

      API_ENDPOINT: "api.endpoint"

      API_VERSION: "api.version"

      FORMAT_REGEX: ::Regexp

      # either :format (< 0.12.0) or .ext (>= 0.12.0)
      VERSION_REGEX: ::Regexp

      MIN_VERSION: untyped

      PIPE_STRING: "|"

      def handle_transaction: (untyped endpoint, untyped class_name, untyped version) -> (nil | untyped)

      def name_transaction: (untyped route, untyped class_name, untyped version) -> untyped

      def name_for_transaction: (untyped route, untyped class_name, untyped version) -> untyped

      def name_for_transaction_deprecated: (untyped route, untyped class_name, untyped version) -> untyped

      def capture_params: (untyped endpoint) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module IgnoreActions
        def self.is_filtered?: (untyped key, untyped klass, untyped action_name) -> (true | false)
      end
    end
  end
end

class Object
  def install_mongo_command_subscriber: () -> untyped
end

module NewRelic
  module Agent
    # @api public
    module Instrumentation
      # == NewRelic instrumentation for controller actions and tasks
      #
      # This module can also be used to capture performance information for
      # background tasks and other non-web transactions, including
      # detailed transaction traces and traced errors.
      #
      # For details on how to instrument background tasks see
      # {ClassMethods#add_transaction_tracer} and
      # {#perform_action_with_newrelic_trace}
      #
      # @api public
      #
      # module ControllerInstrumentation
      #   def self.included: (untyped clazz) -> untyped

      #   module ClassMethodsShim
      #     # This module is for importing stubs when the agent is disabled
      #     # :nodoc:
      #     def newrelic_ignore: (*untyped args) -> nil

      #     def newrelic_ignore_apdex: (*untyped args) -> nil

      #     def newrelic_ignore_enduser: (*untyped args) -> nil
      #   end

      #   module Shim
      #     # :nodoc:
      #     def self.included: (untyped clazz) -> untyped

      #     def new_relic_trace_controller_action: (*untyped args) { () -> untyped } -> untyped

      #     def perform_action_with_newrelic_trace: (*untyped args) { () -> untyped } -> untyped
      #   end

      #   NR_DO_NOT_TRACE_KEY: :@do_not_trace

      #   NR_IGNORE_APDEX_KEY: :@ignore_apdex

      #   NR_IGNORE_ENDUSER_KEY: :@ignore_enduser

      #   NR_DEFAULT_OPTIONS: ::Hash[untyped, untyped]

      #   # @api public
      #   module ClassMethods
      #     # Have NewRelic ignore actions in this controller.  Specify the actions as hash options
      #     # using :except and :only.  If no actions are specified, all actions are ignored.
      #     #
      #     # @api public
      #     #
      #     def newrelic_ignore: (?::Hash[untyped, untyped] specifiers) -> untyped

      #     # Have NewRelic omit apdex measurements on the given actions.  Typically used for
      #     # actions that are not user facing or that skew your overall apdex measurement.
      #     # Accepts :except and :only options, as with #newrelic_ignore.
      #     #
      #     # @api public
      #     #
      #     def newrelic_ignore_apdex: (?::Hash[untyped, untyped] specifiers) -> untyped

      #     # @api public
      #     def newrelic_ignore_enduser: (?::Hash[untyped, untyped] specifiers) -> untyped

      #     def newrelic_ignore_aspect: (untyped property, ?::Hash[untyped, untyped] specifiers) -> untyped

      #     def newrelic_write_attr: (untyped attr_name, untyped value) -> untyped

      #     def newrelic_read_attr: (untyped attr_name) -> untyped

      #     # Add transaction tracing to the given method.  This will treat
      #     # the given method as a main entrypoint for instrumentation, just
      #     # like controller actions are treated by default.  Useful especially
      #     # for background tasks.
      #     #
      #     # Example for background job:
      #     #   class Job
      #     #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
      #     #     def run(task)
      #     #        ...
      #     #     end
      #     #     # Instrument run so tasks show up under task.name.  Note single
      #     #     # quoting to defer eval to runtime.
      #     #     add_transaction_tracer :run, :name => '#{args[0].name}'
      #     #   end
      #     #
      #     # Here's an example of a controller that uses a dispatcher
      #     # action to invoke operations which you want treated as top
      #     # level actions, so they aren't all lumped into the invoker
      #     # action.
      #     #
      #     #   MyController < ActionController::Base
      #     #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
      #     #     # dispatch the given op to the method given by the service parameter.
      #     #     def invoke_operation
      #     #       op = params['operation']
      #     #       send op
      #     #     end
      #     #     # Ignore the invoker to avoid double counting
      #     #     newrelic_ignore :only => 'invoke_operation'
      #     #     # Instrument the operations:
      #     #     add_transaction_tracer :print
      #     #     add_transaction_tracer :show
      #     #     add_transaction_tracer :forward
      #     #   end
      #     #
      #     # Here's an example of how to pass contextual information into the transaction
      #     # so it will appear in transaction traces:
      #     #
      #     #   class Job
      #     #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
      #     #     def process(account)
      #     #        ...
      #     #     end
      #     #     # Include the account name in the transaction details.  Note the single
      #     #     # quotes to defer eval until call time.
      #     #     add_transaction_tracer :process, :params => '{ :account_name => args[0].name }'
      #     #   end
      #     #
      #     # See NewRelic::Agent::Instrumentation::ControllerInstrumentation#perform_action_with_newrelic_trace
      #     # for the full list of available options.
      #     #
      #     # @api public
      #     #
      #     def add_transaction_tracer: (untyped method, ?::Hash[untyped, untyped] options) -> (nil | untyped)

      #     def parse_punctuation: (untyped method) -> ::Array[untyped]

      #     def generate_argument_list: (untyped options) -> untyped

      #     def build_method_names: (untyped traced_method, untyped punctuation) -> ::Array[::String]

      #     def already_added_transaction_tracer?: (untyped target, untyped with_method_name) -> untyped
      #   end

      #   class TransactionNamer
      #     def self.name_for: (untyped txn, untyped traced_obj, untyped category, ?::Hash[untyped, untyped] options) -> ::String

      #     def self.prefix_for_category: (untyped txn, ?untyped? category) -> untyped

      #     def self.path_name: (untyped traced_obj, ?::Hash[untyped, untyped] options) -> untyped

      #     def self.class_name: (untyped traced_obj, ?::Hash[untyped, untyped] options) -> untyped
      #   end

      #   def perform_action_with_newrelic_trace: (*untyped args) { () -> untyped } -> untyped

      #   def newrelic_request: (untyped args) -> untyped

      #   # Should be implemented in the dispatcher class
      #   def newrelic_response_code: () -> nil

      #   def newrelic_request_headers: (untyped request) -> untyped

      #   # overrideable method to determine whether to trace an action
      #   # or not - you may override this in your controller and supply
      #   # your own logic for ignoring transactions.
      #   def do_not_trace?: () -> untyped

      #   # overrideable method to determine whether to trace an action
      #   # for purposes of apdex measurement - you can use this to
      #   # ignore things like api calls or other fast non-user-facing
      #   # actions
      #   def ignore_apdex?: () -> untyped

      #   def ignore_enduser?: () -> untyped

      #   private

      #   def create_transaction_options: (untyped trace_options, untyped category, untyped state, untyped queue_start_time) -> untyped

      #   # Filter out a request if it matches one of our parameters for
      #   # ignoring it - the key is either NR_DO_NOT_TRACE_KEY or NR_IGNORE_APDEX_KEY
      #   def _is_filtered?: (untyped key) -> untyped

      #   def detect_queue_start_time: (untyped request) -> untyped
      # end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Rails3
        module ActionController
          # determine the path that is used in the metric name for
          # the called controller action
          def newrelic_metric_path: (?untyped? action_name_override) -> untyped

          def process_action: (*untyped args) -> untyped
        end

        module ActionView
          module NewRelic
            extend ::NewRelic::Agent::Instrumentation::Rails3::ActionView::NewRelic

            def template_metric: (untyped identifier, ?::Hash[untyped, untyped] options) -> untyped

            def render_type: (untyped file_path) -> untyped
          end
        end
      end
    end
  end
end

class ActionController::Base
  # include NewRelic::Agent::Instrumentation::ControllerInstrumentation

  include NewRelic::Agent::Instrumentation::Rails3::ActionController
end

class Object
  # include NewRelic::Agent::MethodTracer

  def render_with_newrelic: (untyped context, untyped options) -> untyped

  alias render_without_newrelic render

  alias render render_with_newrelic

  # include NewRelic::Agent::MethodTracer

  def instrument_with_newrelic: (untyped name, ?::Hash[untyped, untyped] payload) { () -> untyped } -> untyped

  alias instrument_without_newrelic instrument

  alias instrument instrument_with_newrelic
end

module NewRelic::Agent::Instrumentation
  module HTTPrb
    module Prepend
      include NewRelic::Agent::Instrumentation::HTTPrb

      def perform: (untyped request, untyped options) -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module HTTPrb
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic::Agent::Instrumentation
  module HTTPrb
    def with_tracing: (untyped request) { () -> untyped } -> untyped
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module DelayedJob
        module Prepend
          include NewRelic::Agent::Instrumentation::DelayedJob

          def initialize: (*untyped args) -> void

          def install_newrelic_job_tracer: () -> untyped
        end
      end

      module DelayedJobTracerPrepend
        include NewRelic::Agent::Instrumentation::DelayedJobTracer

        def invoke_job: (*untyped args) { () -> untyped } -> untyped
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module DelayedJob
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module DelayedJob
        def initialize_with_tracing: () { () -> untyped } -> untyped
      end

      module DelayedJobTracer
        # include NewRelic::Agent::Instrumentation::ControllerInstrumentation

        NR_TRANSACTION_CATEGORY: "OtherTransaction/DelayedJob"

        def invoke_job_with_tracing: () { () -> untyped } -> untyped
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Tilt::Prepend
    include NewRelic::Agent::Instrumentation::Tilt

    def render: (*untyped args) { () -> untyped } -> untyped
  end
end

module NewRelic::Agent::Instrumentation
  module Tilt
    module Chain
      def self.instrument!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module Tilt
        def metric_name: (untyped klass, untyped file) -> ::String

        # Sinatra uses #caller_locations for the file name in Tilt (unlike Rails/Rack)
        # So here we are only grabbing the file name and name of directory it is in
        def create_filename_for_metric: (untyped file) -> untyped

        def render_with_tracing: (*untyped args) { () -> untyped } -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      class MiddlewareProxy
        include MiddlewareTracing

        ANONYMOUS_CLASS: "AnonymousClass"

        OBJECT_CLASS_NAME: "Object"

        # This class is used to wrap classes that are passed to
        # Rack::Builder#use without synchronously instantiating those classes.
        # A MiddlewareProxy::Generator responds to new, like a Class would, and
        # passes through arguments to new to the original target class.
        class Generator
          def initialize: (untyped middleware_class) -> void

          def new: (*untyped args) { () -> untyped } -> untyped
        end

        def self.is_sinatra_app?: (untyped target) -> untyped

        def self.for_class: (untyped target_class) -> untyped

        def self.needs_wrapping?: (untyped target) -> untyped

        def self.wrap: (untyped target, ?bool is_app) -> untyped

        attr_reader target: untyped

        attr_reader category: untyped

        attr_reader transaction_options: untyped

        def initialize: (untyped target, ?bool is_app) -> void

        def determine_category: () -> untyped

        def determine_prefix: () -> untyped

        # In 'normal' usage, the target will be an application instance that
        # responds to #call. With Rails, however, the target may be a subclass
        # of Rails::Application that defines a method_missing that proxies #call
        # to a singleton instance of the the subclass. We need to ensure that we
        # capture the correct name in both cases.
        def determine_class_name: () -> untyped

        def class_for_target: () -> untyped
      end
    end
  end
end


module NewRelic
  module Agent
    module Instrumentation
      module ActiveJobHelper
        # include ::NewRelic::Agent::MethodTracer

        def self.enqueue: (untyped job, untyped block) -> untyped

        def self.perform: (untyped job, untyped block) -> untyped

        def self.run_in_trace: (untyped job, untyped block, untyped event) -> untyped

        def self.run_in_transaction: (untyped job, untyped block) -> untyped

        def self.transaction_category: () -> ::String

        def self.transaction_name_suffix_for_job: (untyped job) -> ::String

        def self.transaction_name_for_job: (untyped job) -> ::String

        def self.adapter: () -> untyped

        ADAPTER_REGEX: ::Regexp

        def self.clean_adapter_name: (untyped name) -> untyped
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module PadrinoTracer
    module Prepend
      include NewRelic::Agent::Instrumentation::Sinatra

      include NewRelic::Agent::Instrumentation::Padrino

      def dispatch: () -> untyped

      def invoke_route: (*untyped args) { () -> untyped } -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Instrumentation
      module PadrinoTracer
        module Chain
          def self.instrument!: () -> untyped
        end
      end
    end
  end
end

module NewRelic::Agent::Instrumentation
  module Padrino
    def invoke_route_with_tracing: (*untyped args) { () -> untyped } -> untyped
  end
end

# Listen for ActiveSupport::Notifications events for ActiveRecord query
# events.  Write metric data, transaction trace nodes and slow sql
# nodes for each event.
module NewRelic
  module Agent
    module Instrumentation
      class ActiveRecordSubscriber < NotificationsSubscriber
        CACHED_QUERY_NAME: "CACHE"

        def initialize: () -> void

        def define_cachedp_method: () -> (nil | untyped)

        def start: (untyped name, untyped id, untyped payload) -> untyped

        def finish: (untyped name, untyped id, untyped payload) -> untyped

        def get_explain_plan: (untyped statement) -> untyped

        def active_record_config: (untyped payload) -> (untyped | nil)

        def start_segment: (untyped config, untyped payload) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module SystemInfo
      def self.ruby_os_identifier: () -> untyped

      def self.darwin?: () -> untyped

      def self.linux?: () -> untyped

      def self.bsd?: () -> untyped

      def self.ip_addresses: () -> untyped

      def self.clear_processor_info: () -> untyped

      def self.get_processor_info: () -> untyped

      def self.sysctl_value: (untyped name) -> untyped

      def self.parse_cpuinfo: (untyped cpuinfo) -> { num_physical_packages: untyped, num_physical_cores: untyped, num_logical_processors: untyped }

      def self.num_physical_packages: () -> untyped

      def self.num_physical_cores: () -> untyped

      def self.num_logical_processors: () -> untyped

      def self.processor_arch: () -> untyped

      def self.os_version: () -> untyped

      def self.docker_container_id: () -> (nil | untyped)

      def self.parse_docker_container_id: (untyped cgroup_info) -> (nil | untyped)

      def self.parse_cgroup_ids: (untyped cgroup_info) -> untyped

      # A File.read against /(proc|sysfs)/* can hang with some older Linuxes.
      # See https://bugzilla.redhat.com/show_bug.cgi?id=604887, RUBY-736, and
      # https://github.com/opscode/ohai/commit/518d56a6cb7d021b47ed3d691ecf7fba7f74a6a7
      # for details on why we do it this way.
      def self.proc_try_read: (untyped path) -> (nil | untyped)

      def self.ram_in_mib: () -> untyped

      def self.parse_linux_meminfo_in_mib: (untyped meminfo) -> untyped

      def self.boot_id: () -> (nil | untyped)
    end
  end
end

module NewRelic
  module Agent
    module VM
      class Snapshot
        attr_accessor gc_total_time: untyped

        attr_accessor gc_runs: untyped

        attr_accessor major_gc_count: untyped

        attr_accessor minor_gc_count: untyped

        attr_accessor total_allocated_object: untyped

        attr_accessor heap_live: untyped

        attr_accessor heap_free: untyped

        attr_accessor method_cache_invalidations: untyped

        attr_accessor constant_cache_invalidations: untyped

        attr_accessor thread_count: untyped

        attr_accessor taken_at: untyped

        def initialize: () -> void
      end
    end
  end
end

module NewRelic
  module Agent
    module VM
      class JRubyVM
        def snapshot: () -> untyped

        def gather_stats: (untyped snap) -> untyped

        def supports?: (untyped key) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module VM
      class MonotonicGCProfiler
        def initialize: () -> void

        def total_time_s: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module VM
      class MriVM
        def snapshot: () -> untyped

        def gather_stats: (untyped snap) -> untyped

        def gather_gc_stats: (untyped snap) -> untyped

        def gather_gc_time: (untyped snap) -> untyped

        def gather_ruby_vm_stats: (untyped snap) -> untyped

        def gather_constant_cache_invalidations: () -> untyped

        def gather_thread_stats: (untyped snap) -> untyped

        def supports?: (untyped key) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class ErrorTraceAggregator
      def initialize: (untyped capacity) -> void

      def enabled?: () -> untyped

      def merge!: (untyped errors) -> untyped

      # Get the errors currently queued up.  Unsent errors are left
      # over from a previous unsuccessful attempt to send them to the server.
      def harvest!: () -> untyped

      def reset!: () -> untyped

      # Synchronizes adding an error to the error queue, and checks if
      # the error queue is too long - if so, we drop the error on the
      # floor after logging a warning.
      def add_to_error_queue: (untyped noticed_error) -> (nil | untyped)

      # checks the size of the error queue to make sure we are under
      # the maximum limit, and logs a warning if we are over the limit.
      def over_queue_limit?: (untyped message) -> untyped

      # *Use sparingly for difficult to track bugs.*
      #
      # Track internal agent errors for communication back to New Relic.
      # To use, make a specific subclass of NewRelic::Agent::InternalAgentError,
      # then pass an instance of it to this method when your problem occurs.
      #
      # Limits are treated differently for these errors. We only gather one per
      # class per harvest, disregarding (and not impacting) the app error queue
      # limit.
      def notice_agent_error: (untyped exception) -> untyped

      def register_config_callbacks: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class RulesEngine
      class SegmentTermsRule
        PREFIX_KEY: "prefix"

        TERMS_KEY: "terms"

        SEGMENT_PLACEHOLDER: "*"

        ADJACENT_PLACEHOLDERS_REGEX: ::Regexp

        ADJACENT_PLACEHOLDERS_REPLACEMENT: "\\1"

        VALID_PREFIX_SEGMENT_COUNT: 2

        attr_reader prefix: untyped

        attr_reader terms: untyped

        def self.valid?: (untyped rule_spec) -> untyped

        def self.valid_prefix_segment_count?: (untyped prefix) -> untyped

        def initialize: (untyped options) -> void

        def terminal?: () -> true

        def matches?: (untyped string) -> untyped

        def prefix_matches_on_segment_boundary?: (untyped string) -> untyped

        def apply: (untyped string) -> ::String

        def collapse_adjacent_placeholder_segments: (untyped segments) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class RulesEngine
      class ReplacementRule
        attr_reader terminate_chain: untyped

        attr_reader each_segment: untyped

        attr_reader ignore: untyped

        attr_reader replace_all: untyped

        attr_reader eval_order: untyped

        attr_reader match_expression: untyped

        attr_reader replacement: untyped

        def initialize: (untyped options) -> void

        def terminal?: () -> untyped

        def matches?: (untyped string) -> untyped

        def apply: (untyped string) -> untyped

        def apply_replacement: (untyped string) -> untyped

        def apply_to_each_segment: (untyped string) -> ::String

        def <=>: (untyped other) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class MemoryLogger
      include LogOnce

      def initialize: () -> void

      def is_startup_logger?: () -> true

      attr_accessor messages: untyped

      attr_accessor level: untyped

      attr_accessor log_formatter: untyped

      def fatal: (*untyped msgs) { () -> untyped } -> untyped

      def error: (*untyped msgs) { () -> untyped } -> untyped

      def warn: (*untyped msgs) { () -> untyped } -> untyped

      def info: (*untyped msgs) { () -> untyped } -> untyped

      def debug: (*untyped msgs) { () -> untyped } -> untyped

      def log_exception: (untyped level, untyped e, ?untyped backtrace_level) -> untyped

      def dump: (untyped logger) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Utilization
      class GCP < Vendor
        MACH_TYPE: "machineType"

        ZONE: "zone"

        def prepare_response: (untyped response) -> untyped

        SLASH: "/"

        def trim_leading: (untyped value) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Utilization
      class AWS < Vendor
        IMDS_BASE_URL: "http://169.254.169.254/latest"

        IMDS_KEYS: ::Array["instanceId" | "instanceType" | "availabilityZone"]

        IMDS_TOKEN_TTL_SECS: "60"

        TOKEN_OPEN_TIMEOUT_SECS: 1

        TOKEN_READ_TIMEOUT_SECS: 1

        def self.imds_token: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Utilization
      class PCF < Vendor
        def detect: () -> untyped

        def pcf_keys_present?: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Utilization
      class Azure < Vendor
      end
    end
  end
end

module NewRelic
  module Agent
    module Utilization
      class Vendor
        def self.vendor_name: (?untyped? vendor_name) -> untyped

        def self.endpoint: (?untyped? endpoint) -> untyped

        def self.headers: (?untyped? headers) -> untyped

        def self.keys: (?untyped? keys) -> untyped

        def self.key_transforms: (?untyped? key_transforms) -> untyped

        def self.processed_headers: () -> (nil | untyped)

        attr_reader metadata: untyped

        def initialize: () -> void

        SUCCESS: "200"

        def detect: () -> (false | untyped)

        private

        def request_metadata: () -> untyped

        def prepare_response: (untyped response) -> untyped

        def process_response: (untyped response) -> (false | true)

        def normalize: (untyped value) -> (nil | untyped)

        def valid_length?: (untyped value) -> untyped

        VALID_CHARS: ::Regexp

        def valid_chars?: (untyped value) -> (false | true)

        def transform_key: (untyped key) -> untyped

        def record_supportability_metric: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    # A worker loop executes a set of registered tasks on a single thread.
    # A task is a proc or block with a specified call period in seconds.
    class WorkerLoop
      attr_accessor period: untyped

      attr_accessor propagate_errors: untyped

      attr_reader iterations: untyped

      # Optional argument :duration (in seconds) for how long the worker loop runs
      # or :limit (integer) for max number of iterations
      def initialize: (?::Hash[untyped, untyped] opts) -> void

      # Reset state that is changed by running the worker loop
      def setup: (untyped period, untyped task) -> untyped

      # Run infinitely, calling the registered tasks at their specified
      # call periods.  The caller is responsible for creating the thread
      # that runs this worker loop.  This will run the task immediately.
      def run: (?untyped? period) { () -> untyped } -> untyped

      def schedule_next_invocation: () -> untyped

      # a simple accessor for @should_run
      def keep_running?: () -> untyped

      def under_duration?: () -> untyped

      def under_limit?: () -> untyped

      # Sets @should_run to false. Returns false
      def stop: () -> untyped

      # Executes the block given to the worker loop, and handles errors.
      def run_task: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    # This class represents a single transaction (usually mapping to one
    # web request or background job invocation) instrumented by the Ruby agent.
    #
    # @api public
    class Transaction
      include Tracing

      # for nested transactions
      NESTED_TRANSACTION_PREFIX: "Nested/"

      CONTROLLER_PREFIX: "Controller/"

      MIDDLEWARE_PREFIX: "Middleware/Rack/"

      OTHER_TRANSACTION_PREFIX: "OtherTransaction/"

      TASK_PREFIX: ::String

      RAKE_PREFIX: ::String

      MESSAGE_PREFIX: ::String

      RACK_PREFIX: ::String

      SINATRA_PREFIX: ::String

      GRAPE_PREFIX: ::String

      ACTION_CABLE_PREFIX: ::String

      WEB_TRANSACTION_CATEGORIES: ::Array[:web | :controller | :uri | :rack | :sinatra | :grape | :middleware | :action_cable]

      TRANSACTION_NAMING_SOURCES: ::Array[:child | :api]

      MIDDLEWARE_SUMMARY_METRICS: ::Array["Middleware/all"]

      WEB_SUMMARY_METRIC: "HttpDispatcher"

      OTHER_SUMMARY_METRIC: ::String

      QUEUE_TIME_METRIC: "WebFrontend/QueueTime"

      APDEX_S: "S"

      APDEX_T: "T"

      APDEX_F: "F"

      APDEX_ALL_METRIC: "ApdexAll"

      APDEX_METRIC: "Apdex"

      APDEX_OTHER_METRIC: "ApdexOther"

      APDEX_TXN_METRIC_PREFIX: "Apdex/"

      APDEX_OTHER_TXN_METRIC_PREFIX: "ApdexOther/Transaction/"

      JRUBY_CPU_TIME_ERROR: "Error calculating JRuby CPU Time"

      # reference to the transaction state managing this transaction
      attr_accessor state: untyped

      # A Time instance for the start time, never nil
      attr_accessor start_time: untyped

      # A Time instance used for calculating the apdex score, which
      # might end up being @start, or it might be further upstream if
      # we can find a request header for the queue entry time
      attr_accessor apdex_start: untyped

      attr_accessor exceptions: untyped

      attr_accessor filtered_params: untyped

      attr_accessor jruby_cpu_start: untyped

      attr_accessor process_cpu_start: untyped

      attr_accessor http_response_code: untyped

      attr_accessor response_content_length: untyped

      attr_accessor response_content_type: untyped

      attr_accessor parent_span_id: untyped

      attr_reader guid: untyped

      attr_reader metrics: untyped

      attr_reader logs: untyped

      attr_reader gc_start_snapshot: untyped

      attr_reader category: untyped

      attr_reader attributes: untyped

      attr_reader payload: untyped

      attr_reader nesting_max_depth: untyped

      attr_reader segments: untyped

      attr_reader end_time: untyped

      attr_reader duration: untyped

      attr_writer sampled: untyped

      attr_writer priority: untyped

      # Populated with the trace sample once this transaction is completed.
      attr_reader transaction_trace: untyped

      # Fields for tracking synthetics requests
      attr_accessor raw_synthetics_header: untyped

      # Fields for tracking synthetics requests
      attr_accessor synthetics_payload: untyped

      # Return the currently active transaction, or nil.
      def self.tl_current: () -> untyped

      def self.set_default_transaction_name: (untyped partial_name, ?untyped? category) -> untyped

      def self.set_overriding_transaction_name: (untyped partial_name, ?untyped? category) -> (nil | untyped)

      def self.name_from_partial: (untyped partial_name, untyped category) -> ::String

      def self.start_new_transaction: (untyped state, untyped category, untyped options) -> untyped

      def self.nested_transaction_name: (untyped name) -> untyped

      # discards the currently saved transaction information
      def self.abort_transaction!: () -> untyped

      # See NewRelic::Agent.notice_error for options and commentary
      def self.notice_error: (untyped e, ?::Hash[untyped, untyped] options) -> untyped

      def self.recording_web_transaction?: () -> untyped

      def self.apdex_bucket: (untyped duration, untyped failed, untyped apdex_t) -> untyped

      def self.add_agent_attribute: (untyped key, untyped value, untyped default_destinations) -> untyped

      def add_agent_attribute: (untyped key, untyped value, untyped default_destinations) -> untyped

      def self.merge_untrusted_agent_attributes: (untyped attributes, untyped prefix, untyped default_destinations) -> untyped

      def merge_untrusted_agent_attributes: (untyped attributes, untyped prefix, untyped default_destinations) -> untyped

      def initialize: (untyped category, untyped options) -> void

      def distributed_tracer: () -> untyped

      def sampled?: () -> (nil | untyped)

      def trace_id: () -> untyped

      def trace_id=: (untyped value) -> untyped

      def priority: () -> untyped

      def referer: () -> untyped

      def request_path: () -> untyped

      def request_port: () -> untyped

      # This transaction-local hash may be used as temprory storage by
      # instrumentation that needs to pass data from one instrumentation point
      # to another.
      #
      # For example, if both A and B are instrumented, and A calls B
      # but some piece of state needed by the instrumentation at B is only
      # available at A, the instrumentation at A may write into the hash, call
      # through, and then remove the key afterwards, allowing the
      # instrumentation at B to read the value in between.
      #
      # Keys should be symbols, and care should be taken to not generate key
      # names dynamically, and to ensure that keys are removed upon return from
      # the method that creates them.
      #
      def instrumentation_state: () -> untyped

      def overridden_name=: (untyped name) -> untyped

      def default_name=: (untyped name) -> untyped

      def merge_request_parameters: (untyped params) -> untyped

      def set_default_transaction_name: (untyped name, untyped category) -> untyped

      def set_overriding_transaction_name: (untyped name, untyped category) -> untyped

      def log_frozen_name: (untyped name) -> nil

      def influences_transaction_name?: (untyped category) -> untyped

      def best_name: () -> untyped

      # For common interface with Trace
      alias transaction_name best_name

      def promoted_transaction_name: (untyped name) -> untyped

      def freeze_name_and_execute_if_not_ignored: () { () -> untyped } -> untyped

      def name_frozen?: () -> untyped

      def start: () -> (nil | untyped)

      def initial_segment: () -> untyped

      def create_initial_segment: () -> untyped

      def create_segment: (untyped name) -> untyped

      def create_nested_segment: (untyped category, untyped options) -> untyped

      def nest_initial_segment: () -> untyped

      # Call this to ensure that the current transaction trace is not saved
      # To fully ignore all metrics and errors, use ignore! instead.
      def abort_transaction!: () -> untyped

      def summary_metrics: () -> untyped

      def background_summary_metrics: () -> untyped

      def needs_middleware_summary_metrics?: (untyped name) -> untyped

      def finish: () -> untyped

      def user_defined_rules_ignore?: () -> (nil | untyped)

      def commit!: (untyped outermost_node_name) -> untyped

      def assign_segment_dt_attributes: () -> untyped

      def assign_agent_attributes: () -> untyped

      def assign_intrinsics: () -> untyped

      def calculate_gc_time: () -> untyped

      # This method returns transport_duration in seconds. Transport duration
      # is stored in milliseconds on the payload, but it's needed in seconds
      # for metrics and intrinsics.
      def calculate_transport_duration: (untyped distributed_trace_payload) -> (nil | untyped)

      # The summary metrics recorded by this method all end up with a duration
      # equal to the transaction itself, and an exclusive time of zero.
      def record_summary_metrics: (untyped outermost_node_name) -> untyped

      # This event is fired when the transaction is fully completed. The metric
      # values and sampler can't be successfully modified from this event.
      def send_transaction_finished_event: () -> untyped

      def generate_payload: () -> untyped

      def include_guid?: () -> untyped

      def is_synthetics_request?: () -> untyped

      def synthetics_version: () -> (nil | untyped)

      def synthetics_account_id: () -> (nil | untyped)

      def synthetics_resource_id: () -> (nil | untyped)

      def synthetics_job_id: () -> (nil | untyped)

      def synthetics_monitor_id: () -> (nil | untyped)

      def append_apdex_perf_zone: (untyped payload) -> (nil | untyped)

      def append_synthetics_to: (untyped payload) -> (nil | untyped)

      def merge_metrics: () -> untyped

      def record_exceptions: () -> untyped

      def notice_error: (untyped error, ?::Hash[untyped, untyped] options) -> untyped

      def record_transaction_event: () -> untyped

      def record_log_events: () -> untyped

      def queue_time: () -> untyped

      def record_queue_time: () -> untyped

      def had_error_affecting_apdex?: () -> (true | false)

      def apdex_bucket: (untyped duration, untyped current_apdex_t) -> untyped

      def record_apdex: () -> (nil | untyped)

      def record_apdex_metrics: (untyped rollup_metric, untyped transaction_prefix, untyped current_apdex_t) -> (nil | untyped)

      def apdex_t: () -> untyped

      def transaction_specific_apdex_t: () -> untyped

      def threshold: () -> untyped

      def with_database_metric_name: (untyped model, untyped method, ?untyped? product) { () -> untyped } -> untyped

      def add_custom_attributes: (untyped p) -> untyped

      def add_log_event: (untyped event) -> untyped

      def recording_web_transaction?: () -> untyped

      def web_category?: (untyped category) -> untyped

      def similar_category?: (untyped category) -> untyped

      def cpu_burn: () -> untyped

      def normal_cpu_burn: () -> (nil | untyped)

      def jruby_cpu_burn: () -> (nil | untyped)

      def ignore!: () -> untyped

      def ignore?: () -> untyped

      def ignore_apdex!: () -> untyped

      def ignore_apdex?: () -> untyped

      def ignore_enduser!: () -> untyped

      def ignore_enduser?: () -> untyped

      def ignore_trace?: () -> untyped

      private

      def process_cpu: () -> (nil | untyped)

      def jruby_cpu_time: () -> untyped

      def agent: () -> untyped

      def transaction_sampler: () -> untyped

      def sql_sampler: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    # This module contains helper methods related to decorating log messages
    module LocalLogDecorator
      extend ::NewRelic::Agent::LocalLogDecorator

      def decorate: (untyped message) -> untyped

      private

      def decorating_enabled?: () -> untyped

      def escape_entity_name: (untyped entity_name) -> (nil | untyped)
    end
  end
end

module NewRelic
  module Agent
    class EventBuffer
      attr_reader capacity: untyped

      def initialize: (untyped capacity) -> void

      def reset!: () -> untyped

      def capacity=: (untyped new_capacity) -> untyped

      def append: (untyped x) -> untyped

      def <<: (untyped x) -> untyped

      def full?: () -> untyped

      def size: () -> untyped

      def note_dropped: () -> untyped

      def num_seen: () -> untyped

      def num_dropped: () -> untyped

      def sample_rate: () -> untyped

      def to_a: () -> untyped

      def metadata: () -> { capacity: untyped, captured: untyped, seen: untyped }
    end
  end
end

module NewRelic
  module Agent
    class PipeService
      attr_reader channel_id: untyped

      attr_reader buffer: untyped

      attr_reader pipe: untyped

      attr_accessor request_timeout: untyped

      attr_accessor agent_id: untyped

      attr_accessor collector: untyped

      def initialize: (untyped channel_id) -> void

      def connect: (untyped config) -> nil

      def get_agent_commands: () -> ::Array[untyped]

      def analytic_event_data: (untyped events) -> untyped

      def custom_event_data: (untyped events) -> untyped

      def metric_data: (untyped unsent_timeslice_data) -> ::Hash[untyped, untyped]

      def transaction_sample_data: (untyped transactions) -> untyped

      def error_data: (untyped errors) -> untyped

      def error_event_data: (untyped events) -> untyped

      def span_event_data: (untyped events) -> untyped

      def sql_trace_data: (untyped sql) -> untyped

      def log_event_data: (untyped logs) -> untyped

      def shutdown: () -> untyped

      # Invokes the block it is passed.  This is used to implement HTTP
      # keep-alive in the NewRelicService, and is a required interface for any
      # Service class.
      def session: () { () -> untyped } -> untyped

      private

      def marshal_payload: (untyped data) -> untyped

      def write_to_pipe: (untyped endpoint, untyped data) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Samplers
      # This sampler records the status of your delayed job table once a minute.
      # It assumes jobs are cleared after being run, and failed jobs are not (otherwise
      # the failed job metric is useless).
      #
      # In earlier versions it will break out the queue length by priority.  In later
      # versions of DJ where distinct queues are supported, it breaks it out by queue name.
      #
      class DelayedJobSampler < NewRelic::Agent::Sampler
        # DelayedJob supports multiple backends, only some of which we can
        # handle. Check whether we think we've got what we need here.
        def self.supported_backend?: () -> untyped

        def initialize: () -> void

        def record_failed_jobs: (untyped value) -> untyped

        def record_locked_jobs: (untyped value) -> untyped

        FAILED_QUERY: "failed_at is not NULL"

        LOCKED_QUERY: "locked_by is not NULL"

        def failed_jobs: () -> untyped

        def locked_jobs: () -> untyped

        def count: (untyped query) -> untyped

        def self.supported_on_this_platform?: () -> untyped

        def poll: () -> untyped

        private

        def record_queue_length_metrics: () -> untyped

        QUEUE_QUERY_CONDITION: "run_at <= ? and failed_at is NULL"

        def record_counts_by: (untyped column_name, ?untyped metric_node) -> untyped

        def queue_counts: (untyped column_name) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Samplers
      class VMSampler < Sampler
        GC_RUNS_METRIC: "RubyVM/GC/runs"

        HEAP_LIVE_METRIC: "RubyVM/GC/heap_live"

        HEAP_FREE_METRIC: "RubyVM/GC/heap_free"

        THREAD_COUNT_METRIC: "RubyVM/Threads/all"

        OBJECT_ALLOCATIONS_METRIC: "RubyVM/GC/total_allocated_object"

        MAJOR_GC_METRIC: "RubyVM/GC/major_gc_count"

        MINOR_GC_METRIC: "RubyVM/GC/minor_gc_count"

        METHOD_INVALIDATIONS_METRIC: "RubyVM/CacheInvalidations/method"

        CONSTANT_INVALIDATIONS_METRIC: "RubyVM/CacheInvalidations/constant"

        attr_reader transaction_count: untyped

        def initialize: () -> void

        def take_snapshot: () -> untyped

        def setup_events: (untyped event_listener) -> untyped

        def on_transaction_finished: (*untyped _) -> untyped

        def reset_transaction_count: () -> untyped

        def record_gc_runs_metric: (untyped snapshot, untyped txn_count) -> untyped

        def record_delta: (untyped snapshot, untyped key, untyped metric, untyped txn_count) -> untyped

        def record_gauge_metric: (untyped metric_name, untyped value) -> untyped

        def record_heap_live_metric: (untyped snapshot) -> untyped

        def record_heap_free_metric: (untyped snapshot) -> untyped

        def record_thread_count_metric: (untyped snapshot) -> untyped

        def poll: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Samplers
      class CpuSampler < NewRelic::Agent::Sampler
        attr_reader last_time: untyped

        def initialize: () -> void

        def record_user_util: (untyped value) -> untyped

        def record_system_util: (untyped value) -> untyped

        def record_usertime: (untyped value) -> untyped

        def record_systemtime: (untyped value) -> untyped

        def self.supported_on_this_platform?: () -> (untyped | true)

        def poll: () -> (nil | untyped)
      end
    end
  end
end

module NewRelic
  module Agent
    module Samplers
      class ObjectSampler < NewRelic::Agent::Sampler
        def self.supported_on_this_platform?: () -> untyped

        def poll: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Samplers
      class MemorySampler < NewRelic::Agent::Sampler
        attr_accessor sampler: untyped

        def initialize: () -> void

        def self.supported_on_this_platform?: () -> untyped

        def self.platform: () -> untyped

        def platform: () -> untyped

        def poll: () -> untyped

        class Base
          def initialize: () -> void

          def can_run?: () -> (false | untyped)

          def get_sample: () -> (nil | untyped)
        end

        class JavaHeapSampler < Base
          def get_memory: () -> untyped

          def to_s: () -> "JRuby Java heap sampler"
        end

        class ShellPS < Base
          def initialize: (untyped command) -> void

          # Returns the amount of resident memory this process is using in MB
          #
          def get_memory: () -> untyped

          def to_s: () -> ::String
        end

        # ProcStatus
        #
        # A class that samples memory by reading the file /proc/$$/status, which is specific to linux
        #
        class ProcStatus < Base
          # Returns the amount of resident memory this process is using in MB
          def get_memory: () -> untyped

          def proc_status_file: () -> ::String

          def to_s: () -> ::String
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module VM
      def self.snapshot: () -> untyped

      def self.vm: () -> untyped

      def self.create_vm: () -> untyped
    end
  end
end

module NewRelic
  # columns for a mysql explain plan
  MYSQL_EXPLAIN_COLUMNS: ::Array["Id" | "Select Type" | "Table" | "Type" | "Possible Keys" | "Key" | "Key Length" | "Ref" | "Rows" | "Extra"]

  module Agent
    module Database
      MAX_QUERY_LENGTH: 16384

      ELLIPSIS: "..."

      extend ::NewRelic::Agent::Database

      # Properly encode, truncate, and dup the incoming query.
      # Take care not to the dup the query more than once as
      # correctly encoded may also dup the query.
      def capture_query: (untyped query) -> untyped

      def truncate_query: (untyped query) -> untyped

      def obfuscate_sql: (untyped sql) -> untyped

      def set_sql_obfuscator: (untyped `type`) { () -> untyped } -> untyped

      def record_sql_method: (?::Symbol config_section) -> untyped

      def record_sql_method_key: (untyped config_section) -> untyped

      RECORD_FOR: ::Array[:raw | :obfuscated]

      def should_record_sql?: (?::Symbol config_section) -> untyped

      def should_collect_explain_plans?: (?::Symbol config_section) -> untyped

      def get_connection: (untyped config) { () -> untyped } -> untyped

      def close_connections: () -> untyped

      # Perform this in the runtime environment of a managed
      # application, to explain the sql statement executed within a
      # node of a transaction sample. Returns an array of two arrays.
      # The first array contains the headers, while the second consists of
      # arrays of strings for each column returned by the explain query.
      # Note this happens only for statements whose execution time exceeds
      # a threshold (e.g. 500ms) and only within the slowest transaction
      # in a report period, selected for shipment to New Relic
      def explain_sql: (untyped statement) -> (nil | untyped)

      KNOWN_OPERATIONS: ::Array["alter" | "select" | "update" | "delete" | "insert" | "create" | "show" | "set" | "exec" | "execute" | "call"]

      SQL_COMMENT_REGEX: untyped

      def parse_operation_from_query: (untyped sql) -> untyped

      class ConnectionManager
        include Singleton

        # Returns a cached connection for a given ActiveRecord
        # configuration - these are stored or reopened as needed, and if
        # we cannot get one, we ignore it and move on without explaining
        # the sql
        def get_connection: (untyped config) { () -> untyped } -> untyped

        # Closes all the connections in the internal connection cache
        def close_connections: () -> untyped
      end

      class Statement
        include ExplainPlanHelpers

        attr_accessor sql: untyped

        attr_accessor config: untyped

        attr_accessor explainer: untyped

        attr_accessor binds: untyped

        attr_accessor name: untyped

        attr_accessor host: untyped

        attr_accessor port_path_or_id: untyped

        attr_accessor database_name: untyped

        DEFAULT_QUERY_NAME: "SQL"

        def initialize: (untyped sql, ?::Hash[untyped, untyped] config, ?untyped? explainer, ?untyped? binds, ?untyped name, ?untyped? host, ?untyped? port_path_or_id, ?untyped? database_name) -> void

        # Returns an sql statement that will be in the form most permissable by
        # the config. The format will be safe for transmission to New Relic.
        def safe_sql: () -> untyped

        # This takes a connection config hash from ActiveRecord or Sequel and
        # returns a symbol describing the associated database adapter
        def adapter: () -> (nil | untyped)

        def explain: () -> (nil | untyped)

        NEWLINE: ::String

        def append_sql: (untyped new_sql) -> (nil | untyped)

        private

        POSTGIS_PREFIX: "postgis"

        POSTGRES_PREFIX: "postgres"

        MYSQL_PREFIX: "mysql"

        MYSQL2_PREFIX: "mysql2"

        SQLITE_PREFIX: "sqlite"

        def symbolized_adapter: (untyped adapter) -> untyped

        def explainable?: () -> (false | true)
      end
    end
  end
end

module NewRelic
  module Agent
    module RangeExtensions
      def self?.intersects?: (untyped r1, untyped r2) -> untyped

      def self?.merge: (untyped r1, untyped r2) -> (nil | ::Range[untyped])

      # Takes an array of ranges and a range which it will
      # merge into an existing range if they intersect, otherwise
      # it will append this range to the end the array.
      def self?.merge_or_append: (untyped range, untyped ranges) -> untyped

      # Computes the amount of overlap between range and an array of ranges.
      # For efficiency, it assumes that range intersects with each of the
      # ranges in the ranges array.
      def self?.compute_overlap: (untyped range, untyped ranges) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class SyntheticsEventAggregator < EventAggregator
      TIMESTAMP: "timestamp"

      def record: (untyped event) -> (nil | untyped)

      private

      def after_harvest: (untyped metadata) -> untyped

      def record_dropped_synthetics: (untyped metadata) -> (nil | untyped)
    end
  end
end

module NewRelic
  module Agent
    module DistributedTraceAttributes
      extend ::NewRelic::Agent::DistributedTraceAttributes

      # Intrinsic Keys
      INTRINSIC_KEYS: ::Array[untyped]

      # This method extracts intrinsics from the transaction_payload and
      # inserts them into the specified destination.
      def copy_to_hash: (untyped transaction_payload, untyped destination) -> (nil | untyped)

      # This method extracts intrinsics from the transaction_payload and
      # inserts them as intrinsics in the specified transaction_attributes
      def copy_to_attributes: (untyped transaction_payload, untyped destination) -> (nil | untyped)

      # This method takes all distributed tracing intrinsics from the transaction
      # and the trace_payload, and populates them into the destination
      def copy_from_transaction: (untyped transaction, untyped trace_payload, untyped destination) -> untyped

      def copy_parent_attributes: (untyped transaction, untyped trace_payload, untyped destination) -> untyped

      private

      def enabled?: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    module CrossAppTracing
      # The cross app response header for "outgoing" calls
      NR_APPDATA_HEADER: "X-NewRelic-App-Data"

      # The cross app id header for "outgoing" calls
      NR_ID_HEADER: "X-NewRelic-ID"

      # The cross app transaction header for "outgoing" calls
      NR_TXN_HEADER: "X-NewRelic-Transaction"

      NR_MESSAGE_BROKER_ID_HEADER: "NewRelicID"

      NR_MESSAGE_BROKER_TXN_HEADER: "NewRelicTransaction"

      NR_MESSAGE_BROKER_SYNTHETICS_HEADER: "NewRelicSynthetics"

      attr_accessor is_cross_app_caller: untyped

      attr_accessor cross_app_payload: untyped

      attr_accessor cat_path_hashes: untyped

      def is_cross_app_caller?: () -> untyped

      def is_cross_app_callee?: () -> untyped

      def is_cross_app?: () -> untyped

      def cat_trip_id: () -> untyped

      def cross_app_monitor: () -> untyped

      def cat_path_hash: () -> untyped

      def insert_cross_app_header: (untyped headers) -> (nil | untyped)

      def add_message_cat_headers: (untyped headers) -> (nil | untyped)

      def record_cross_app_metrics: () -> untyped

      def assign_cross_app_intrinsics: () -> untyped

      private

      def insert_message_headers: (untyped headers, untyped txn_guid, untyped trip_id, untyped path_hash, untyped synthetics_header) -> untyped

      def record_cat_path_hash: (untyped hash) -> untyped

      def cat_referring_path_hash: () -> untyped

      def append_cat_info: (untyped payload) -> (nil | untyped)

      def self?.cross_app_enabled?: () -> untyped

      def self?.valid_cross_process_id?: () -> untyped

      def self?.valid_encoding_key?: () -> untyped

      def self?.cross_application_tracer_enabled?: () -> untyped

      def self?.obfuscator: () -> untyped

      def self?.insert_request_headers: (untyped request, untyped txn_guid, untyped trip_id, untyped path_hash) -> untyped

      def self?.response_has_crossapp_header?: (untyped response) -> untyped

      # Extract x-process application data from the specified +response+ and return
      # it as an array of the form:
      #
      #  [
      #    <cross app ID>,
      #    <transaction name>,
      #    <queue time in seconds>,
      #    <response time in seconds>,
      #    <request content length in bytes>,
      #    <transaction GUID>
      #  ]
      def self?.extract_appdata: (untyped response) -> untyped

      def self?.valid_cross_app_id?: (untyped xp_id) -> untyped

      def self?.message_has_crossapp_request_header?: (untyped headers) -> untyped

      def self?.reject_messaging_cat_headers: (untyped headers) -> untyped

      def self?.trusts?: (untyped id) -> (false | untyped)

      def self?.trusted_valid_cross_app_id?: (untyped id) -> untyped

      # From inbound request headers
      def self?.assign_intrinsic_transaction_attributes: (untyped state) -> (nil | untyped)
    end
  end
end

module NewRelic
  module Agent
    module DistributedTraceTransportType
      extend ::NewRelic::Agent::DistributedTraceTransportType

      ALLOWABLE_TRANSPORT_TYPES: ::Array[untyped | "Kafka" | "JMS" | "IronMQ" | "AMQP" | "Queue" | "Other"]

      URL_SCHEMES: ::Hash[::String, untyped]

      RACK_URL_SCHEME: "rack.url_scheme"

      def from: (untyped value) -> untyped

      def for_rack_request: (untyped request) -> untyped
    end
  end
end

module NewRelic
  module Agent
    #
    # This class contains properties related to distributed traces.
    # To obtain an instance, call
    # {DistributedTracing#create_distributed_trace_payload}
    #
    # @api public
    class DistributedTracePayload
      extend Coerce

      VERSION: ::Array[0 | 1]

      PARENT_TYPE: "App"

      POUND: "#"

      # Key names for serialization
      VERSION_KEY: "v"

      DATA_KEY: "d"

      PARENT_TYPE_KEY: "ty"

      PARENT_ACCOUNT_ID_KEY: "ac"

      PARENT_APP_KEY: "ap"

      TRUSTED_ACCOUNT_KEY: "tk"

      ID_KEY: "id"

      TX_KEY: "tx"

      TRACE_ID_KEY: "tr"

      SAMPLED_KEY: "sa"

      TIMESTAMP_KEY: "ti"

      PRIORITY_KEY: "pr"

      def self.for_transaction: (untyped transaction) -> (nil | untyped)

      def self.from_json: (untyped serialized_payload) -> untyped

      def self.from_http_safe: (untyped http_safe_payload) -> untyped

      def self.major_version_matches?: (untyped payload) -> untyped

      private

      def self.assign_trusted_account_key: (untyped payload, untyped account_id) -> untyped

      def self.current_segment_id: (untyped transaction) -> untyped

      def self.connected?: () -> untyped

      public

      attr_accessor version: untyped

      attr_accessor parent_type: untyped

      attr_accessor parent_account_id: untyped

      attr_accessor parent_app_id: untyped

      attr_accessor trusted_account_key: untyped

      attr_accessor id: untyped

      attr_accessor transaction_id: untyped

      attr_accessor trace_id: untyped

      attr_accessor sampled: untyped

      attr_accessor priority: untyped

      attr_accessor timestamp: untyped

      alias sampled? sampled

      # Represent this payload as a raw JSON string.
      #
      # @return [String] Payload translated to JSON
      #
      # @api public
      def text: () -> untyped

      # Encode this payload as a string suitable for passing via an
      # HTTP header.
      #
      # @return [String] Payload translated to JSON and encoded for
      #                  inclusion in headers
      #
      # @api public
      def http_safe: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class TraceContextPayload
      VERSION: 0

      PARENT_TYPE: 0

      DELIMITER: "-"

      SUPPORTABILITY_PARSE_EXCEPTION: "Supportability/TraceContext/Parse/Exception"

      TRUE_CHAR: "1"

      FALSE_CHAR: "0"

      PARENT_TYPES: untyped

      def self.create: (?version: untyped version, ?parent_type: untyped parent_type, ?parent_account_id: untyped? parent_account_id, ?parent_app_id: untyped? parent_app_id, ?id: untyped? id, ?transaction_id: untyped? transaction_id, ?sampled: untyped? sampled, ?priority: untyped? priority, ?timestamp: untyped timestamp) -> untyped

      include NewRelic::Coerce

      def self.from_s: (untyped payload_string) -> untyped

      private

      def self.now_ms: () -> untyped

      def self.handle_invalid_payload: (?error: untyped? error, ?message: untyped? message) -> untyped

      public

      attr_accessor version: untyped

      attr_accessor parent_type_id: untyped

      attr_accessor parent_account_id: untyped

      attr_accessor parent_app_id: untyped

      attr_accessor id: untyped

      attr_accessor transaction_id: untyped

      attr_accessor sampled: untyped

      attr_accessor priority: untyped

      attr_accessor timestamp: untyped

      alias sampled? sampled

      def initialize: (untyped version, untyped parent_type_id, untyped parent_account_id, untyped parent_app_id, untyped id, untyped transaction_id, untyped sampled, untyped priority, untyped timestamp) -> void

      def parent_type: () -> untyped

      def valid?: () -> untyped

      def to_s: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class CrossAppPayload
      attr_reader id: untyped

      attr_reader transaction: untyped

      attr_reader referring_guid: untyped

      attr_reader referring_trip_id: untyped

      attr_reader referring_path_hash: untyped

      def initialize: (untyped id, untyped transaction, untyped transaction_info) -> void

      def as_json_array: (untyped content_length) -> ::Array[untyped | false]

      private

      def string_or_false_for: (untyped value) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module DistributedTracing
      class TraceContext
        VERSION: 0

        COMMA: ","

        EQUALS: "="

        INVALID_TRACE_ID: untyped

        INVALID_PARENT_ID: untyped

        INVALID_VERSION: "ff"

        TRACE_ID_KEY: "trace_id"

        TRACE_FLAGS_KEY: "trace_flags"

        PARENT_ID_KEY: "parent_id"

        VERSION_KEY: "version"

        UNDEFINED_FIELDS_KEY: "undefined_fields"

        TP_VERSION: ::String

        TP_TRACE_ID: ::String

        TP_PARENT_ID: ::String

        TP_TRACE_FLAGS: ::String

        TP_UNDEFINED_FIELDS: ::String

        TRACE_PARENT_REGEX: ::Regexp

        TRACE_PARENT_FORMAT_STRING: "%02x-%s-%s-%02x"

        MAX_TRACE_STATE_SIZE: 512

        MAX_TRACE_STATE_ENTRY_SIZE: 128

        SUPPORTABILITY_TRACE_PARENT_PARSE_EXCEPTION: "Supportability/TraceContext/TraceParent/Parse/Exception"

        SUPPORTABILITY_TRACE_STATE_PARSE_EXCEPTION: "Supportability/TraceContext/TraceState/Parse/Exception"

        SUPPORTABILITY_TRACE_STATE_INVALID_NR_ENTRY: "Supportability/TraceContext/TraceState/InvalidNrEntry"

        def self.insert: (?format: untyped format, ?carrier: untyped? carrier, ?parent_id: untyped? parent_id, ?trace_id: untyped? trace_id, ?trace_flags: untyped? trace_flags, ?trace_state: untyped? trace_state) -> untyped

        def self.parse: (?format: untyped format, ?carrier: untyped? carrier, ?trace_state_entry_key: untyped? trace_state_entry_key) -> (nil | untyped)

        def self.create_trace_state_entry: (untyped entry_key, untyped payload) -> ::String

        private

        def self.format_trace_parent: (?trace_id: untyped? trace_id, ?parent_id: untyped? parent_id, ?trace_flags: untyped? trace_flags) -> untyped

        def self.extract_traceparent: (untyped format, untyped carrier) -> (nil | untyped)

        def self.trace_parent_valid?: (untyped trace_parent) -> (false | true)

        def self.trace_parent_header_for_format: (untyped format) -> untyped

        def self.trace_state_header_for_format: (untyped format) -> untyped

        def self.extract_tracestate: (untyped format, untyped carrier, untyped trace_state_entry_key) -> untyped

        def self.decode_payload: (untyped payload) -> untyped

        public

        class HeaderData
          def self.create: (?trace_parent: untyped? trace_parent, ?trace_state_payload: untyped? trace_state_payload, ?trace_state_entries: untyped? trace_state_entries, ?trace_state_size: ::Integer trace_state_size, ?trace_state_vendors: untyped? trace_state_vendors) -> untyped

          def initialize: (untyped trace_parent, untyped trace_state_payload, untyped trace_state_entries, untyped trace_state_size, untyped trace_state_vendors) -> void

          attr_accessor trace_parent: untyped

          attr_accessor trace_state_payload: untyped

          attr_accessor trace_state_vendors: untyped

          def trace_state: (untyped trace_state_entry) -> untyped

          def trace_id: () -> untyped

          def parent_id: () -> untyped

          private

          def join_trace_state: (untyped trace_state_entry_size) -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    module DistributedTraceMetrics
      extend ::NewRelic::Agent::DistributedTraceMetrics

      ALL_SUFFIX: "all"

      ALL_WEB_SUFFIX: "allWeb"

      ALL_OTHER_SUFFIX: "allOther"

      UNKNOWN_CALLER_PREFIX: "%s/Unknown/Unknown/Unknown/%s"

      def transaction_type_suffix: () -> untyped

      def record_metrics_for_transaction: (untyped transaction) -> (nil | untyped)

      def prefix_for_metric: (untyped name, untyped transaction, untyped payload) -> untyped

      def record_caller_by_duration_metrics: (untyped transaction, untyped payload) -> untyped

      def record_transport_duration_metrics: (untyped transaction, untyped payload) -> (nil | untyped)

      def record_errors_by_caller_metrics: (untyped transaction, untyped payload) -> (nil | untyped)

      private

      def record_unscoped_metric: (untyped transaction, untyped prefix, untyped duration) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class AttributeFilter
      DST_NONE: 0

      DST_TRANSACTION_EVENTS: untyped

      DST_TRANSACTION_TRACER: untyped

      DST_ERROR_COLLECTOR: untyped

      DST_BROWSER_MONITORING: untyped

      DST_SPAN_EVENTS: untyped

      DST_TRANSACTION_SEGMENTS: untyped

      DST_ALL: 63

      attr_reader rules: untyped

      def initialize: (untyped config) -> void

      def setup_key_cache: () -> untyped

      def include_destinations_for_capture_params: (untyped capturing) -> untyped

      def build_rule: (untyped attribute_names, untyped destinations, untyped is_include) -> untyped

      def build_uri_rule: (untyped excluded_attributes) -> untyped

      def apply: (untyped attribute_name, untyped default_destinations) -> untyped

      def allows?: (untyped allowed_destinations, untyped requested_destination) -> untyped

      def allows_key?: (untyped key, untyped destination) -> (false | untyped)

      def high_security?: () -> untyped

      # For attribute prefixes where we know the default destinations will
      # always be DST_NONE, we can statically determine that any attribute
      # starting with the prefix will not be allowed unless there's an include
      # rule that might match attributes starting with it.
      #
      # This allows us to skip significant preprocessing work (hash/array
      # flattening and type coercion) for HTTP request parameters and job
      # arguments for Sidekiq and Resque in the common case, since none of
      # these attributes are captured by default.
      #
      def cache_prefix_denylist: () -> untyped

      # Note that the given prefix *must* be a Symbol
      def might_allow_prefix?: (untyped prefix) -> untyped

      def might_allow_prefix_uncached?: (untyped prefix) -> untyped
    end

    class AttributeFilterRule
      attr_reader attribute_name: untyped

      attr_reader destinations: untyped

      attr_reader is_include: untyped

      attr_reader wildcard: untyped

      def initialize: (untyped attribute_name, untyped destinations, untyped is_include) -> void

      # Rules are sorted from least specific to most specific
      #
      # All else being the same, wildcards are considered less specific
      # All else being the same, include rules are less specific than excludes
      def <=>: (untyped other) -> (untyped | 0)

      def match?: (untyped name) -> untyped

      def empty?: () -> untyped
    end
  end
end

# Stateless calculation of priority for a given log event
module NewRelic
  module Agent
    module LogPriority
      extend ::NewRelic::Agent::LogPriority

      def priority_for: (untyped txn) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Commands
      class AgentCommandRouter
        attr_reader handlers: untyped

        attr_accessor thread_profiler_session: untyped

        attr_accessor backtrace_service: untyped

        def initialize: (?untyped? event_listener) -> void

        def new_relic_service: () -> untyped

        def check_for_and_handle_agent_commands: () -> untyped

        def on_before_shutdown: (*untyped args) -> untyped

        def harvest!: () -> untyped

        # We don't currently support merging thread profiles that failed to send
        # back into the AgentCommandRouter, so we just no-op this method.
        # Same with reset! - we don't support asynchronous cancellation of a
        # running thread profile currently.
        def merge!: (*untyped args) -> nil

        def reset!: () -> nil

        def harvest_from_thread_profiler_session: () -> untyped

        def log_profiles: (untyped profiles) -> untyped

        def get_agent_commands: () -> untyped

        def invoke_commands: (untyped agent_commands) -> untyped

        class AgentCommandError < StandardError
        end

        def invoke_command: (untyped agent_command) -> untyped

        SUCCESS_RESULT: ::Hash[untyped, untyped]

        ERROR_KEY: "error"

        def success: () -> untyped

        def error: (untyped err) -> ::Hash[untyped, untyped]

        def call_handler_for: (untyped agent_command) -> untyped

        def select_handler: (untyped agent_command) -> untyped

        def unrecognized_agent_command: (untyped agent_command) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Commands
      class ThreadProfilerSession
        def initialize: (untyped backtrace_service) -> void

        def handle_start_command: (untyped agent_command) -> untyped

        def handle_stop_command: (untyped agent_command) -> untyped

        def start: (untyped agent_command) -> untyped

        def stop: (untyped report_data) -> (nil | untyped)

        def harvest: () -> untyped

        def enabled?: () -> untyped

        def running?: () -> untyped

        def ready_to_harvest?: () -> untyped

        def past_time?: () -> untyped

        def stopped?: () -> untyped

        private

        def raise_command_error: (untyped msg) -> untyped

        def raise_unsupported_error: () -> untyped

        def raise_thread_profiler_disabled: () -> untyped

        def raise_already_started_error: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Commands
      class AgentCommand
        attr_reader id: untyped

        attr_reader name: untyped

        attr_reader arguments: untyped

        def initialize: (untyped raw_collector_command) -> void
      end
    end
  end
end

module NewRelic
  module Agent
    class ErrorEventAggregator < EventAggregator
      include NewRelic::Coerce

      def record: (untyped noticed_error, ?untyped? transaction_payload, ?untyped? span_id) -> (nil | untyped)

      private

      def create_event: (untyped noticed_error, untyped transaction_payload, untyped span_id) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module PayloadMetricMapping
      SPEC_MAPPINGS: ::Hash[untyped, untyped]

      def self.append_mapped_metrics: (untyped txn_metrics, untyped sample) -> untyped

      private

      def self.map_metric: (untyped metric_name, ?::Hash[untyped, untyped] to_add) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module TransactionErrorPrimitive
      extend ::NewRelic::Agent::TransactionErrorPrimitive

      SAMPLE_TYPE: "TransactionError"

      TYPE_KEY: "type"

      ERROR_CLASS_KEY: "error.class"

      ERROR_MESSAGE_KEY: "error.message"

      ERROR_EXPECTED_KEY: "error.expected"

      TIMESTAMP_KEY: "timestamp"

      PORT_KEY: "port"

      NAME_KEY: "transactionName"

      DURATION_KEY: "duration"

      SAMPLED_KEY: "sampled"

      GUID_KEY: "nr.transactionGuid"

      REFERRING_TRANSACTION_GUID_KEY: "nr.referringTransactionGuid"

      SYNTHETICS_RESOURCE_ID_KEY: "nr.syntheticsResourceId"

      SYNTHETICS_JOB_ID_KEY: "nr.syntheticsJobId"

      SYNTHETICS_MONITOR_ID_KEY: "nr.syntheticsMonitorId"

      PRIORITY_KEY: "priority"

      SPAN_ID_KEY: "spanId"

      def create: (untyped noticed_error, untyped payload, untyped span_id) -> ::Array[untyped]

      def intrinsic_attributes_for: (untyped noticed_error, untyped payload, untyped span_id) -> untyped

      def append_synthetics: (untyped payload, untyped sample) -> untyped

      def append_cat: (untyped payload, untyped sample) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class Heap
      # @param [Array] items an optional array of items to intialize the heap
      #
      # @param [Callable] priority_fn an optional priority function used to
      #   to compute the priority for an item. If it's not supplied priority
      #   will be computed using Comparable.
      def initialize: (?untyped? items) { () -> untyped } -> void

      def []: (untyped index) -> untyped

      def []=: (untyped index, untyped value) -> untyped

      def fix: (untyped index) -> (nil | untyped)

      def push: (untyped item) -> untyped

      alias << push

      def pop: () -> untyped

      def size: () -> untyped

      def empty?: () -> untyped

      def to_a: () -> untyped

      private

      def priority: (untyped index) -> untyped

      def parent_index_for: (untyped child_index) -> untyped

      def left_child_index_for: (untyped parent_index) -> untyped

      def right_sibling_smaller?: (untyped lchild_index) -> untyped

      def in_range?: (untyped index) -> untyped

      def heapify_up: (untyped child_index) -> (nil | untyped)

      def heapify_down: (untyped parent_index) -> (nil | untyped)

      def swap: (untyped i, untyped j) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class TransactionMetrics
      DEFAULT_PROC: untyped

      def initialize: () -> void

      # As a general rule, when recording a scoped metric, the corresponding
      # unscoped metric should always be recorded as well.
      #
      # As an optimization, scoped metrics are representated within this class
      # only by their entries in the @scoped Hash, and it's up to clients to
      # propagate them into unscoped metrics as well when instances of this
      # class are merged into the global metric store.
      #
      def record_scoped_and_unscoped: (untyped names, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      def record_unscoped: (untyped names, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      def has_key?: (untyped key) -> untyped

      def []: (untyped key) -> untyped

      def each_unscoped: () { (untyped, untyped) -> untyped } -> untyped

      def each_scoped: () { (untyped, untyped) -> untyped } -> untyped

      def _record_metrics: (untyped names, untyped value, untyped aux, untyped target) { () -> untyped } -> untyped
    end
  end
end

module NewRelic
  module Agent
    class NewRelicService
      PROTOCOL_VERSION: 17

      # These include Errno connection errors, and all indicate that the
      # underlying TCP connection may be in a bad state.
      CONNECTION_ERRORS: ::Array[untyped]

      attr_accessor request_timeout: untyped

      attr_reader collector: untyped

      attr_reader marshaller: untyped

      attr_reader agent_id: untyped

      def initialize: (?untyped? license_key, ?untyped collector) -> void

      def agent_id=: (untyped id) -> untyped

      def connect: (?::Hash[untyped, untyped] settings) -> untyped

      def preconnect: () -> untyped

      def shutdown: (untyped time) -> untyped

      def force_restart: () -> untyped

      # The collector wants to receive metric data in a format that's different
      # from how we store it internally, so this method handles the translation.
      def build_metric_data_array: (untyped stats_hash) -> untyped

      def metric_data: (untyped stats_hash) -> untyped

      def error_data: (untyped unsent_errors) -> untyped

      def transaction_sample_data: (untyped traces) -> untyped

      def sql_trace_data: (untyped sql_traces) -> untyped

      def profile_data: (untyped profile) -> untyped

      def get_agent_commands: () -> untyped

      def agent_command_results: (untyped results) -> untyped

      def analytic_event_data: (untyped data) -> untyped

      def custom_event_data: (untyped data) -> untyped

      def log_event_data: (untyped data) -> untyped

      def error_event_data: (untyped data) -> untyped

      def span_event_data: (untyped data) -> untyped

      # We do not compress if content is smaller than 64kb.  There are
      # problems with bugs in Ruby in some versions that expose us
      # to a risk of segfaults if we compress aggressively.
      def compress_request_if_needed: (untyped data, untyped endpoint) -> ::Array[untyped]

      # One session with the service's endpoint.  In this case the session
      # represents 1 tcp connection which may transmit multiple HTTP requests
      # via keep-alive.
      def session: () { () -> untyped } -> untyped

      def session_with_keepalive: () { () -> untyped } -> untyped

      def session_without_keepalive: () { () -> untyped } -> untyped

      def establish_shared_connection: () -> untyped

      def close_shared_connection: () -> untyped

      def has_shared_connection?: () -> untyped

      def ssl_cert_store: () -> untyped

      # Return a Net::HTTP connection object to make a call to the collector.
      # We'll reuse the same handle for cases where we're using keep-alive, or
      # otherwise create a new one.
      def http_connection: () -> untyped

      def setup_connection_for_ssl: (untyped conn) -> untyped

      def set_cert_store: (untyped conn) -> untyped

      def start_connection: (untyped conn) -> untyped

      def setup_connection_timeouts: (untyped conn) -> untyped

      def create_http_connection: () -> untyped

      def create_and_start_http_connection: () -> untyped

      # The path to the certificate file used to verify the SSL
      # connection if verify_peer is enabled
      def cert_file_path: () -> untyped

      def valid_to_marshal?: (untyped data) -> untyped

      private

      # A shorthand for NewRelic::Control.instance
      def control: () -> untyped

      def remote_method_uri: (untyped method) -> untyped

      def reset_remote_method_uris: () -> untyped

      def generate_remote_method_uri: (untyped method) -> untyped

      def license_key: () -> untyped

      # send a message via post to the actual server. This attempts
      # to automatically compress the data via zlib if it is large
      # enough to be worth compressing, and handles any errors the
      # server may return
      def invoke_remote: (untyped method, ?untyped payload, ?::Hash[untyped, untyped] options) -> untyped

      def handle_serialization_error: (untyped method, untyped e) -> untyped

      def record_timing_supportability_metrics: (untyped method, untyped start_ts, untyped serialize_finish_ts, untyped request_send_ts, untyped response_check_ts) -> untyped

      # For these metrics, we use the following fields:
      # call_count           => number of times this remote method was invoked
      # total_call_time      => total size in bytes of payloads across all invocations
      # total_exclusive_time => total size in items (e.g. unique metrics, traces, events, etc) across all invocations
      #
      # The last field doesn't make sense for all methods (e.g. get_agent_commands),
      # so we omit it for those methods that don't really take collections
      # of items as arguments.
      def record_size_supportability_metrics: (untyped method, untyped size_bytes, untyped item_count) -> untyped

      # Raises an UnrecoverableServerException if the post_string is longer
      # than the limit configured in the control object
      def check_post_size: (untyped post_string, untyped endpoint) -> (nil | untyped)

      # Posts to the specified server
      #
      # Options:
      #  - :uri => the path to request on the server (a misnomer of
      #              course)
      #  - :encoding => the encoding to pass to the server
      #  - :collector => a URI object that responds to the 'name' method
      #                    and returns the name of the collector to
      #                    contact
      #  - :data => the data to send as the body of the request
      def send_request: (untyped opts) -> untyped

      def log_response: (untyped response) -> untyped

      # Per protocol 17, this metric should be recorded for all error response codes
      # that cause data to be discarded.
      def record_error_response_supportability_metrics: (untyped response_code) -> untyped

      def record_endpoint_attempts_supportability_metrics: (untyped endpoint) -> untyped

      # Decompresses the response from the server, if it is gzip
      # encoded, otherwise returns it verbatim
      def decompress_response: (untyped response) -> untyped

      # Sets the user agent for connections to the server, to
      # conform with the HTTP spec and allow for debugging. Includes
      # the ruby version and also zlib version if available since
      # that may cause corrupt compression if there is a problem.
      def user_agent: () -> ::String
    end
  end
end

module NewRelic
  module Agent
    module Threading
      class BacktraceService
        ALL_TRANSACTIONS: "**ALL**"

        def self.is_supported?: () -> untyped

        # Because of Resque's forking, we don't poll thread backtraces for it.
        # To accomplish that would require starting a new backtracing thread in
        # each forked worker, and merging profiles across the pipe channel.
        def self.is_resque?: () -> untyped

        attr_reader worker_loop: untyped

        attr_reader buffer: untyped

        attr_reader effective_polling_period: untyped

        attr_reader overhead_percent_threshold: untyped

        attr_accessor worker_thread: untyped

        attr_accessor profile_agent_code: untyped

        def initialize: (?untyped? event_listener) -> void

        def running?: () -> untyped

        def subscribe: (untyped transaction_name, ?::Hash[untyped, untyped] command_arguments) -> (nil | untyped)

        def unsubscribe: (untyped transaction_name) -> (nil | untyped)

        def update_values_from_profiles: () -> untyped

        def subscribed?: (untyped transaction_name) -> untyped

        def harvest: (untyped transaction_name) -> untyped

        def on_transaction_finished: (untyped payload) -> untyped

        # This method is expected to be called with @lock held.
        def aggregate_backtraces: (untyped backtraces, untyped name, untyped start, untyped duration, untyped bucket, untyped thread) -> untyped

        def start: () -> (nil | untyped)

        # This method is expected to be called with @lock held
        def stop: () -> (nil | untyped)

        def effective_polling_period=: (untyped new_period) -> untyped

        def poll: () -> untyped

        # This method is expected to be called with @lock held.
        attr_reader profiles: untyped

        # This method is expected to be called with @lock held.
        def should_buffer?: (untyped bucket) -> untyped

        # This method is expected to be called with @lock held.
        def need_backtrace?: (untyped bucket) -> untyped

        # This method is expected to be called with @lock held
        def watching_for_transaction?: () -> untyped

        def allowed_bucket?: (untyped bucket) -> untyped

        MAX_BUFFER_LENGTH: 500

        # This method is expected to be called with @lock held.
        def buffer_backtrace_for_thread: (untyped thread, untyped timestamp, untyped backtrace, untyped bucket) -> untyped

        # This method is expected to be called with @lock held.
        def aggregate_global_backtrace: (untyped backtrace, untyped bucket, untyped thread) -> untyped

        # This method is expected to be called with @lock held.
        def sample_thread: (untyped thread) -> untyped

        # This method is expected to be called with @lock held.
        def find_effective_polling_period: () -> untyped

        # This method is expected to be called with @lock held.
        def should_profile_agent_code?: () -> untyped

        # If our overhead % exceeds the threshold, bump the next poll period
        # relative to how much larger our overhead is than allowed
        def adjust_polling_time: (untyped now, untyped poll_start) -> untyped

        def record_supportability_metrics: (untyped now, untyped poll_start) -> untyped

        def record_polling_time: (untyped now, untyped poll_start) -> untyped

        def record_skew: (untyped poll_start) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Threading
      class ThreadProfile
        attr_reader profile_id: untyped

        attr_reader traces: untyped

        attr_reader sample_period: untyped

        attr_reader duration: untyped

        attr_reader poll_count: untyped

        attr_reader backtrace_count: untyped

        attr_reader failure_count: untyped

        attr_reader created_at: untyped

        attr_reader command_arguments: untyped

        attr_reader profile_agent_code: untyped

        attr_accessor finished_at: untyped

        def initialize: (?::Hash[untyped, untyped] command_arguments) -> void

        def requested_period: () -> untyped

        def increment_poll_count: () -> untyped

        def empty?: () -> untyped

        def unique_thread_count: () -> (0 | untyped)

        def aggregate: (untyped backtrace, untyped bucket, untyped thread) -> untyped

        def convert_N_trace_nodes_to_arrays: (untyped count_to_keep) -> untyped

        THREAD_PROFILER_NODES: 20000

        include NewRelic::Coerce

        def generate_traces: () -> ::Hash[::String, untyped]

        def to_collector_array: (untyped encoder) -> untyped

        def to_log_description: () -> ::String
      end
    end
  end
end

module NewRelic
  module Agent
    module Threading
      class AgentThread
        def self.create: (untyped label) { () -> untyped } -> untyped

        # Simplifies testing if we don't directly use ::Thread.list, so keep
        # the accessor for it here on AgentThread to use and stub.
        def self.list: () -> untyped

        def self.bucket_thread: (untyped thread, untyped profile_agent_code) -> untyped

        def self.scrub_backtrace: (untyped thread, untyped profile_agent_code) -> (nil | untyped)

        def self.backing_thread_class: () -> untyped

        def self.backing_thread_class=: (untyped clazz) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Threading
      MAX_THREAD_PROFILE_DEPTH: 500

      UNKNOWN_LINE_NUMBER: -1

      class BacktraceBase
        attr_reader children: untyped

        def initialize: () -> void

        def add_child_unless_present: (untyped child) -> untyped

        def add_child: (untyped child) -> untyped

        def find_child: (untyped raw_line) -> untyped
      end

      class BacktraceRoot < BacktraceBase
        attr_reader flattened: untyped

        def initialize: () -> void

        def ==: (untyped other) -> true

        def as_array: () -> untyped

        def aggregate: (untyped backtrace) -> untyped

        def dump_string: () -> untyped
      end

      class BacktraceNode < BacktraceBase
        attr_reader file: untyped

        attr_reader method: untyped

        attr_reader line_no: untyped

        attr_reader raw_line: untyped

        attr_reader as_array: untyped

        attr_accessor runnable_count: untyped

        attr_accessor depth: untyped

        def initialize: (untyped line) -> void

        def ==: (untyped other) -> untyped

        def mark_for_array_conversion: () -> untyped

        include NewRelic::Coerce

        def complete_array_conversion: () -> untyped

        def dump_string: (?::Integer indent) -> untyped

        # Returns [filename, method, line number]
        def parse_backtrace_frame: (untyped frame) -> ::Array[untyped]
      end
    end
  end
end

module NewRelic
  module Agent
    #
    # This module contains helper methods related to Distributed
    # Tracing, an APM feature that ties together traces from multiple
    # apps in one view.  Use it to add distributed tracing to protocols
    # not already supported by the agent.
    #
    # @api public
    module DistributedTracing
      extend NewRelic::SupportabilityHelper

      extend ::NewRelic::Agent::DistributedTracing

      # Adds the Distributed Trace headers so that the downstream service can participate in a
      # distributed trace. This method should be called every time an outbound call is made
      # since the header payload contains a timestamp.
      #
      # Distributed Tracing must be enabled to use this method.
      #
      # +insert_distributed_trace_headers+ always inserts W3C trace context headers and inserts
      # New Relic distributed tracing header by default. New Relic headers may be suppressed by
      # setting +exclude_new_relic_header+ to +true+ in your configuration file.
      #
      # @param headers           [Hash]     Is a Hash to which the distributed trace headers
      #                                     will be inserted.
      #
      # @return           {Transaction}     The transaction the headers were inserted from,
      #                                     or +nil+ if headers were not inserted.
      #
      # @api public
      #
      def insert_distributed_trace_headers: (?::Hash[untyped, untyped] headers) -> untyped

      # Accepts distributed tracing headers from any source that has been packaged
      # as a Ruby Hash, thereby allowing the user to manually inject distributed
      # tracing headers.  It is optimized to process +HTTP_TRACEPARENT+, +HTTP_TRACESTATE+,
      # and +HTTP_NEWRELIC+ as the given Hash keys.  which is the most common scenario
      # from Rack middleware in most Ruby applications.  However, the Hash keys are
      # case-insensitive and the "HTTP_" prefixes may also be omitted.
      #
      # Calling this method is not necessary in a typical HTTP trace as
      # distributed tracing is already handled by the agent.
      #
      # When used, invoke this method as early as possible in a transaction's life-cycle
      # as calling after the headers are already created will have no effect.
      #
      # This method accepts both W3C trace context and New Relic distributed tracing headers.
      # When both are present, only the W3C headers are utilized.  When W3C trace context
      # headers are present, New Relic headers are ignored regardless if W3C trace context
      # headers are valid and parsable.
      #
      # @param headers         [Hash]     Incoming distributed trace headers as a Ruby
      #                                   Hash object.  Hash keys are expected to be one of
      #                                   +TRACEPARENT+, +TRACESTATE+, +NEWRELIC+ and are
      #                                   case-insensitive, with or without "HTTP_" prefixes.
      #
      #                                   either as a JSON string or as a
      #                                   header-friendly string returned from
      #                                   {DistributedTracePayload#http_safe}
      #
      # @param transport_Type  [String]   May be one of:  +HTTP+, +HTTPS+, +Kafka+, +JMS+,
      #                                   +IronMQ+, +AMQP+, +Queue+, +Other+.  Values are
      #                                   case sensitive.  All other values result in +Unknown+
      #
      # @return {Transaction} if successful, +nil+ otherwise
      #
      # @api public
      #
      def accept_distributed_trace_headers: (untyped headers, ?untyped transport_type) -> untyped

      private

      def has_variant_key?: (untyped key, untyped variants) -> untyped

      def variant_key_value: (untyped headers, untyped variants) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class AgentLogger
      include LogOnce

      def initialize: (?::String root, ?untyped? override_logger) -> void

      def fatal: (*untyped msgs) { () -> untyped } -> untyped

      def error: (*untyped msgs) { () -> untyped } -> untyped

      def warn: (*untyped msgs) { () -> untyped } -> untyped

      def info: (*untyped msgs) { () -> untyped } -> untyped

      def debug: (*untyped msgs) { () -> untyped } -> untyped

      def is_startup_logger?: () -> untyped

      # Use this when you want to log an exception with explicit control over
      # the log level that the backtrace is logged at. If you just want the
      # default behavior of backtraces logged at debug, use one of the methods
      # above and pass an Exception as one of the args.
      def log_exception: (untyped level, untyped e, ?untyped backtrace_level) -> untyped

      def log_formatter=: (untyped formatter) -> untyped

      private

      def backtrace_from_exception: (untyped e) -> untyped

      # Allows for passing exceptions in explicitly, which format with backtrace
      def format_and_send: (untyped level, *untyped msgs) { () -> untyped } -> nil

      def create_log: (untyped root, untyped override_logger) -> untyped

      def create_log_to_file: (untyped root) -> untyped

      def create_null_logger: () -> untyped

      def wants_stdout?: () -> untyped

      def find_or_create_file_path: (untyped path_setting, untyped root) -> (untyped | nil)

      def set_log_level!: () -> untyped

      LOG_LEVELS: ::Hash[::String, untyped]

      def self.log_level_for: (untyped level) -> untyped

      def set_log_format!: () -> untyped

      # Don't allow agent logs into agent log forwarding for now
      def disable_log_instrumentation!: () -> untyped

      def gather_startup_logs: () -> untyped

      def self.format_fatal_error: (untyped message) -> ::String
    end

    # In an effort to not lose messages during startup, we trap them in memory
    # The real logger will then dump its contents out when it arrives.
    class StartupLogger < MemoryLogger
      include Singleton
    end
  end
end

module NewRelic
  module Agent
    # This class contains the logic of recording slow SQL traces, which may
    # represent multiple aggregated SQL queries.
    #
    # A slow SQL trace consists of a collection of SQL instrumented SQL queries
    # that all normalize to the same text. For example, the following two
    # queries would be aggregated together into a single slow SQL trace:
    #
    #   SELECT * FROM table WHERE id=42
    #   SELECT * FROM table WHERE id=1234
    #
    # Each slow SQL trace keeps track of the number of times the same normalized
    # query was seen, the min, max, and total time spent executing those
    # queries, and an example backtrace from one of the aggregated queries.
    #
    # @api public
    class SqlSampler
      attr_reader disabled: untyped

      # this is for unit tests only
      attr_reader sql_traces: untyped

      MAX_SAMPLES: 10

      def initialize: () -> void

      def enabled?: () -> untyped

      def on_start_transaction: (untyped state, ?untyped? uri) -> (nil | untyped)

      def tl_transaction_data: () -> untyped

      # This is called when we are done with the transaction.
      def on_finishing_transaction: (untyped state, untyped name) -> (nil | untyped)

      # this should always be called under the @samples_lock
      def save_slow_sql: (untyped transaction_sql_data) -> untyped

      # this should always be called under the @samples_lock
      def should_add_trace?: (untyped sql_item) -> untyped

      # this should always be called under the @samples_lock
      def has_room?: () -> untyped

      # this should always be called under the @samples_lock
      def remove_shortest_trace: () -> untyped

      def notice_sql: (untyped sql, untyped metric_name, untyped config, untyped duration, ?untyped? state, ?untyped? explainer, ?untyped? binds, ?untyped? name) -> (nil | untyped)

      PRIORITY: "priority"

      def distributed_trace_attributes: (untyped state) -> untyped

      def notice_sql_statement: (untyped statement, untyped metric_name, untyped duration) -> (nil | untyped)

      def merge!: (untyped sql_traces) -> untyped

      def harvest!: () -> (::Array[untyped] | untyped)

      def reset!: () -> untyped
    end

    class TransactionSqlData
      attr_reader path: untyped

      attr_reader uri: untyped

      attr_reader sql_data: untyped

      attr_reader guid: untyped

      def initialize: () -> void

      def set_transaction_info: (untyped uri, untyped guid) -> untyped

      def set_transaction_name: (untyped name) -> untyped
    end

    class SlowSql
      attr_reader statement: untyped

      attr_reader metric_name: untyped

      attr_reader duration: untyped

      attr_reader backtrace: untyped

      def initialize: (untyped statement, untyped metric_name, untyped duration, ?untyped? backtrace, ?untyped? params) -> void

      def sql: () -> untyped

      def base_params: () -> untyped

      def obfuscate: () -> untyped

      def normalize: () -> untyped

      def explain: () -> untyped

      # We can't serialize the explainer, so clear it before we transmit
      def prepare_to_send: () -> untyped
    end

    class SqlTrace < Stats
      attr_reader path: untyped

      attr_reader url: untyped

      attr_reader sql_id: untyped

      attr_reader sql: untyped

      attr_reader database_metric_name: untyped

      attr_reader params: untyped

      attr_reader slow_sql: untyped

      def initialize: (untyped normalized_query, untyped slow_sql, untyped path, untyped uri) -> void

      def set_primary: (untyped slow_sql, untyped path, untyped uri) -> untyped

      def aggregate: (untyped slow_sql, untyped path, untyped uri) -> untyped

      def aggregate_trace: (untyped trace) -> untyped

      def prepare_to_send: () -> untyped

      def need_to_obfuscate?: () -> untyped

      def need_to_explain?: () -> untyped

      include NewRelic::Coerce

      def to_collector_array: (untyped encoder) -> ::Array[untyped]

      private

      # need to hash the same way in every process, to be able to aggregate slow SQL traces
      def consistent_hash: (untyped string) -> untyped
    end
  end
end

module NewRelic
  module Agent
    module Connect
      class RequestBuilder
        def initialize: (untyped new_relic_service, untyped config, untyped event_harvest_config, untyped environment_report) -> void

        # Initializes the hash of settings that we send to the
        # server. Returns a literal hash containing the options
        def connect_payload: () -> { pid: untyped, host: untyped, display_host: untyped, app_name: untyped, language: "ruby", labels: untyped, agent_version: untyped, environment: untyped, metadata: untyped, settings: untyped, high_security: untyped, utilization: untyped, identifier: ::String, event_harvest_config: untyped }

        # We've seen objects in the environment report (Rails.env in
        # particular) that can't seralize to JSON. Cope with that here and
        # clear out so downstream code doesn't have to check again.
        def sanitize_environment_report: (untyped environment_report) -> (::Array[untyped] | untyped)

        def environment_metadata: () -> untyped

        def local_host: () -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    module Connect
      class ResponseHandler
        def initialize: (untyped agent, untyped config) -> void

        # Takes a hash of configuration data returned from the
        # server and uses it to set local variables and to
        # initialize various parts of the agent that are configured
        # separately.
        #
        # Can accommodate most arbitrary data - anything extra is
        # ignored unless we say to do something with it here.
        def configure_agent: (untyped config_data) -> (nil | untyped)

        def add_server_side_config: (untyped config_data) -> untyped

        def add_security_policy_config: (untyped security_policies) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class Attributes
      KEY_LIMIT: 255

      VALUE_LIMIT: 255

      COUNT_LIMIT: 64

      attr_reader custom_attributes: untyped

      def initialize: (untyped filter) -> void

      def add_agent_attribute: (untyped key, untyped value, untyped default_destinations) -> (nil | untyped)

      def add_agent_attribute_with_key_check: (untyped key, untyped value, untyped default_destinations) -> (nil | untyped)

      def add_intrinsic_attribute: (untyped key, untyped value) -> untyped

      def merge_untrusted_agent_attributes: (untyped attributes, untyped prefix, untyped default_destinations) -> (nil | untyped)

      def merge_custom_attributes: (untyped other) -> (nil | untyped)

      def custom_attributes_for: (untyped destination) -> untyped

      def agent_attributes_for: (untyped destination) -> untyped

      def intrinsic_attributes_for: (untyped destination) -> untyped

      private

      def add_custom_attribute: (untyped key, untyped value) -> (nil | untyped)

      def add: (untyped attributes, untyped key, untyped value) -> (nil | untyped)

      def for_destination: (untyped attributes, untyped calculated_destinations, untyped destination) -> untyped

      def exceeds_bytesize_limit?: (untyped value, untyped limit) -> untyped

      # Take one byte past our limit. Why? This lets us unconditionally chop!
      # the end. It'll either remove the one-character-too-many we have, or
      # peel off the partial, mangled character left by the byteslice.
      def slice: (untyped incoming) -> untyped
    end
  end
end

module NewRelic
  module Agent
    #
    # This module contains helper methods to facilitate instrumentation of
    # datastores not directly supported by the Ruby agent. It is intended to be
    # primarily used by authors of 3rd-party datastore instrumentation.
    #
    # @api public
    module Datastores
      # Add Datastore tracing to a method. This properly generates the metrics
      # for New Relic's Datastore features. It does not capture the actual
      # query content into Transaction Traces. Use wrap if you want to provide
      # that functionality.
      #
      # @param [Class] klass the class to instrument
      #
      # @param [String, Symbol] method_name the name of instance method to
      #   instrument
      #
      # @param [String] product name of your datastore for use in metric naming, e.g. "Redis"
      #
      # @param [optional,String] operation the name of operation if different
      #   than the instrumented method name
      #
      # @api public
      #
      def self.trace: (untyped klass, untyped method_name, untyped product, ?untyped operation) -> untyped

      # Wrap a call to a datastore and record New Relic Datastore metrics. This
      # method can be used when a collection (i.e. table or model name) is
      # known at runtime to be included in the metric naming. It is intended
      # for situations that the simpler NewRelic::Agent::Datastores.trace can't
      # properly handle.
      #
      # To use this, wrap the datastore operation in the block passed to wrap.
      #
      #   NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items") do
      #     FauxDB.find(query)
      #   end
      #
      # @param [String] product the datastore name for use in metric naming,
      #   e.g. "FauxDB"
      #
      # @param [String,Symbol] operation the name of operation (e.g. "select"),
      #   often named after the method that's being instrumented.
      #
      # @param [optional, String] collection the collection name for use in
      #   statement-level metrics (i.e. table or model name)
      #
      # @param [Proc,#call] callback proc or other callable to invoke after
      #   running the datastore block. Receives three arguments: result of the
      #   yield, the most specific (scoped) metric name, and elapsed time of the
      #   call. An example use is attaching SQL to Transaction Traces at the end
      #   of a wrapped datastore call.
      #
      #     callback = Proc.new do |result, metrics, elapsed|
      #       NewRelic::Agent::Datastores.notice_sql(query, metrics, elapsed)
      #     end
      #
      #     NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items", callback) do
      #       FauxDB.find(query)
      #     end
      #
      # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING QUERY TEXT!
      #   New Relic's Transaction Tracing and Slow SQL features will
      #   attempt to apply obfuscation to the passed queries, but it is possible
      #   for a query format to be unsupported and result in exposing user
      #   information embedded within captured queries.
      #
      # @api public
      #
      def self.wrap: (untyped product, untyped operation, ?untyped? collection, ?untyped? callback) { () -> untyped } -> untyped

      # Wrapper for simplifying attaching SQL queries during a transaction.
      #
      # If you are recording non-SQL data, please use {notice_statement}
      # instead.
      #
      #   NewRelic::Agent::Datastores.notice_sql(query, metrics, elapsed)
      #
      # @param [String] query the SQL text to be captured. Note that depending
      #   on user settings, this string will be run through obfuscation, but
      #   some dialects of SQL (or non-SQL queries) are not guaranteed to be
      #   properly obfuscated by these routines!
      #
      # @param [String] scoped_metric The most specific metric relating to this
      #   query. Typically the result of
      #   NewRelic::Agent::Datastores::MetricHelper#metrics_for
      #
      # @param [Float] elapsed the elapsed time during query execution
      #
      # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING QUERY TEXT!
      #   New Relic's Transaction Tracing and Slow SQL features will
      #   attempt to apply obfuscation to the passed queries, but it is possible
      #   for a query format to be unsupported and result in exposing user
      #   information embedded within captured queries.
      #
      # @api public
      #
      def self.notice_sql: (untyped query, untyped scoped_metric, untyped elapsed) -> nil

      # Wrapper for simplifying attaching non-SQL data statements to a
      # transaction. For instance, Mongo or CQL queries, Memcached or Redis
      # keys would all be appropriate data to attach as statements.
      #
      # Data passed to this method is NOT obfuscated by New Relic, so please
      # ensure that user information is obfuscated if the agent setting
      # `transaction_tracer.record_sql` is set to `obfuscated`
      #
      #   NewRelic::Agent::Datastores.notice_statement("key", elapsed)
      #
      # @param [String] statement text of the statement to capture.
      #
      # @param [Float] elapsed the elapsed time during query execution
      #
      # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING STATEMENTS!
      #   This method will properly ignore statements when the user has turned
      #   off capturing queries, but it is not able to obfuscate arbitrary data!
      #   To prevent exposing user information embedded in captured queries,
      #   please ensure all data passed to this method is safe to transmit to
      #   New Relic.
      #
      # @api public
      #
      def self.notice_statement: (untyped statement, untyped elapsed) -> nil
    end
  end
end

# The agent's configuration is accessed through a configuration object exposed
# by ::NewRelic::Agent.config.  It provides a hash like interface to the
# agent's settings.
#
# For example:
# ::NewRelic::Agent.config[:'transaction_tracer.enabled']
# determines whether transaction tracing is enabled.  String and symbol keys
# are treated indifferently and nested keys are collapsed and concatenated with
# a dot (i.e. {:a => {:b => 'c'} becomes { 'a.b' => 'c'}).
#
# The agent reads configuration from a variety of sources. These sources are
# modeled as a set of layers.  The top layer has the highest priority.  If the
# top layer does not contain the requested setting the config object will search
# through the subsequent layers returning the first value it finds.
#
# Configuration layers include EnvironmentSource (which reads settings from
# ENV), ServerSource (which reads Server Side Config from New Relic's servers),
# YamlSource (which reads from newrelic.yml),  ManualSource (which reads
# arguments passed to NewRelic::Agent.manual_start or potentially other
# methods), and Defaults (which contains default settings).
#
module NewRelic
  module Agent
    module Configuration
    end
  end
end

module NewRelic
  module Agent
    module Logging
      # This class can be used as the formatter for an existing logger.  It
      # decorates log messages with trace and entity metadata, and formats each
      # log messages as a JSON object.
      #
      # It can be added to a Rails application like this:
      #
      #   require 'newrelic_rpm'
      #
      #   Rails.application.configure do
      #     config.log_formatter = ::NewRelic::Agent::Logging::DecoratingFormatter.new
      #   end
      #
      # @api public
      class DecoratingFormatter < ::Logger::Formatter
        TIMESTAMP_KEY: "timestamp"

        MESSAGE_KEY: "message"

        LOG_LEVEL_KEY: "log.level"

        LOG_NAME_KEY: "logger.name"

        NEWLINE: ::String

        QUOTE: "\""

        COLON: ":"

        COMMA: ","

        CLOSING_BRACE: "}"

        REPLACEMENT_CHAR: ::String

        def initialize: () -> void

        def call: (untyped severity, untyped time, untyped progname, untyped msg) -> untyped

        def app_name: () -> untyped

        def add_key_value: (untyped message, untyped key, untyped value) -> untyped

        def escape: (untyped message) -> untyped

        def clear_tags!: () -> nil
      end

      # This logger decorates logs with trace and entity metadata, and emits log
      # messages formatted as JSON objects.  It extends the Logger class from
      # the Ruby standard library, and accepts the same constructor parameters.
      #
      # It aliases the `:info` message to overwrite the `:write` method, so it
      # can be used in Rack applications that expect the logger to be a file-like
      # object.
      #
      # It can be added to an application like this:
      #
      #   require 'newrelic_rpm'
      #
      #   config.logger = NewRelic::Agent::Logging::DecoratingLogger.new "log/application.log"
      #
      # @api public
      class DecoratingLogger 
        # alias write info

        # def initialize: (*untyped args) -> void

        def initialize: (*untyped args, **untyped kwargs) -> void
      end
    end
  end
end

module NewRelic
  module Agent
    class SpanEventAggregator < EventAggregator
      def record: (?priority: untyped? priority, ?event: untyped? event) { () -> untyped } -> (nil | untyped)

      SUPPORTABILITY_TOTAL_SEEN: "Supportability/SpanEvent/TotalEventsSeen"

      SUPPORTABILITY_TOTAL_SENT: "Supportability/SpanEvent/TotalEventsSent"

      SUPPORTABILITY_DISCARDED: "Supportability/SpanEvent/Discarded"

      def after_harvest: (untyped metadata) -> untyped
    end
  end
end

module NewRelic
  module Agent
    # module MethodTracer
    #   def self.included: (untyped klass) -> untyped

    #   def self.extended: (untyped klass) -> untyped

    #   def trace_execution_scoped: (untyped metric_names, ?untyped options) { () -> untyped } -> untyped

    #   def trace_execution_unscoped: (untyped metric_names, ?untyped options) { () -> untyped } -> untyped

    #   # Defines methods used at the class level, for adding instrumentation
    #   # @api public
    #   module ClassMethods
    #     # contains methods refactored out of the #add_method_tracer method
    #     module AddMethodTracer
    #       ALLOWED_KEYS: ::Array[:metric | :push_scope | :code_header | :code_footer]

    #       DEFAULT_SETTINGS: { push_scope: true, metric: true, code_header: ::String, code_footer: ::String }

    #       # Checks the provided options to make sure that they make
    #       # sense. Raises an error if the options are incorrect to
    #       # assist with debugging, so that errors occur at class
    #       # construction time rather than instrumentation run time
    #       def _nr_validate_method_tracer_options: (untyped method_name, untyped options) -> untyped

    #       # Default to the class where the method is defined.
    #       #
    #       # Example:
    #       #  Foo._nr_default_metric_name_code('bar') #=> "Custom/#{Foo.name}/bar"
    #       def _nr_default_metric_name: (untyped method_name) -> untyped

    #       # Checks to see if the method we are attempting to trace
    #       # actually exists or not. #add_method_tracer can't do
    #       # anything if the method doesn't exist.
    #       def newrelic_method_exists?: (untyped method_name) -> untyped

    #       # Checks to see if we have already traced a method with a
    #       # given metric by checking to see if the traced method
    #       # exists. Warns the user if methods are being double-traced
    #       # to help with debugging custom instrumentation.
    #       def method_traced?: (untyped method_name) -> untyped

    #       # Returns an anonymous module that stores prepended trace methods.
    #       def _nr_traced_method_module: () -> untyped

    #       # for testing only
    #       def _nr_clear_traced_methods!: () -> untyped

    #       def _nr_derived_class_name: () -> (untyped | "AnonymousModule")
    #     end

    #     include AddMethodTracer

    #     # Add a method tracer to the specified method.
    #     #
    #     # By default, this will cause invocations of the traced method to be
    #     # recorded in transaction traces, and in a metric named after the class
    #     # and method. It will also make the method show up in transaction-level
    #     # breakdown charts and tables.
    #     #
    #     # === Overriding the metric name
    #     #
    #     # +metric_name+ is a String or Proc. If a Proc is given, it is bound to
    #     # the object that called the traced method. For example:
    #     #
    #     #     add_method_tracer :foo, -> { "Custom/#{self.class.name}/foo" }
    #     #
    #     # This would name the metric according to the class of the runtime
    #     # instance, as opposed to the class where +foo+ is defined.
    #     #
    #     # If not provided, the metric name will be <tt>Custom/ClassName/method_name</tt>.
    #     #
    #     # @param method_name [Symbol] the name of the method to trace
    #     # @param metric_name [String,Proc,Array] the metric name to record calls to
    #     #   the traced method under. This may be either a String, or a Proc
    #     #   to be evaluated at call-time in order to determine the metric
    #     #   name dynamically.
    #     #   This method also accepts an array of Strings/Procs, in which case the
    #     #   first metric given will be scoped, while the remaining metrics will be
    #     #   recorded as though passed with :push_scope => false. If an Array of
    #     #   metric names is given with :push_scope => false, all metrics will be
    #     #   unscoped.
    #     # @param [Hash] options additional options controlling how the method is
    #     #   traced.
    #     # @option options [Boolean] :push_scope (true) If false, the traced method will
    #     #   not appear in transaction traces or breakdown charts, and it will
    #     #   only be visible in custom dashboards.
    #     # @option options [Boolean] :metric (true) If false, the traced method will
    #     #   only appear in transaction traces, but no metrics will be recorded
    #     #   for it.
    #     # @option options [Proc] :code_header ('') Ruby code to be inserted and run
    #     #   before the tracer begins timing.
    #     # @option options [Proc] :code_footer ('') Ruby code to be inserted and run
    #     #   after the tracer stops timing.
    #     #
    #     # @example
    #     #   add_method_tracer :foo
    #     #
    #     #   # With a custom metric name
    #     #   add_method_tracer :foo, "Custom/MyClass/foo"
    #     #   add_method_tracer :bar, -> { "Custom/#{self.class.name}/bar" }
    #     #
    #     #   # Instrument foo only for custom dashboards (not in transaction
    #     #   # traces or breakdown charts)
    #     #   add_method_tracer :foo, 'Custom/foo', :push_scope => false
    #     #
    #     #   # Instrument foo in transaction traces only
    #     #   add_method_tracer :foo, 'Custom/foo', :metric => false
    #     #
    #     # @api public
    #     #
    #     def add_method_tracer: (untyped method_name, ?untyped? metric_name, ?::Hash[untyped, untyped] options) -> untyped

    #     def remove_method_tracer: (untyped method_name) -> (nil | untyped)

    #     private

    #     def _nr_add_method_tracer_now: (untyped method_name, untyped metric_name, untyped options) -> (nil | untyped)

    #     # See #add_method_tracer; if multiple metric names are given, the first is
    #     # treated as scoped, the rest unscoped. If options[:push_scope] is false,
    #     # all given metrics are unscoped.
    #     def _nr_scoped_unscoped_metrics: (untyped metric_name, untyped method_name, ?push_scope: bool push_scope) -> untyped

    #     def _nr_define_traced_method: (untyped method_name, ?scoped_metric: untyped? scoped_metric, ?unscoped_metrics: untyped unscoped_metrics, ?code_header: untyped? code_header, ?code_footer: untyped? code_footer, ?record_metrics: bool record_metrics, ?visibility: ::Symbol visibility) -> untyped
    #   end
    # end
  end
end

module NewRelic
  module Agent
    class TimestampSampledBuffer < PrioritySampledBuffer
      TIMESTAMP_KEY: "timestamp"

      private

      def priority_for: (untyped event) -> untyped
    end
  end
end

module NewRelic
  module Agent
    class NewRelicService
      module SecurityPolicySettings
        EXPECTED_SECURITY_POLICIES: untyped

        def self.preliminary_settings: (untyped security_policies) -> ::Hash[::String, untyped]

        class Validator
          def initialize: (untyped preconnect_response) -> void

          def validate_matching_agent_config!: () -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    class NewRelicService
      class Marshaller
        def prepare: (untyped data, ?::Hash[untyped, untyped] options) -> untyped

        def default_encoder: () -> untyped

        def self.human_readable?: () -> false

        def return_value: (untyped data) -> untyped
      end
    end
  end
end

module NewRelic
  module Agent
    class NewRelicService
      module Encoders
        module Identity
          def self.encode: (untyped data, ?untyped? opts) -> untyped
        end

        module Compressed
          module Deflate
            def self.encode: (untyped data, ?untyped? opts) -> untyped
          end

          module Gzip
            BINARY: "BINARY"

            def self.encode: (untyped data, ?untyped? opts) -> untyped
          end
        end

        module Base64CompressedJSON
          def self.encode: (untyped data, ?::Hash[untyped, untyped] opts) -> untyped
        end
      end
    end
  end
end

module NewRelic
  module Agent
    class NewRelicService
      # Marshal collector protocol with JSON when available
      class JsonMarshaller < Marshaller
        def initialize: () -> void

        OK_YAJL_VERSION: untyped

        def warn_for_yajl: () -> untyped

        def dump: (untyped ruby, ?::Hash[untyped, untyped] opts) -> untyped

        def load: (untyped data) -> untyped

        def default_encoder: () -> untyped

        def format: () -> "json"

        def self.human_readable?: () -> true
      end
    end
  end
end

module NewRelic
  module Agent
    class AdaptiveSampler
      def initialize: (?::Integer target_samples, ?::Integer period_duration) -> void

      # Called at the beginning of each transaction, increments seen and
      # returns a boolean indicating if we should mark the transaction as
      # sampled. This uses the adaptive sampling algorithm.
      def sampled?: () -> untyped

      def exponential_backoff: () -> untyped

      def stats: () -> untyped

      private

      def reset_if_period_expired!: () -> (nil | untyped)

      def register_config_callbacks: () -> untyped

      def register_sampling_target_callback: () -> untyped

      def register_sampling_period_callback: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    class EventAggregator
      def self.named: (?untyped? named) -> untyped

      def self.capacity_key: (?untyped? key) -> untyped

      def self.enabled_keys: (*untyped keys) -> untyped

      alias self.enabled_key self.enabled_keys

      def self.enabled_fn: (?untyped? fn) -> untyped

      def self.buffer_class: (?untyped? klass) -> untyped

      def initialize: (untyped events) -> void

      # interface method for subclasses to override to provide post-initialization setup
      def after_initialize: () -> nil

      # interface method for subclasses to override to provide post harvest functionality
      def after_harvest: (untyped metadata) -> nil

      def enabled?: () -> untyped

      def has_metadata?: () -> true

      def harvest!: () -> ::Array[untyped]

      # Merges samples from payload back into buffer and optionally adjusts the count of
      # the buffer to ensure accuracy of buffer of metadata. We want to make sure not to
      # double count samples being merged back in from a failed harvest, yet we do not
      # want to under-count samples being merged from the PipeService.
      def merge!: (untyped payload, ?bool adjust_count) -> untyped

      def reset!: () -> untyped

      private

      def reservoir_metadata: (untyped metadata) -> { reservoir_size: untyped, events_seen: untyped }

      def register_capacity_callback: () -> untyped

      def register_enabled_callback: (untyped events) -> untyped

      def notify_if_full: () -> (nil | untyped)

      def reset_buffer!: () -> untyped
    end
  end
end

module NewRelic
  module Agent
    # stub module that contains instrumentation defined in the
    # instrumentation directory
    module Instrumentation
    end
  end
end

module NewRelic
  module Agent
    # This class is used for instrumentations that have exceptions or error classes
    # not derived from Ruby's usual Exception or StandardError or in situations
    # where we do not have such Exception object to work with.
    class NoticibleError
      attr_reader class_name: untyped

      attr_reader message: untyped

      def initialize: (untyped class_name, untyped message) -> void
    end
  end
end

# -*- coding: utf-8 -*-
module NewRelic
  module Agent
    class StatsEngine
      module GCProfiler
        GCSnapshot: untyped

        def self.init: () -> untyped

        def self.reset: () -> untyped

        def self.take_snapshot: () -> untyped

        def self.record_delta: (untyped start_snapshot, untyped end_snapshot) -> untyped

        def self.record_gc_metric: (untyped call_count, untyped elapsed) -> untyped

        GC_ROLLUP: "GC/Transaction/all"

        GC_OTHER: "GC/Transaction/allOther"

        GC_WEB: "GC/Transaction/allWeb"

        def self.gc_metric_name: () -> untyped

        class RailsBenchProfiler
          def self.enabled?: () -> untyped

          def call_time_s: () -> untyped

          def call_count: () -> untyped

          def reset: () -> untyped
        end

        class CoreGCProfiler
          def self.enabled?: () -> untyped

          def call_time_s: () -> untyped

          def call_count: () -> untyped

          # When using GC::Profiler, it's important to periodically call
          # GC::Profiler.clear in order to avoid unbounded growth in the number
          # of GC records that are stored. However, we actually do this
          # internally within MonotonicGCProfiler on calls to #total_time_s,
          # so the reset here is a no-op.
          def reset: () -> nil
        end
      end
    end
  end
end

module NewRelic
  module Agent
    class StatsHash
      attr_accessor started_at: untyped

      attr_accessor harvested_at: untyped

      def initialize: (?untyped started_at) -> void

      def marshal_dump: () -> ::Array[untyped]

      def marshal_load: (untyped data) -> untyped

      def ==: (untyped other) -> untyped

      def to_h: () -> untyped

      def []: (untyped key) -> untyped

      def each: () { (untyped, untyped) -> untyped } -> untyped

      def empty?: () -> untyped

      def size: () -> untyped

      class StatsHashLookupError < NewRelic::Agent::InternalAgentError
        def initialize: (untyped original_error, untyped hash, untyped metric_spec) -> void
      end

      def record: (untyped metric_specs, ?untyped? value, ?untyped? aux) { () -> untyped } -> untyped

      def handle_stats_lookup_error: (untyped key, untyped hash, untyped error) -> untyped

      def merge!: (untyped other) -> untyped

      def merge_transaction_metrics!: (untyped txn_metrics, untyped scope) -> untyped

      def merge_or_insert: (untyped target, untyped name, untyped stats) -> untyped
    end
  end
end

class NewRelic::Cli::Install < NewRelic::Cli::Command
  NO_LICENSE_KEY: "<PASTE LICENSE KEY HERE>"

  def self.command: () -> "install"

  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  attr_reader dest_dir: untyped

  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  attr_reader license_key: untyped

  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  attr_reader generated_for_user: untyped

  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  attr_reader quiet: untyped

  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  attr_reader src_file: untyped

  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  attr_reader app_name: untyped

  def initialize: (?::Hash[untyped, untyped] command_line_args) -> void

  def run: () -> untyped

  def content: () -> untyped

  private

  def options: () { (untyped) -> untyped } -> untyped
end

class NewRelic::Cli::Deployments < NewRelic::Cli::Command
  attr_reader control: untyped

  def self.command: () -> "deployments"

  # Initialize the deployment uploader with command line args.
  # Use -h to see options.
  # When command_line_args is a hash, we are invoking directly and
  # it's treated as an options with optional string values for
  # :user, :description, :appname, :revision, :environment,
  # :license_key, and :changes.
  #
  # Will throw CommandFailed exception if there's any error.
  #
  def initialize: (untyped command_line_args) -> void

  def load_yaml_from_env: (untyped env) -> untyped

  def setup_logging: (untyped env) -> untyped

  # Run the Deployment upload in New Relic via Active Resource.
  # Will possibly print errors and exit the VM
  def run: () -> untyped

  private

  def options: () { (untyped) -> untyped } -> untyped
end

module NewRelic
  module Cli
    class Command
      attr_accessor leftover: untyped

      # Capture a failure to execute the command.
      class CommandFailure < StandardError
        attr_reader options: untyped

        def initialize: (untyped message, ?untyped? opt_parser) -> void
      end

      def info: (untyped message) -> untyped

      def err: (untyped message) -> untyped

      def initialize: (untyped command_line_args) -> void

      def self.inherited: (untyped subclass) -> untyped

      def self.run: () -> untyped
    end
  end
end

module NewRelic
  module Coerce
    def self?.int: (untyped value, ?untyped? context) -> untyped

    def self?.int_or_nil: (untyped value, ?untyped? context) -> untyped

    def self?.float: (untyped value, ?untyped? context) -> untyped

    def self?.string: (untyped value, ?untyped? context) -> untyped

    def self?.scalar: (untyped val) -> untyped

    def self?.int!: (untyped value) -> (nil | untyped)

    # Use when you plan to perform a boolean check using the integer 1
    # for true and the integer 0 for false
    # String values will be converted to 0
    def self?.boolean_int!: (untyped value) -> untyped

    def self?.float!: (untyped value, ?untyped precision) -> (nil | untyped)

    def self?.value_or_nil: (untyped value) -> (nil | untyped)

    def self?.log_failure: (untyped value, untyped `type`, untyped context, untyped error) -> untyped
  end
end

module NewRelic
  module CollectionHelper
    DEFAULT_TRUNCATION_SIZE: untyped

    DEFAULT_ARRAY_TRUNCATION_SIZE: 128

    # Transform parameter hash into a hash whose values are strictly
    # strings
    def normalize_params: (untyped params) -> untyped

    private

    # Convert any kind of object to a short string.
    def flatten: (untyped object) -> untyped

    def truncate: (untyped string, ?untyped len) -> untyped
  end
end

# This class encapsulates an error that was noticed by New Relic in a managed app.
class NewRelic::NoticedError
  extend NewRelic::CollectionHelper

  attr_accessor path: untyped

  attr_accessor timestamp: untyped

  attr_accessor message: untyped

  attr_accessor exception_class_name: untyped

  attr_accessor request_uri: untyped

  attr_accessor request_port: untyped

  attr_accessor file_name: untyped

  attr_accessor line_number: untyped

  attr_accessor stack_trace: untyped

  attr_accessor attributes_from_notice_error: untyped

  attr_accessor attributes: untyped

  attr_accessor expected: untyped

  attr_reader exception_id: untyped

  attr_reader is_internal: untyped

  STRIPPED_EXCEPTION_REPLACEMENT_MESSAGE: "Message removed by New Relic 'strip_exception_messages' setting"

  UNKNOWN_ERROR_CLASS_NAME: "Error"

  NIL_ERROR_MESSAGE: "<no message>"

  USER_ATTRIBUTES: "userAttributes"

  AGENT_ATTRIBUTES: "agentAttributes"

  INTRINSIC_ATTRIBUTES: "intrinsics"

  DESTINATION: untyped

  ERROR_PREFIX_KEY: "error"

  ERROR_MESSAGE_KEY: ::String

  ERROR_CLASS_KEY: ::String

  ERROR_EXPECTED_KEY: ::String

  def initialize: (untyped path, untyped exception, ?untyped timestamp, ?bool expected) -> void

  def ==: (untyped other) -> untyped

  def self.passes_message_allowlist: (untyped exception_class) -> untyped

  include NewRelic::Coerce

  def to_collector_array: (?untyped? encoder) -> ::Array[untyped]

  # Note that we process attributes lazily and store the result. This is because
  # there is a possibility that a noticed error will be discarded and not sent back
  # as a traced error or TransactionError.
  def processed_attributes: () -> untyped

  def base_parameters: () -> untyped

  # We can get custom attributes from two sources--the transaction, which we
  # hold in @attributes, or passed options to notice_error which show up in
  # @attributes_from_notice_error. Both need filtering, so merge them together
  # in our Attributes class for consistent handling
  def merged_custom_attributes: (untyped merged_attributes) -> untyped

  def merge_custom_attributes_from_transaction: (untyped merged_attributes) -> untyped

  def merge_custom_attributes_from_notice_error: (untyped merged_attributes) -> untyped

  def build_error_attributes: () -> untyped

  def build_agent_attributes: (untyped merged_attributes) -> untyped

  def build_intrinsic_attributes: () -> untyped

  def append_attributes: (untyped outgoing_params, untyped outgoing_key, untyped source_attributes) -> untyped

  def agent_attributes: () -> untyped

  def custom_attributes: () -> untyped

  def intrinsic_attributes: () -> untyped

  def extract_class_name_and_message_from: (untyped exception) -> untyped
end

module NewRelic
  module DelayedJobInjection
    extend ::NewRelic::DelayedJobInjection

    attr_accessor worker_name: untyped
  end
end

module NewRelic
  module LanguageSupport
    extend ::NewRelic::LanguageSupport

    def can_fork?: () -> untyped

    def gc_profiler_usable?: () -> untyped

    def gc_profiler_enabled?: () -> untyped

    def object_space_usable?: () -> untyped

    def jruby?: () -> untyped

    def constantize: (untyped const_name) -> untyped

    def bundled_gem?: (untyped gem_name) -> untyped
  end
end

class Object
  def send_deployment_notification_to_newrelic: () -> untyped

  # def lookup_changelog: () -> (nil | untyped)
end

class Object
  def lookup_changelog: (untyped changelog) -> untyped

  def lookup_rev: (untyped rev) -> untyped
end

module NewRelic
  # The EnvironmentReport is responsible for analyzing the application's
  # environment and generating the data for the Environment Report in New
  # Relic's interface.
  #
  # It contains useful system information like Ruby version, OS, loaded gems,
  # etc.
  #
  # Additional logic can be registered by using the EnvironmentReport.report_on
  # hook.
  class EnvironmentReport
    # This is the main interface for registering logic that should be included
    # in the Environment Report. For example:
    #
    # EnvironmentReport.report_on "Day of week" do
    #   Time.now.strftime("%A")
    # end
    #
    # The passed blocks will be run in EnvironmentReport instances on #initialize.
    #
    # Errors raised in passed blocks will be handled and logged at debug, so it
    # is safe to report on things that may not work in certain environments.
    #
    # The blocks should only return strings or arrays full of strings.  Falsey
    # values will be ignored.
    def self.report_on: (untyped key) { () -> untyped } -> untyped

    def self.registered_reporters: () -> untyped

    # allow the logic to be swapped out in tests
    def self.registered_reporters=: (untyped logic) -> untyped

    attr_reader data: untyped

    # Generate the report based on the class level logic.
    def initialize: () -> void

    def []: (untyped key) -> untyped

    def []=: (untyped key, untyped value) -> untyped

    def to_a: () -> untyped
  end
end

module NewRelic
  PRIORITY_PRECISION: 6

  EMPTY_ARRAY: ::Array[untyped]

  EMPTY_HASH: ::Hash[untyped, untyped]

  EMPTY_STR: ::String

  HTTP: "HTTP"

  HTTPS: "HTTPS"

  UNKNOWN: "Unknown"

  FORMAT_NON_RACK: 0

  FORMAT_RACK: 1

  NEWRELIC_KEY: "newrelic"

  CANDIDATE_NEWRELIC_KEYS: ::Array[untyped | "NEWRELIC" | "NewRelic" | "Newrelic"]

  TRACEPARENT_KEY: "traceparent"

  TRACESTATE_KEY: "tracestate"

  HTTP_TRACEPARENT_KEY: ::String

  HTTP_TRACESTATE_KEY: ::String

  HTTP_NEWRELIC_KEY: ::String

  CONNECT_RETRY_PERIODS: ::Array[15 | 30 | 60 | 120 | 300]

  MIN_RETRY_PERIOD: 15

  MAX_RETRY_PERIOD: 300
end

module NewRelic
  module Rack
    class AgentMiddleware
      include Agent::Instrumentation::MiddlewareTracing

      attr_reader transaction_options: untyped

      attr_reader category: untyped

      attr_reader target: untyped

      def initialize: (untyped app, ?::Hash[untyped, untyped] options) -> void

      def build_transaction_name: () -> ::String

      # If middleware tracing is disabled, we'll still inject our agent-specific
      # middlewares, and still trace those, but we don't want to capture HTTP
      # response codes, since middleware that's outside of ours might change the
      # response code before it goes back to the client.
      def capture_http_response_code: (untyped state, untyped result) -> (nil | untyped)

      def capture_response_content_type: (untyped state, untyped result) -> (nil | untyped)
    end
  end
end

module NewRelic::Rack
  # This middleware is used by the agent for the Real user monitoring (RUM)
  # feature, and will usually be automatically injected in the middleware chain.
  # If automatic injection is not working, you may manually use it in your
  # middleware chain instead.
  #
  # @api public
  #
  class BrowserMonitoring < AgentMiddleware
    # The maximum number of bytes of the response body that we will
    # examine in order to look for a RUM insertion point.
    SCAN_LIMIT: 50000

    CONTENT_TYPE: "Content-Type"

    CONTENT_DISPOSITION: "Content-Disposition"

    CONTENT_LENGTH: "Content-Length"

    ATTACHMENT: "attachment"

    TEXT_HTML: "text/html"

    BODY_START: "<body"

    HEAD_START: "<head"

    GT: ">"

    def traced_call: (untyped env) -> untyped

    ALREADY_INSTRUMENTED_KEY: "newrelic.browser_monitoring_already_instrumented"

    def should_instrument?: (untyped env, untyped status, untyped headers) -> untyped

    def is_html?: (untyped headers) -> untyped

    def is_attachment?: (untyped headers) -> untyped

    def is_streaming?: (untyped env, untyped headers) -> (true | untyped)

    CHARSET_RE: ::Regexp

    X_UA_COMPATIBLE_RE: ::Regexp

    def autoinstrument_source: (untyped response, untyped headers, untyped js_to_inject) -> untyped

    def gather_source: (untyped response) -> untyped

    # Per "The Response > The Body" section of Rack spec, we should close
    # if our response is able. http://rack.rubyforge.org/doc/SPEC.html
    def close_old_response: (untyped response) -> untyped

    def find_body_start: (untyped beginning_of_source) -> untyped

    def find_x_ua_compatible_position: (untyped beginning_of_source) -> untyped

    def find_charset_position: (untyped beginning_of_source) -> untyped

    def find_end_of_head_open: (untyped beginning_of_source) -> untyped
  end
end

module NewRelic::Rack
  # This middleware is used internally by the agent in the rare case
  # where the disable_middleware_instrumentation configuration setting
  # is true.  In Rails and Sinatra applications this middleware will be
  # automatically injected if necessary.
  #
  # If you have disabled middleware instrumentation and are not using Rails or
  # Sinatra you can include this middleware manually in your config.ru file.
  #
  # All of the functionality of this module resides in the MiddlewareTracing
  # module, which is shared between it and our third party middleware
  # instrumentation.
  #
  # @api public
  #
  class AgentHooks < AgentMiddleware
    def self.needed?: () -> untyped

    def traced_call: (untyped env) -> untyped
  end
end

module NewRelic
  # The Control is a singleton responsible for the startup and
  # initialization sequence.  The initializer uses a LocalEnvironment to
  # detect the framework and instantiates the framework specific
  # subclass.
  #
  # The Control also implements some of the public API for the agent.
  #
  class Control
  end
end

module NewRelic
  module VERSION
    # :nodoc:
    MAJOR: 8

    MINOR: 6

    TINY: 0

    STRING: ::String
  end
end

# this struct uniquely defines a metric, optionally inside
# the call scope of another metric
class NewRelic::MetricSpec
  attr_reader name: untyped

  attr_reader scope: untyped

  # the maximum length of a metric name or metric scope
  MAX_LENGTH: 255

  LENGTH_RANGE: ::Range[::Integer]

  EMPTY_SCOPE: ::String

  def initialize: (?::String metric_name, ?untyped? metric_scope) -> void

  def ==: (untyped o) -> untyped

  def eql?: (untyped o) -> untyped

  def hash: () -> untyped

  def to_s: () -> (untyped | ::String)

  def inspect: () -> ::String

  def to_json: (*untyped a) -> untyped

  def <=>: (untyped o) -> untyped
end

module NewRelic
  class Control
    # class-level methods for lazy creation of NewRelic::Control and
    # NewRelic::LocalEnvironment instances.
    module ClassMethods
      # Access the Control singleton, lazy initialized.  Default will instantiate a new
      # instance or pass false to defer
      def instance: (?bool create) -> untyped

      # clear out memoized Control and LocalEnv instances
      def reset: () -> untyped

      # Access the LocalEnvironment singleton, lazy initialized
      def local_env: () -> untyped

      # Create the concrete class for environment specific behavior
      def new_instance: () -> untyped

      # nb this does not 'load test' the framework, it loads the 'test framework'
      def load_test_framework: () -> untyped

      # Loads the specified framework class from the
      # NewRelic::Control::Frameworks module
      def load_framework_class: (untyped framework) -> untyped

      # The root directory for the plugin or gem
      def newrelic_root: () -> untyped

      def camelize: (untyped snake_case_name) -> untyped
    end

    extend ClassMethods
  end
end

module NewRelic
  class Control
    # Contains subclasses of NewRelic::Control that are used when
    # starting the agent within an application. Framework-specific
    # logic should be included here, as documented within the Control
    # abstract parent class
    module Frameworks
    end
  end
end

module NewRelic
  class Control
    # Contains methods that relate to the runtime usage of the control
    # object. Note that these are subject to override in the
    # NewRelic::Control::Framework classes that are actually instantiated
    module InstanceMethods
      # The env is the setting used to identify which section of the newrelic.yml
      # to load.  This defaults to a framework specific value, such as ENV['RAILS_ENV']
      # but can be overridden as long as you set it before calling #init_plugin
      attr_writer env: untyped

      # The local environment contains all the information we report
      # to the server about what kind of application this is, what
      # gems and plugins it uses, and many other kinds of
      # machine-dependent information useful in debugging
      attr_reader local_env: untyped

      # Initialize the plugin/gem and start the agent.  This does the
      # necessary configuration based on the framework environment and
      # determines whether or not to start the agent.  If the agent is
      # not going to be started then it loads the agent shim which has
      # stubs for all the external api.
      #
      # This may be invoked multiple times, as long as you don't attempt
      # to uninstall the agent after it has been started.
      #
      # If the plugin is initialized and it determines that the agent is
      # not enabled, it will skip starting it and install the shim.  But
      # if you later call this with <tt>:agent_enabled => true</tt>,
      # then it will install the real agent and start it.
      #
      # What determines whether the agent is launched is the result of
      # calling agent_enabled?  This will indicate whether the
      # instrumentation should/will be installed.  If we're in a mode
      # where tracers are not installed then we should not start the
      # agent.
      #
      # Subclasses are not allowed to override, but must implement
      # init_config({}) which is called one or more times.
      #
      def init_plugin: (?::Hash[untyped, untyped] options) -> untyped

      def determine_env: (untyped options) -> untyped

      def configure_agent: (untyped env, untyped options) -> untyped

      def security_settings_valid?: () -> untyped

      def handle_invalid_security_settings: () -> untyped

      # Install the real agent into the Agent module, and issue the start command.
      def start_agent: () -> untyped

      def app: () -> untyped

      def framework: () -> untyped

      # for backward compatibility with the old config interface
      def []: (untyped key) -> untyped

      def settings: () -> untyped

      def dispatcher: () -> untyped

      # Delegates to the class method newrelic_root, implemented by
      # each subclass
      def newrelic_root: () -> untyped

      def initialize: (untyped local_env, ?untyped? config_file_override) -> void

      def root: () -> "."

      def stdout: () -> untyped
    end

    include InstanceMethods
  end
end

module NewRelic
  class Control
    class Server
      # Structs holding info for the remote server and proxy server
      # :nodoc:
      def to_s: () -> ::String
    end

    # Contains methods that deal with connecting to the server
    module ServerMethods
      def server: () -> untyped

      # the server we should contact for api requests, like uploading
      # deployments and the like
      def api_server: () -> untyped

      def server_from_host: (?untyped? hostname) -> untyped
    end

    include ServerMethods
  end
end

module NewRelic
  class Control
    module Frameworks
      # Control subclass instantiated when Rails is detected.  Contains
      # Rails 3.0+  specific configuration, instrumentation, environment values,
      # etc. Many methods are inherited from the
      # NewRelic::Control::Frameworks::Rails class, where the two do
      # not differ
      class Rails3 < NewRelic::Control::Frameworks::Rails
        def env: () -> untyped

        def rails_root: () -> untyped

        def vendor_root: () -> untyped

        def version: () -> untyped

        def install_shim: () -> untyped
      end
    end
  end
end

module NewRelic
  class Control
    module Frameworks
      # This is the control used when starting up in the context of
      # The New Relic Infrastructure Agent.  We want to call this
      # out specifically because in this context we are not monitoring
      # the running process, but actually external things.
      class External < NewRelic::Control::Frameworks::Ruby
        def init_config: (?::Hash[untyped, untyped] options) -> untyped
      end
    end
  end
end

module NewRelic
  class Control
    module Frameworks
      # Contains basic control logic for Sinatra
      class Sinatra < NewRelic::Control::Frameworks::Ruby
        def install_shim: () -> untyped
      end
    end
  end
end

module NewRelic
  class Control
    module Frameworks
      # Control subclass instantiated when Rails is detected.  Contains
      # Rails specific configuration, instrumentation, environment values,
      # etc.
      class Rails < NewRelic::Control::Frameworks::Ruby
        def env: () -> untyped

        # Rails can return an empty string from this method, causing
        # the agent not to start even when it is properly in a rails 3
        # application, so we test the value to make sure it actually
        # has contents, and bail to the parent class if it is empty.
        def root: () -> untyped

        def rails_root: () -> untyped

        def rails_config: () -> untyped

        # In versions of Rails prior to 2.0, the rails config was only available to
        # the init.rb, so it had to be passed on from there.  This is a best effort to
        # find a config and use that.
        def init_config: (?::Hash[untyped, untyped] options) -> untyped

        def install_agent_hooks: (untyped config) -> (nil | untyped)

        def install_browser_monitoring: (untyped config) -> untyped

        def rails_version: () -> untyped

        def rails_vendor_root: () -> untyped

        def install_shim: () -> untyped
      end
    end
  end
end

module NewRelic
  class Control
    module Frameworks
      # A control used when no framework is detected - the default.
      class Ruby < NewRelic::Control
        def env: () -> untyped

        def root: () -> untyped

        def init_config: (?::Hash[untyped, untyped] options) -> nil
      end
    end
  end
end

module NewRelic
  class Control
    module Frameworks
      class RailsNotifications < NewRelic::Control::Frameworks::Rails4
      end
    end
  end
end

module NewRelic
  class Control
    module Frameworks
      class Rails4 < NewRelic::Control::Frameworks::Rails3
        def rails_gem_list: () -> untyped

        def append_plugin_list: () -> nil
      end
    end
  end
end

module NewRelic
  class Control
    # Contains methods that relate to adding and executing files that
    # contain instrumentation for the Ruby Agent
    module Instrumentation
      # Adds a list of files in Dir.glob format
      # (e.g. '/app/foo/**/*_instrumentation.rb')
      # This requires the files within a rescue block, so that any
      # errors within instrumentation files do not affect the overall
      # agent or application in which it runs.
      def load_instrumentation_files: (untyped pattern) -> untyped

      def install_shim: () -> nil

      # Add instrumentation.  Don't call this directly.  Use NewRelic::Agent#add_instrumentation.
      # This will load the file synchronously if we've already loaded the default
      # instrumentation, otherwise instrumentation files specified
      # here will be deferred until all instrumentation is run
      #
      # This happens after the agent has loaded and all dependencies
      # are ready to be instrumented
      def add_instrumentation: (untyped pattern) -> untyped

      # Signals the agent that it's time to actually load the
      # instrumentation files. May be overridden by subclasses
      def install_instrumentation: () -> untyped

      private

      def _install_instrumentation: () -> (nil | untyped)
    end

    include Instrumentation
  end
end

# @api public
module NewRelic
  # This module contains Rack middlewares used by the Ruby agent.
  #
  # Generally, these middlewares should be injected automatically when starting
  # your application. If automatic injection into the middleware chain is not
  # working for some reason, you may also include them manually.
  #
  #
  # @api public
  module Rack
  end
end

module DependencyDetection
  def self?.defer: () { () -> untyped } -> untyped

  def self?.detect!: () -> untyped

  def self?.dependency_by_name: (untyped name) -> untyped

  def self?.installed?: (untyped name) -> untyped

  def self?.items: () -> untyped

  def self?.items=: (untyped new_items) -> untyped

  class Dependent
    attr_reader executed: untyped

    attr_accessor name: untyped

    attr_writer config_name: untyped

    attr_reader dependencies: untyped

    attr_reader prepend_conflicts: untyped

    def executed!: () -> untyped

    def config_name: () -> untyped

    def initialize: () -> void

    def dependencies_satisfied?: () -> untyped

    def source_location_for: (untyped klass, untyped method_name) -> untyped

    # Extracts the instrumented library name from the instrumenting module's name
    # Given "NewRelic::Agent::Instrumentation::NetHTTP::Prepend"
    # Will extract "NetHTTP" which is in the 2nd to last spot
    def extract_supportability_name: (untyped instrumenting_module) -> untyped

    def log_and_instrument: (untyped method, untyped instrumenting_module, untyped supportability_name) { () -> untyped } -> untyped

    def prepend_instrument: (untyped target_class, untyped instrumenting_module, ?untyped? supportability_name) -> untyped

    def chain_instrument: (untyped instrumenting_module, ?untyped? supportability_name) -> untyped

    def chain_instrument_target: (untyped target, untyped instrumenting_module, ?untyped? supportability_name) -> untyped

    def execute: () -> untyped

    def check_dependencies: () -> (false | untyped)

    def depends_on: () { () -> untyped } -> untyped

    def allowed_by_config?: () -> untyped

    # TODO: Remove in 8.0
    # will only return true if a disabled key is found and is truthy
    def deprecated_disabled_configured?: () -> (false | true)

    def config_key: () -> (nil | untyped)

    VALID_CONFIG_VALUES: ::Array[:auto | :disabled | :prepend | :chain]

    AUTO_CONFIG_VALUE: untyped

    # returns only a valid value for instrumentation configuration
    # If user uses "enabled" it's converted to "auto"
    def valid_config_value: (untyped retrieved_value) -> untyped

    # fetches and transform potentially invalid value given to one of the valid config values
    # logs the resolved value during debug mode.
    def fetch_config_value: (untyped key) -> untyped

    def config_value: () -> untyped

    def named: (untyped new_name) -> untyped

    def configure_with: (untyped new_config_name) -> untyped

    def executes: () { () -> untyped } -> untyped

    def conflicts_with_prepend: () { () -> untyped } -> untyped

    def use_prepend?: () -> untyped

    def prepend_conflicts?: () -> untyped
  end
end
