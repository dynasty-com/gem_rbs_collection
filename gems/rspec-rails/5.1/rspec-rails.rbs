# Namespace for all core RSpec projects.
module RSpec
  # Namespace for rspec-rails code.
  module Rails
    # Railtie to hook into Rails.
    class Railtie < ::Rails::Railtie
      private

      def setup_preview_path: (untyped app) -> (nil | untyped)

      def config_preview_path?: (untyped options) -> untyped

      def config_default_preview_path: (untyped options) -> (nil | untyped)

      def supports_action_mailer_previews?: (untyped config) -> untyped
    end
  end
end

# @private
# Weirdly named generators namespace (should be `RSpec`) for compatibility with
# rails loading.
module Rspec
  # @private
  module Generators
    # @private
    class Base < ::Rails::Generators::NamedBase
      include RSpec::Rails::FeatureCheck

      def self.source_root: (?untyped? path) -> untyped
    end
  end
end

# @private
module Rails
  module Generators
    # @private
    class GeneratedAttribute
      def input_type: () -> untyped
    end
  end
end

module Rspec
  module Generators
    # @private
    class InstallGenerator < ::Rails::Generators::Base
      def self.source_root: () -> untyped

      def copy_spec_files: () -> untyped

      def copy_rails_files: () -> untyped

      private

      def generate_rspec_init: (untyped tmpdir) -> untyped

      def replace_generator_command: (untyped spec_helper_path) -> untyped

      def remove_warnings_configuration: (untyped spec_helper_path) -> untyped
    end
  end
end


module Rspec
  module Generators
    # @private
    class MailboxGenerator < Base
      def create_mailbox_spec: () -> untyped
    end
  end
end

module Rspec
  module Generators
    # @private
    class IntegrationGenerator < Base
      def generate_request_spec: () -> (nil | untyped)
    end
  end
end


module Rspec
  module Generators
    # @private
    class MailerGenerator < Base
      def generate_mailer_spec: () -> untyped

      def generate_fixtures_files: () -> untyped

      def generate_preview_files: () -> (nil | untyped)
    end
  end
end



module Rspec
  module Generators
    # @private
    class ControllerGenerator < Base
      def generate_request_spec: () -> (nil | untyped)

      def generate_controller_spec: () -> (nil | untyped)

      def generate_view_specs: () -> (nil | untyped)

      def generate_routing_spec: () -> (nil | untyped)
    end
  end
end





module Rspec
  module Generators
    # @private
    class ChannelGenerator < Base
      def create_channel_spec: () -> untyped
    end
  end
end

module Rspec
  module Generators
    # @private
    class GeneratorGenerator < Base
      def generate_generator_spec: () -> (nil | untyped)

      def template_name: () -> "generator_spec.rb"

      def filename: () -> ::String
    end
  end
end


module Rspec
  module Generators
    # @private
    class SystemGenerator < Base
      def generate_system_spec: () -> (nil | untyped)

      def template_name: () -> "system_spec.rb"

      def filename: () -> ::String
    end
  end
end



module Rspec
  module Generators
    # @private
    class ModelGenerator < Base
      def create_model_spec: () -> untyped

      def create_fixture_file: () -> (nil | untyped)

      private

      def missing_fixture_replacement?: () -> untyped
    end
  end
end

module Rspec
  module Generators
    # @private
    class JobGenerator < Base
      def create_job_spec: () -> untyped
    end
  end
end

module Rspec
  module Generators
    # @private
    class ViewGenerator < Base
      def create_view_specs: () -> untyped
    end
  end
end


module Rspec
  module Generators
    # @private
    class RequestGenerator < IntegrationGenerator
    end
  end
end

module Rspec
  module Generators
    # @private
    class FeatureGenerator < Base
      def generate_feature_spec: () -> (nil | untyped)

      def template_name: () -> untyped

      def filename: () -> untyped
    end
  end
end



module Rspec
  module Generators
    # @private
    class ScaffoldGenerator < Base
      include ::Rails::Generators::ResourceHelpers

      def initialize: (*untyped args) { () -> untyped } -> void

      def generate_controller_spec: () -> (nil | untyped)

      def generate_request_spec: () -> (nil | untyped)

      def generate_view_specs: () -> (nil | untyped)

      def generate_routing_spec: () -> (nil | untyped)

      attr_reader generator_args: untyped

      def copy_view: (untyped view) -> untyped

      # support for namespaced-resources
      def ns_file_name: () -> (untyped | ::String)

      # support for namespaced-resources
      def ns_table_name: () -> (untyped | ::String)

      def ns_parts: () -> untyped

      def ns_prefix: () -> untyped

      def ns_suffix: () -> untyped

      def value_for: (untyped attribute) -> untyped

      def raw_value_for: (untyped attribute) -> untyped

      def template_file: (folder: untyped folder, ?suffix: ::String suffix) -> untyped

      def banner: () -> untyped

      def show_helper: (?untyped resource_name) -> ::String
    end
  end
end










module Rspec
  module Generators
    # @private
    class HelperGenerator < Base
      def generate_helper_spec: () -> (nil | untyped)
    end
  end
end



module RSpec
  module Rails
    # @api public
    # Helpers for optionally rendering views in controller specs.
    module ViewRendering
      extend ActiveSupport::Concern

      # @!attribute [r]
      # Returns the controller object instance under test.
      attr_reader controller: untyped

      # @private
      attr_writer controller: untyped

      # DSL methods
      module ClassMethods
        # @see RSpec::Rails::ControllerExampleGroup
        def render_views: (?bool true_or_false) -> untyped

        # @api private
        def render_views?: () -> untyped
      end

      # @api private
      def render_views?: () -> untyped

      # @private
      class EmptyTemplateResolver
        def self.build: (untyped path) -> untyped

        def self.nullify_template_rendering: (untyped templates) -> untyped

        def self.template_format: (untyped template) -> untyped

        # Delegates all methods to the submitted resolver and for all methods
        # that return a collection of `ActionView::Template` instances, return
        # templates with modified source
        #
        # @private
        class ResolverDecorator
          def initialize: (untyped resolver) -> void

          def method_missing: (untyped name, *untyped args) { () -> untyped } -> untyped

          private

          def nullify_templates: (untyped collection) -> untyped
        end

        # Delegates find_templates to the submitted path set and then returns
        # templates with modified source
        #
        # @private
        class FileSystemResolver < ::ActionView::FileSystemResolver
          private

          def find_templates: (*untyped args) -> untyped
        end
      end

      # @private
      class EmptyTemplateHandler
        def self.call: (untyped _template, ?untyped? _source) -> "\"\""
      end

      # Used to null out view rendering in controller specs.
      #
      # @private
      module EmptyTemplates
        def prepend_view_path: (untyped new_path) -> untyped

        def append_view_path: (untyped new_path) -> untyped

        private

        def _path_decorator: (*untyped paths) -> untyped
      end

      # @private
      RESOLVER_CACHE: untyped
    end
  end
end

module RSpec
  module Rails
    # @private
    def self.disable_testunit_autorun: () -> untyped

    # Constant aliased to either Minitest or TestUnit, depending on what is
    # loaded.
    Assertions: untyped

    # @private
    class AssertionDelegator < Module
      def initialize: (*untyped assertion_modules) -> void
    end

    # Adapts example groups for `Minitest::Test::LifecycleHooks`
    #
    # @private
    module MinitestLifecycleAdapter
      extend ActiveSupport::Concern

      def before_setup: () -> nil

      def after_setup: () -> nil

      def before_teardown: () -> nil

      def after_teardown: () -> nil
    end

    # @private
    module MinitestCounters
      attr_writer assertions: untyped

      def assertions: () -> untyped
    end

    # @private
    module SetupAndTeardownAdapter
      extend ActiveSupport::Concern

      module ClassMethods
        # Wraps `setup` calls from within Rails' testing framework in `before`
        # hooks.
        def setup: (*untyped methods) { () -> untyped } -> untyped

        # @api private
        #
        # Wraps `teardown` calls from within Rails' testing framework in
        # `after` hooks.
        def teardown: (*untyped methods) { () -> untyped } -> untyped
      end

      def initialize: (*untyped args) -> void

      def method_name: () -> untyped
    end

    # @private
    module MinitestAssertionAdapter
      extend ActiveSupport::Concern

      # @private
      module ClassMethods
        # Returns the names of assertion methods that we want to expose to
        # examples without exposing non-assertion methods in Test::Unit or
        # Minitest.
        def assertion_method_names: () -> untyped

        def define_assertion_delegators: () -> untyped
      end

      class AssertionDelegator
        # include ::RSpec::Rails::Assertions

        include ::RSpec::Rails::MinitestCounters
      end

      def assertion_delegator: () -> untyped
    end

    # Backwards compatibility. It's unlikely that anyone is using this
    # constant, but we had forgotten to mark it as `@private` earlier
    #
    # @private
    TestUnitAssertionAdapter: untyped
  end
end

module RSpec
  module Rails
    # @private
    module FixtureSupport
      extend ActiveSupport::Concern

      include RSpec::Rails::SetupAndTeardownAdapter

      include RSpec::Rails::MinitestLifecycleAdapter

      include RSpec::Rails::MinitestAssertionAdapter

      include ActiveRecord::TestFixtures

      # @private prevent ActiveSupport::TestFixtures to start a DB transaction.
      # Monkey patched to avoid collisions with 'let(:name)' in Rails 6.1 and after
      # and let(:method_name) before Rails 6.1.
      def run_in_transaction?: () -> untyped

      include Fixtures

      module Fixtures
        extend ActiveSupport::Concern

        def fixtures: (*untyped args) -> untyped

        def proxy_method_warning_if_called_in_before_context_scope: (untyped method_name) -> untyped
      end
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for Rails specific matchers.
    module Matchers
    end
  end
end

module RSpec
  module Rails
    # @private
    module FixtureFileUploadSupport
      private

      def rails_fixture_file_wrapper: () -> untyped

      class RailsFixtureFileWrapper
        include ActionDispatch::TestProcess

        include ActiveSupport::Testing::FileFixtures

        attr_accessor self.fixture_path: untyped

        # Get instance of wrapper
        def self.instance: () -> untyped
      end
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container class for view spec functionality.
    module ViewExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      include ActionView::TestCase::Behavior

      include RSpec::Rails::ViewAssigns

      include RSpec::Rails::Matchers::RenderTemplate

      # @private
      module StubResolverCache
        def self.resolver_for: (untyped hash) -> untyped
      end

      # @private
      module ClassMethods
        def _default_helper: () -> untyped

        def _default_helpers: () -> untyped
      end

      # DSL exposed to view specs.
      module ExampleMethods
        extend ActiveSupport::Concern

        # @overload render
        # @overload render({partial: path_to_file})
        # @overload render({partial: path_to_file}, {... locals ...})
        # @overload render({partial: path_to_file}, {... locals ...}) do ... end
        #
        # Delegates to ActionView::Base#render, so see documentation on that
        # for more info.
        #
        # The only addition is that you can call render with no arguments, and
        # RSpec will pass the top level description to render:
        #
        #     describe "widgets/new.html.erb" do
        #       it "shows all the widgets" do
        #         render # => view.render(file: "widgets/new.html.erb")
        #         # ...
        #       end
        #     end
        def render: (?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] local_assigns) { () -> untyped } -> untyped

        # The instance of `ActionView::Base` that is used to render the template.
        # Use this to stub methods _before_ calling `render`.
        #
        #     describe "widgets/new.html.erb" do
        #       it "shows all the widgets" do
        #         view.stub(:foo) { "foo" }
        #         render
        #         # ...
        #       end
        #     end
        def view: () -> untyped

        # Simulates the presence of a template on the file system by adding a
        # Rails' FixtureResolver to the front of the view_paths list. Designed to
        # help isolate view examples from partials rendered by the view template
        # that is the subject of the example.
        #
        #     stub_template("widgets/_widget.html.erb" => "This content.")
        def stub_template: (untyped hash) -> untyped

        # Provides access to the params hash that will be available within the
        # view.
        #
        #     params[:foo] = 'bar'
        def params: () -> untyped

        # @deprecated Use `view` instead.
        def template: () -> untyped

        # @deprecated Use `rendered` instead.
        def response: () -> untyped

        private

        def _default_render_options: () -> untyped

        def _path_parts: () -> untyped

        def _controller_path: () -> untyped

        def _inferred_action: () -> untyped

        def _include_controller_helpers: () -> untyped
      end

      include ExampleMethods
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for job spec functionality. It is only available if
    # ActiveJob has been loaded before it.
    module JobExampleGroup
    end
  end
end

module RSpec
  module Rails
    # Container module for job spec functionality.
    module JobExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for helper specs.
    module HelperExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      include ActionView::TestCase::Behavior

      include RSpec::Rails::ViewAssigns

      # @private
      module ClassMethods
        def determine_constant_from_test_name: (untyped _ignore) { (untyped) -> untyped } -> untyped
      end

      # Returns an instance of ActionView::Base with the helper being specified
      # mixed in, along with any of the built-in rails helpers.
      def helper: () -> untyped

      private

      def _controller_path: (untyped example) -> untyped
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for channel spec functionality. It is only available if
    # ActionCable has been loaded before it.
    module ChannelExampleGroup
      # @private
      module ClassMethods
      end
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for channel spec functionality.
    module ChannelExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      # include ActionCable::Connection::TestCase::Behavior

      # include ActionCable::Channel::TestCase::Behavior

      # Class-level DSL for channel specs.
      module ClassMethods
        # @private
        def channel_class: () -> untyped

        # @private
        def connection_class: () -> untyped
      end

      # Checks that the connection attempt has been rejected.
      #
      # @example
      #     expect { connect }.to have_rejected_connection
      def have_rejected_connection: () -> untyped

      # Checks that the subscription is subscribed to at least one stream.
      #
      # @example
      #     expect(subscription).to have_streams
      def have_streams: () -> untyped

      # Checks that the channel has been subscribed to the given stream
      #
      # @example
      #     expect(subscription).to have_stream_from("chat_1")
      def have_stream_from: (untyped stream) -> untyped

      # Checks that the channel has been subscribed to a stream for the given model
      #
      # @example
      #     expect(subscription).to have_stream_for(user)
      def have_stream_for: (untyped object) -> untyped
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for mailbox spec functionality.
    module MailboxExampleGroup
      extend ActiveSupport::Concern

      # extend ::ActionMailbox::TestHelper

      # @private
      # def self.create_inbound_email: (untyped arg) -> untyped

      def self.create_inbound_email: (untyped _arg) -> untyped

      # @private
      def mailbox_class: () -> untyped

      # @api public
      # Passes if the inbound email was delivered
      #
      # @example
      #       inbound_email = process(args)
      #       expect(inbound_email).to have_been_delivered
      def have_been_delivered: () -> untyped

      # @api public
      # Passes if the inbound email bounced during processing
      #
      # @example
      #       inbound_email = process(args)
      #       expect(inbound_email).to have_bounced
      def have_bounced: () -> untyped

      # @api public
      # Passes if the inbound email failed to process
      #
      # @example
      #       inbound_email = process(args)
      #       expect(inbound_email).to have_failed
      def have_failed: () -> untyped

      # Process an inbound email message directly, bypassing routing.
      #
      # @param message [Hash, Mail::Message] a mail message or hash of
      #   attributes used to build one
      # @return [ActionMaibox::InboundMessage]
      def process: (untyped message) -> untyped
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Common rails example functionality.
    module RailsExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::SetupAndTeardownAdapter

      include RSpec::Rails::MinitestLifecycleAdapter

      include RSpec::Rails::MinitestAssertionAdapter

      include RSpec::Rails::FixtureSupport
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container class for system tests
    module SystemExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      include RSpec::Rails::Matchers::RedirectTo

      include RSpec::Rails::Matchers::RenderTemplate

      include ActionDispatch::Integration::Runner

      include ActionDispatch::Assertions

      include ActionController::TemplateAssertions

      # Special characters to translate into underscores for #method_name
      CHARS_TO_TRANSLATE: ::Array["/" | "." | ":" | "," | "'" | "\"" | " "]

      # @private
      module BlowAwayTeardownHooks
        # @private
        def before_teardown: () -> nil

        # @private
        def after_teardown: () -> nil
      end

      # for the SystemTesting Screenshot situation
      def passed?: () -> (false | true | untyped)

      # @private
      def method_name: () -> untyped

      # Delegates to `Rails.application`.
      def app: () -> untyped

      attr_reader driver: untyped

      def initialize: (*untyped args) { () -> untyped } -> void

      def driven_by: (untyped driver, **untyped driver_options) { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container class for request spec functionality.
    module RequestExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      include ActionDispatch::Integration::Runner

      include ActionDispatch::Assertions

      include RSpec::Rails::Matchers::RedirectTo

      include RSpec::Rails::Matchers::RenderTemplate

      include ActionController::TemplateAssertions

      include ActionDispatch::IntegrationTest::Behavior

      # Delegates to `Rails.application`.
      def app: () -> untyped
    end
  end
end

module RSpec
  module Rails
    # @private
    RoutingAssertionDelegator: untyped

    # @api public
    # Container module for routing spec functionality.
    module RoutingExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      include RSpec::Rails::Matchers::RoutingMatchers

      include RSpec::Rails::Matchers::RoutingMatchers::RouteHelpers

      # include RSpec::Rails::RoutingAssertionDelegator

      # Class-level DSL for route specs.
      module ClassMethods
        # Specifies the routeset that will be used for the example group. This
        # is most useful when testing Rails engines.
        #
        # @example
        #     describe MyEngine::PostsController do
        #       routes { MyEngine::Engine.routes }
        #
        #       it "routes posts#index" do
        #         expect(:get => "/posts").to
        #           route_to(:controller => "my_engine/posts", :action => "index")
        #       end
        #     end
        def routes: () { () -> untyped } -> untyped
      end

      # @!attribute [r]
      # @private
      attr_reader routes: untyped

      # @private
      def routes=: (untyped routes) -> untyped

      private

      def method_missing: (untyped m, *untyped args) { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for routing spec functionality.
    module FeatureExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      # Default host to be used in Rails route helpers if none is specified.
      DEFAULT_HOST: "www.example.com"

      # Shim to check for presence of Capybara. Will delegate if present, raise
      # if not. We assume here that in most cases `visit` will be the first
      # Capybara method called in a spec.
      def visit: () -> untyped
    end
  end
end

module RSpec
  module Rails
    # @private
    ControllerAssertionDelegator: untyped

    # @api public
    # Container module for controller spec functionality.
    module ControllerExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      include ActionController::TestCase::Behavior

      include RSpec::Rails::ViewRendering

      include RSpec::Rails::Matchers::RedirectTo

      include RSpec::Rails::Matchers::RenderTemplate

      include RSpec::Rails::Matchers::RoutingMatchers

      # include ControllerAssertionDelegator

      # Class-level DSL for controller specs.
      module ClassMethods
        # @private
        def controller_class: () -> untyped

        # Supports a simple DSL for specifying behavior of ApplicationController.
        # Creates an anonymous subclass of ApplicationController and evals the
        # `body` in that context. Also sets up implicit routes for this
        # controller, that are separate from those defined in "config/routes.rb".
        #
        # @note Due to Ruby 1.8 scoping rules in anonymous subclasses, constants
        #   defined in `ApplicationController` must be fully qualified (e.g.
        #   `ApplicationController::AccessDenied`) in the block passed to the
        #   `controller` method. Any instance methods, filters, etc, that are
        #   defined in `ApplicationController`, however, are accessible from
        #   within the block.
        #
        # @example
        #     describe ApplicationController do
        #       controller do
        #         def index
        #           raise ApplicationController::AccessDenied
        #         end
        #       end
        #
        #       describe "handling AccessDenied exceptions" do
        #         it "redirects to the /401.html page" do
        #           get :index
        #           response.should redirect_to("/401.html")
        #         end
        #       end
        #     end
        #
        # If you would like to spec a subclass of ApplicationController, call
        # controller like so:
        #
        #     controller(ApplicationControllerSubclass) do
        #       # ....
        #     end
        def controller: (?untyped? base_class) { () -> untyped } -> untyped

        # Specifies the routeset that will be used for the example group. This
        # is most useful when testing Rails engines.
        #
        # @example
        #     describe MyEngine::PostsController do
        #       routes { MyEngine::Engine.routes }
        #
        #       # ...
        #     end
        def routes: () { () -> untyped } -> untyped
      end

      # @!attribute [r]
      # Returns the controller object instance under test.
      attr_reader controller: untyped

      # @!attribute [r]
      # Returns the Rails routes used for the spec.
      attr_reader routes: untyped

      # @private
      #
      # RSpec Rails uses this to make Rails routes easily available to specs.
      def routes=: (untyped routes) -> untyped

      # @private
      module BypassRescue
        def rescue_with_handler: (untyped exception) -> untyped
      end

      # Extends the controller with a module that overrides
      # `rescue_with_handler` to raise the exception passed to it. Use this to
      # specify that an action _should_ raise an exception given appropriate
      # conditions.
      #
      # @example
      #     describe ProfilesController do
      #       it "raises a 403 when a non-admin user tries to view another user's profile" do
      #         profile = create_profile
      #         login_as profile.user
      #
      #         expect do
      #           bypass_rescue
      #           get :show, id: profile.id + 1
      #         end.to raise_error(/403 Forbidden/)
      #       end
      #     end
      def bypass_rescue: () -> untyped

      # If method is a named_route, delegates to the RouteSet associated with
      # this controller.
      def method_missing: (untyped method, *untyped args) { () -> untyped } -> untyped

      private

      def route_available?: (untyped method) -> untyped

      def route_defined?: (untyped routes, untyped method) -> (false | untyped)
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container class for model spec functionality. Does not provide anything
    # special over the common RailsExampleGroup currently.
    module ModelExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup
    end
  end
end

module RSpec
  module Rails
    # @api public
    # Container module for mailer spec functionality. It is only available if
    # ActionMailer has been loaded before it.
    module MailerExampleGroup
    end
  end
end

module RSpec
  module Rails
    # Container module for mailer spec functionality.
    module MailerExampleGroup
      extend ActiveSupport::Concern

      include RSpec::Rails::RailsExampleGroup

      # include ActionMailer::TestCase::Behavior

      # Class-level DSL for mailer specs.
      module ClassMethods
        # Alias for `described_class`.
        def mailer_class: () -> untyped
      end
    end
  end
end


module RSpec
  module Rails
    # Helpers for making instance variables available to views.
    module ViewAssigns
      # Assigns a value to an instance variable in the scope of the
      # view being rendered.
      #
      # @example
      #
      #     assign(:widget, stub_model(Widget))
      def assign: (untyped key, untyped value) -> untyped

      # Compat-shim for AbstractController::Rendering#view_assigns
      #
      # _assigns was deprecated in favor of view_assigns after
      # Rails-3.0.0 was released. Since we are not able to predict when
      # the _assigns/view_assigns patch will be released (I thought it
      # would have been in 3.0.1, but 3.0.1 bypassed this change for a
      # security fix), this bit ensures that we do the right thing without
      # knowing anything about the Rails version we are dealing with.
      #
      # Once that change _is_ released, this can be changed to something
      # that checks for the Rails version when the module is being
      # interpreted, as it was before commit dd0095.
      def view_assigns: () -> untyped

      # @private
      def _assigns: () -> untyped

      private

      def _encapsulated_assigns: () -> untyped
    end
  end
end



module RSpec
  module Rails
    # Fake class to document RSpec ActiveRecord configuration options. In practice,
    # these are dynamically added to the normal RSpec configuration object.
    class ActiveRecordConfiguration
      # @private
      def self.initialize_activerecord_configuration: (untyped config) -> untyped
    end
  end
end

module RSpec
  module Rails
    # Version information for RSpec Rails.
    module Version
      # Current version of RSpec Rails, in semantic versioning format.
      STRING: "6.0.0.pre"
    end
  end
end


module RSpec
  module Rails
    module Matchers
      # Namespace for various implementations of `have_http_status`.
      #
      # @api private
      module HaveHttpStatus
        # Instantiates an instance of the proper matcher based on the provided
        # `target`.
        #
        # @param target [Object] expected http status or code
        # @return response matcher instance
        def self.matcher_for_status: (untyped target) -> untyped

        # @api private
        # Conversion function to coerce the provided object into an
        # `ActionDispatch::TestResponse`.
        #
        # @param obj [Object] object to convert to a response
        # @return [ActionDispatch::TestResponse]
        def self?.as_test_response: (untyped obj) -> untyped

        # @return [String, nil] a formatted failure message if
        #   `@invalid_response` is present, `nil` otherwise
        def invalid_response_type_message: () -> (nil | ::String)

        # @api private
        # Provides an implementation for `have_http_status` matching against
        # numeric http status codes.
        #
        # Not intended to be instantiated directly.
        #
        # @example
        #   expect(response).to have_http_status(404)
        #
        # @see RSpec::Rails::Matchers#have_http_status
        class NumericCode < RSpec::Rails::Matchers::BaseMatcher
          include HaveHttpStatus

          def initialize: (untyped code) -> void

          # @param [Object] response object providing an http code to match
          # @return [Boolean] `true` if the numeric code matched the `response` code
          def matches?: (untyped response) -> untyped

          # @return [String]
          def description: () -> ::String

          # @return [String] explaining why the match failed
          def failure_message: () -> untyped

          # @return [String] explaining why the match failed
          def failure_message_when_negated: () -> untyped
        end

        # @api private
        # Provides an implementation for `have_http_status` matching against
        # Rack symbol http status codes.
        #
        # Not intended to be instantiated directly.
        #
        # @example
        #   expect(response).to have_http_status(:created)
        #
        # @see RSpec::Rails::Matchers#have_http_status
        # @see https://github.com/rack/rack/blob/master/lib/rack/utils.rb `Rack::Utils::SYMBOL_TO_STATUS_CODE`
        class SymbolicStatus < RSpec::Rails::Matchers::BaseMatcher
          include HaveHttpStatus

          def initialize: (untyped status) -> void

          # @param [Object] response object providing an http code to match
          # @return [Boolean] `true` if Rack's associated numeric HTTP code matched
          #   the `response` code
          def matches?: (untyped response) -> untyped

          # @return [String]
          def description: () -> ::String

          # @return [String] explaining why the match failed
          def failure_message: () -> untyped

          # @return [String] explaining why the match failed
          def failure_message_when_negated: () -> untyped

          private

          # The initialized expected status symbol
          attr_reader expected_status: untyped

          # @return [Symbol] representing the actual http numeric code
          def actual_status: () -> (nil | untyped)

          # Reverse lookup of the Rack status code symbol based on the numeric
          # http code
          #
          # @param code [Fixnum] http status code to look up
          # @return [Symbol] representing the http numeric code
          def compute_status_from: (untyped code) -> untyped

          # @return [String] pretty format the actual response status
          def pp_actual: () -> untyped

          # @return [String] pretty format the expected status and associated code
          def pp_expected: () -> untyped

          # @return [String] pretty format the actual response status
          def pp_status: (untyped status, untyped code) -> untyped

          # Sets `expected` to the numeric http code based on the Rack
          # `expected_status` status
          #
          # @see Rack::Utils::SYMBOL_TO_STATUS_CODE
          # @raise [ArgumentError] if an associated code could not be found
          def set_expected_code!: () -> untyped
        end

        # @api private
        # Provides an implementation for `have_http_status` matching against
        # `ActionDispatch::TestResponse` http status category queries.
        #
        # Not intended to be instantiated directly.
        #
        # @example
        #   expect(response).to have_http_status(:success)
        #   expect(response).to have_http_status(:error)
        #   expect(response).to have_http_status(:missing)
        #   expect(response).to have_http_status(:redirect)
        #
        # @see RSpec::Rails::Matchers#have_http_status
        # @see https://github.com/rails/rails/blob/6-0-stable/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
        class GenericStatus < RSpec::Rails::Matchers::BaseMatcher
          include HaveHttpStatus

          # @return [Array<Symbol>] of status codes which represent a HTTP status
          #   code "group"
          # @see https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
          def self.valid_statuses: () -> ::Array[:error | :success | :missing | :server_error | :successful | :not_found | :redirect]

          def initialize: (untyped `type`) -> void

          # @return [Boolean] `true` if Rack's associated numeric HTTP code matched
          #   the `response` code or the named response status
          def matches?: (untyped response) -> untyped

          # @return [String]
          def description: () -> ::String

          # @return [String] explaining why the match failed
          def failure_message: () -> untyped

          # @return [String] explaining why the match failed
          def failure_message_when_negated: () -> untyped

          RESPONSE_METHODS: { success: "successful", error: "server_error", missing: "not_found" }

          def check_expected_status: (untyped test_response, untyped expected) -> untyped

          private

          # @return [String] formatting the expected status and associated code(s)
          def type_message: () -> untyped

          # @return [String] formatting the associated code(s) for the various
          #   status code "groups"
          # @see https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
          # @see https://github.com/rack/rack/blob/master/lib/rack/response.rb `Rack::Response`
          def type_codes: () -> untyped
        end
      end

      # @api public
      # Passes if `response` has a matching HTTP status code.
      #
      # The following symbolic status codes are allowed:
      #
      # - `Rack::Utils::SYMBOL_TO_STATUS_CODE`
      # - One of the defined `ActionDispatch::TestResponse` aliases:
      #   - `:error`
      #   - `:missing`
      #   - `:redirect`
      #   - `:success`
      #
      # @example Accepts numeric and symbol statuses
      #   expect(response).to have_http_status(404)
      #   expect(response).to have_http_status(:created)
      #   expect(response).to have_http_status(:success)
      #   expect(response).to have_http_status(:error)
      #   expect(response).to have_http_status(:missing)
      #   expect(response).to have_http_status(:redirect)
      #
      # @example Works with standard `response` objects and Capybara's `page`
      #   expect(response).to have_http_status(404)
      #   expect(page).to     have_http_status(:created)
      #
      # @see https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/testing/test_response.rb `ActionDispatch::TestResponse`
      # @see https://github.com/rack/rack/blob/master/lib/rack/utils.rb `Rack::Utils::SYMBOL_TO_STATUS_CODE`
      def have_http_status: (untyped target) -> untyped
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # Matcher for template rendering.
      module RenderTemplate
        # @private
        class RenderTemplateMatcher < RSpec::Rails::Matchers::BaseMatcher
          def initialize: (untyped scope, untyped expected, ?untyped? message) -> void

          # @api private
          def matches?: () -> untyped

          # Uses normalize_argument_to_redirection to find and format
          # the redirect location. normalize_argument_to_redirection is private
          # in ActionDispatch::Assertions::ResponseAssertions so we call it
          # here using #send. This will keep the error message format consistent
          # @api private
          def check_redirect: () -> (nil | untyped)

          # @api private
          def failure_message: () -> untyped

          # @api private
          def failure_message_when_negated: () -> ::String
        end

        # Delegates to `assert_template`.
        #
        # @example
        #     expect(response).to have_rendered("new")
        def have_rendered: (untyped options, ?untyped? message) -> untyped

        alias render_template have_rendered
      end
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # @api private
      #
      # Matcher class for `be_a_new`. Should not be instantiated directly.
      #
      # @see RSpec::Rails::Matchers#be_a_new
      class BeANew < RSpec::Rails::Matchers::BaseMatcher
        # @private
        def initialize: (untyped expected) -> void

        # @private
        def matches?: (untyped actual) -> untyped

        # @api public
        # @see RSpec::Rails::Matchers#be_a_new
        def with: (untyped expected_attributes) -> untyped

        # @private
        def failure_message: () -> untyped

        private

        def attributes: () -> untyped

        def attributes_match?: (untyped actual) -> untyped

        def unmatched_attributes: () -> untyped
      end

      # @api public
      # Passes if actual is an instance of `model_class` and returns `true` for
      # `new_record?`. Typically used to specify instance variables assigned to
      # views by controller actions
      #
      # Use the `with` method to specify the specific attributes to match on the
      # new record.
      #
      # @example
      #     get :new
      #     assigns(:thing).should be_a_new(Thing)
      #
      #     post :create, :thing => { :name => "Illegal Value" }
      #     assigns(:thing).should be_a_new(Thing).with(:name => nil)
      def be_a_new: (untyped model_class) -> untyped
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # @api private
      #
      # Base class to build matchers. Should not be instantiated directly.
      class BaseMatcher
        include RSpec::Matchers::Composable

        # @api private
        # Used to detect when no arg is passed to `initialize`.
        # `nil` cannot be used because it's a valid value to pass.
        UNDEFINED: untyped

        # @private
        attr_reader actual: untyped

        # @private
        attr_reader expected: untyped

        # @private
        attr_reader rescued_exception: untyped

        # @private
        attr_writer matcher_name: untyped

        def initialize: (?untyped expected) -> void

        # @api private
        # Indicates if the match is successful. Delegates to `match`, which
        # should be defined on a subclass. Takes care of consistently
        # initializing the `actual` attribute.
        def matches?: (untyped actual) -> untyped

        # @api private
        # Used to wrap a block of code that will indicate failure by
        # raising one of the named exceptions.
        #
        # This is used by rspec-rails for some of its matchers that
        # wrap rails' assertions.
        def match_unless_raises: (*untyped exceptions) { () -> untyped } -> untyped

        # @api private
        # Generates a description using {RSpec::Matchers::EnglishPhrasing}.
        # @return [String]
        def description: () -> untyped

        # @api private
        # Matchers are not diffable by default. Override this to make your
        # subclass diffable.
        def diffable?: () -> false

        # @api private
        # Most matchers are value matchers (i.e. meant to work with `expect(value)`)
        # rather than block matchers (i.e. meant to work with `expect { }`), so
        # this defaults to false. Block matchers must override this to return true.
        def supports_block_expectations?: () -> false

        # @api private
        def expects_call_stack_jump?: () -> false

        # @private
        def expected_formatted: () -> untyped

        # @private
        def actual_formatted: () -> untyped

        # @private
        def self.matcher_name: () -> untyped

        # @private
        def matcher_name: () -> untyped

        # @private
        # Borrowed from ActiveSupport.
        def self.underscore: (untyped camel_cased_word) -> untyped

        private

        def assert_ivars: (*untyped expected_ivars) -> (nil | untyped)

        alias present_ivars instance_variables

        # @private
        module HashFormatting
          # `{ :a => 5, :b => 2 }.inspect` produces:
          #
          #     {:a=>5, :b=>2}
          #
          # ...but it looks much better as:
          #
          #     {:a => 5, :b => 2}
          #
          # This is idempotent and safe to run on a string multiple times.
          def self?.improve_hash_formatting: (untyped inspect_string) -> untyped
        end

        include HashFormatting

        # @api private
        # Provides default implementations of failure messages, based on the `description`.
        module DefaultFailureMessages
          # @api private
          # Provides a good generic failure message. Based on `description`.
          # When subclassing, if you are not satisfied with this failure message
          # you often only need to override `description`.
          # @return [String]
          def failure_message: () -> ::String

          # @api private
          # Provides a good generic negative failure message. Based on `description`.
          # When subclassing, if you are not satisfied with this failure message
          # you often only need to override `description`.
          # @return [String]
          def failure_message_when_negated: () -> ::String

          # @private
          def self.has_default_failure_messages?: (untyped matcher) -> untyped
        end

        include DefaultFailureMessages
      end
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # @private
      class BeANewRecord < RSpec::Rails::Matchers::BaseMatcher
        def matches?: (untyped actual) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String
      end

      # @api public
      # Passes if actual returns `true` for `new_record?`.
      #
      # @example
      #     get :new
      #     expect(assigns(:thing)).to be_new_record
      def be_new_record: () -> untyped
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # Matcher for redirects.
      module RedirectTo
        # @private
        class RedirectTo < RSpec::Rails::Matchers::BaseMatcher
          def initialize: (untyped scope, untyped expected) -> void

          def matches?: (untyped _) -> untyped

          def failure_message: () -> untyped

          def failure_message_when_negated: () -> ::String
        end

        # Delegates to `assert_redirected_to`.
        #
        # @example
        #     expect(response).to redirect_to(:action => "new")
        def redirect_to: (untyped target) -> untyped
      end
    end
  end
end

module RSpec
  module Rails
    module Matchers
      module ActionCable
        # @api private
        # Provides the implementation for `have_stream`, `have_stream_for`, and `have_stream_from`.
        # Not intended to be instantiated directly.
        class HaveStream < RSpec::Matchers::BuiltIn::BaseMatcher
          # @api private
          # @return [String]
          def failure_message: () -> ::String

          # @api private
          # @return [String]
          def failure_message_when_negated: () -> ::String

          # @api private
          # @return [Boolean]
          def matches?: (untyped subscription) -> untyped

          # @api private
          # @return [Boolean]
          def does_not_match?: (untyped subscription) -> untyped

          private

          def match: (untyped subscription) -> untyped

          def base_message: () -> untyped

          def no_expected?: () -> untyped
        end
      end
    end
  end
end

module RSpec
  module Rails
    module Matchers
      module ActionCable
        # rubocop: disable Metrics/ClassLength
        # @private
        class HaveBroadcastedTo < RSpec::Matchers::BuiltIn::BaseMatcher
          def initialize: (untyped target, channel: untyped channel) -> void

          def with: (?untyped? data) { () -> untyped } -> untyped

          def exactly: (untyped count) -> untyped

          def at_least: (untyped count) -> untyped

          def at_most: (untyped count) -> untyped

          def times: () -> untyped

          def once: () -> untyped

          def twice: () -> untyped

          def thrice: () -> untyped

          def failure_message: () -> untyped

          def failure_message_when_negated: () -> ::String

          def message_expectation_modifier: () -> untyped

          def supports_block_expectations?: () -> true

          def matches?: (untyped proc) -> untyped

          def from_channel: (untyped channel) -> untyped

          private

          def stream: () -> untyped

          def check: (untyped messages) -> untyped

          def set_expected_number: (untyped relativity, untyped count) -> untyped

          def base_message: () -> untyped

          def data_description: (untyped data) -> untyped

          def pubsub_adapter: () -> untyped

          def check_channel_presence: () -> (nil | untyped)
        end
      end
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # Namespace for various implementations of ActionCable features
      #
      # @api private
      module ActionCable
      end

      # @api public
      # Passes if a message has been sent to a stream/object inside a block.
      # May chain `at_least`, `at_most` or `exactly` to specify a number of times.
      # To specify channel from which message has been broadcasted to object use `from_channel`.
      #
      #
      # @example
      #     expect {
      #       ActionCable.server.broadcast "messages", text: 'Hi!'
      #     }.to have_broadcasted_to("messages")
      #
      #     expect {
      #       SomeChannel.broadcast_to(user)
      #     }.to have_broadcasted_to(user).from_channel(SomeChannel)
      #
      #     # Using alias
      #     expect {
      #       ActionCable.server.broadcast "messages", text: 'Hi!'
      #     }.to broadcast_to("messages")
      #
      #     expect {
      #       ActionCable.server.broadcast "messages", text: 'Hi!'
      #       ActionCable.server.broadcast "all", text: 'Hi!'
      #     }.to have_broadcasted_to("messages").exactly(:once)
      #
      #     expect {
      #       3.times { ActionCable.server.broadcast "messages", text: 'Hi!' }
      #     }.to have_broadcasted_to("messages").at_least(2).times
      #
      #     expect {
      #       ActionCable.server.broadcast "messages", text: 'Hi!'
      #     }.to have_broadcasted_to("messages").at_most(:twice)
      #
      #     expect {
      #       ActionCable.server.broadcast "messages", text: 'Hi!'
      #     }.to have_broadcasted_to("messages").with(text: 'Hi!')
      def have_broadcasted_to: (?untyped? target) -> untyped

      alias broadcast_to have_broadcasted_to

      private

      # @private
      def check_action_cable_adapter: () -> (nil | untyped)
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # Matchers to help with specs for routing code.
      module RoutingMatchers
        extend RSpec::Matchers::DSL

        # @private
        class RouteToMatcher < RSpec::Rails::Matchers::BaseMatcher
          def initialize: (untyped scope, *untyped expected) -> void

          def matches?: (untyped verb_to_path_map) -> untyped

          def failure_message: () -> untyped

          def failure_message_when_negated: () -> ::String

          def description: () -> ::String
        end

        # Delegates to `assert_recognizes`. Supports short-hand controller/action
        # declarations (e.g. `"controller#action"`).
        #
        # @example
        #
        #     expect(get: "/things/special").to route_to(
        #       controller: "things",
        #       action:     "special"
        #     )
        #
        #     expect(get: "/things/special").to route_to("things#special")
        #
        # @see https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_recognizes
        def route_to: (*untyped expected) -> untyped

        # @private
        class BeRoutableMatcher < RSpec::Rails::Matchers::BaseMatcher
          def initialize: (untyped scope) -> void

          def matches?: (untyped path) -> untyped

          def failure_message: () -> ::String

          def failure_message_when_negated: () -> ::String

          def description: () -> "be routable"
        end

        # Passes if the route expression is recognized by the Rails router based on
        # the declarations in `config/routes.rb`. Delegates to
        # `RouteSet#recognize_path`.
        #
        # @example You can use route helpers provided by rspec-rails.
        #     expect(get:  "/a/path").to be_routable
        #     expect(post: "/another/path").to be_routable
        #     expect(put:  "/yet/another/path").to be_routable
        def be_routable: () -> untyped

        # Helpers for matching different route types.
        module RouteHelpers
        end
      end
    end
  end
end

# rubocop: disable Metrics/ClassLength
module RSpec
  module Rails
    module Matchers
      # Matcher class for `have_enqueued_mail`. Should not be instantiated directly.
      #
      # @private
      # @see RSpec::Rails::Matchers#have_enqueued_mail
      class HaveEnqueuedMail < ActiveJob::HaveEnqueuedJob
        MAILER_JOB_METHOD: "deliver_now"

        include RSpec::Mocks::ArgumentMatchers

        def initialize: (untyped mailer_class, untyped method_name) -> void

        def description: () -> ::String

        def with: (*untyped args) { () -> untyped } -> untyped

        def matches?: (untyped block) -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> ::String

        private

        def base_message: () -> untyped

        def expected_count_message: () -> ::String

        def mailer_class_name: () -> untyped

        def job_match?: (untyped job) -> untyped

        def arguments_match?: (untyped job) -> untyped

        def base_mailer_args: () -> ::Array[untyped]

        def yield_mail_args: (untyped block) -> untyped

        def check_active_job_adapter: () -> (nil | untyped)

        def unmatching_mail_jobs: () -> untyped

        def unmatching_mail_jobs_message: () -> untyped

        def mail_job_message: (untyped job) -> untyped

        # Ruby 3.1 changed how params were serialized on Rails 6.1
        # so we override the active job implementation and customize it here.
        def deserialize_arguments: (untyped job) -> untyped

        def legacy_mail?: (untyped job) -> untyped

        def parameterized_mail?: (untyped job) -> untyped

        def unified_mail?: (untyped job) -> untyped
      end

      # @api public
      # Passes if an email has been enqueued inside block.
      # May chain with to specify expected arguments.
      # May chain at_least, at_most or exactly to specify a number of times.
      # May chain at to specify a send time.
      # May chain on_queue to specify a queue.
      #
      # @example
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #     }.to have_enqueued_mail
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #     }.to have_enqueued_mail(MyMailer)
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #     }.to have_enqueued_mail(MyMailer, :welcome)
      #
      #     # Using alias
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #     }.to enqueue_mail(MyMailer, :welcome)
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #     }.to have_enqueued_mail(MyMailer, :welcome).with(user)
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #       MyMailer.welcome(user).deliver_later
      #     }.to have_enqueued_mail(MyMailer, :welcome).at_least(:once)
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later
      #     }.to have_enqueued_mail(MyMailer, :welcome).at_most(:twice)
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later(wait_until: Date.tomorrow.noon)
      #     }.to have_enqueued_mail(MyMailer, :welcome).at(Date.tomorrow.noon)
      #
      #     expect {
      #       MyMailer.welcome(user).deliver_later(queue: :urgent_mail)
      #     }.to have_enqueued_mail(MyMailer, :welcome).on_queue(:urgent_mail)
      def have_enqueued_mail: (?untyped? mailer_class, ?untyped? mail_method_name) -> untyped

      alias have_enqueued_email have_enqueued_mail

      alias enqueue_mail have_enqueued_mail

      alias enqueue_email have_enqueued_mail
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # @private
      class BeValid < RSpec::Matchers::BuiltIn::Be
        def initialize: (*untyped args) -> void

        def matches?: (untyped actual) -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> ::String
      end

      # @api public
      # Passes if the given model instance's `valid?` method is true, meaning
      # all of the `ActiveModel::Validations` passed and no errors exist. If a
      # message is not given, a default message is shown listing each error.
      #
      # @example
      #     thing = Thing.new
      #     expect(thing).to be_valid
      def be_valid: (*untyped args) -> untyped
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # Namespace for various implementations of ActionMailbox features
      #
      # @api private
      module ActionMailbox
        # @private
        class Base < RSpec::Rails::Matchers::BaseMatcher
          private

          def create_inbound_email: (untyped message) -> untyped
        end

        # @private
        class ReceiveInboundEmail < Base
          def initialize: (untyped message) -> void

          def matches?: (untyped mailbox) -> untyped

          def failure_message: () -> untyped

          def failure_message_when_negated: () -> ::String

          private

          attr_reader inbound_email: untyped

          attr_reader mailbox: untyped

          attr_reader receiver: untyped

          def describe_inbound_email: () -> ::String
        end
      end

      # @api public
      # Passes if the given inbound email would be routed to the subject inbox.
      #
      # @param message [Hash, Mail::Message] a mail message or hash of
      #   attributes used to build one
      def receive_inbound_email: (untyped message) -> untyped
    end
  end
end

module RSpec
  module Rails
    module Matchers
      # Namespace for various implementations of ActiveJob features
      #
      # @api private
      module ActiveJob
        # rubocop: disable Metrics/ClassLength
        # @private
        class Base < RSpec::Rails::Matchers::BaseMatcher
          def initialize: () -> void

          def with: (*untyped args) { () -> untyped } -> untyped

          def on_queue: (untyped queue) -> untyped

          def at: (untyped time_or_date) -> untyped

          def exactly: (untyped count) -> untyped

          def at_least: (untyped count) -> untyped

          def at_most: (untyped count) -> untyped

          def times: () -> untyped

          def once: () -> untyped

          def twice: () -> untyped

          def thrice: () -> untyped

          def failure_message: () -> untyped

          def failure_message_when_negated: () -> ::String

          def message_expectation_modifier: () -> untyped

          def supports_block_expectations?: () -> true

          private

          def check: (untyped jobs) -> untyped

          def base_message: () -> untyped

          def base_job_message: (untyped job) -> untyped

          def job_match?: (untyped job) -> untyped

          def arguments_match?: (untyped job) -> untyped

          def queue_match?: (untyped job) -> (true | untyped)

          def at_match?: (untyped job) -> (true | untyped | false)

          def check_for_inprecise_value: (untyped scheduled_at) -> (nil | false)

          def set_expected_number: (untyped relativity, untyped count) -> untyped

          def serialize_and_deserialize_arguments: (untyped args) -> untyped

          def deserialize_arguments: (untyped job) -> untyped

          def queue_adapter: () -> untyped
        end

        # @private
        class HaveEnqueuedJob < Base
          FAILURE_MESSAGE_EXPECTATION_ACTION: "enqueue"

          MESSAGE_EXPECTATION_ACTION: "enqueued"

          def initialize: (untyped job) -> void

          def matches?: (untyped proc) -> untyped

          def does_not_match?: (untyped proc) -> untyped
        end

        # @private
        class HaveBeenEnqueued < Base
          FAILURE_MESSAGE_EXPECTATION_ACTION: "enqueue"

          MESSAGE_EXPECTATION_ACTION: "enqueued"

          def matches?: (untyped job) -> untyped

          def does_not_match?: (untyped proc) -> untyped
        end

        # @private
        class HavePerformedJob < Base
          FAILURE_MESSAGE_EXPECTATION_ACTION: "perform"

          MESSAGE_EXPECTATION_ACTION: "performed"

          def initialize: (untyped job) -> void

          def matches?: (untyped proc) -> untyped
        end

        # @private
        class HaveBeenPerformed < Base
          FAILURE_MESSAGE_EXPECTATION_ACTION: "perform"

          MESSAGE_EXPECTATION_ACTION: "performed"

          def matches?: (untyped job) -> untyped
        end
      end

      # @api public
      # Passes if a job has been enqueued inside block. May chain at_least, at_most or exactly to specify a number of times.
      #
      # @example
      #     expect {
      #       HeavyLiftingJob.perform_later
      #     }.to have_enqueued_job
      #
      #     # Using alias
      #     expect {
      #       HeavyLiftingJob.perform_later
      #     }.to enqueue_job
      #
      #     expect {
      #       HelloJob.perform_later
      #       HeavyLiftingJob.perform_later
      #     }.to have_enqueued_job(HelloJob).exactly(:once)
      #
      #     expect {
      #       3.times { HelloJob.perform_later }
      #     }.to have_enqueued_job(HelloJob).at_least(2).times
      #
      #     expect {
      #       HelloJob.perform_later
      #     }.to have_enqueued_job(HelloJob).at_most(:twice)
      #
      #     expect {
      #       HelloJob.perform_later
      #       HeavyLiftingJob.perform_later
      #     }.to have_enqueued_job(HelloJob).and have_enqueued_job(HeavyLiftingJob)
      #
      #     expect {
      #       HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
      #     }.to have_enqueued_job.with(42).on_queue("low").at(Date.tomorrow.noon)
      #
      #     expect {
      #       HelloJob.set(queue: "low").perform_later(42)
      #     }.to have_enqueued_job.with(42).on_queue("low").at(:no_wait)
      #
      #     expect {
      #       HelloJob.perform_later('rspec_rails', 'rails', 42)
      #     }.to have_enqueued_job.with { |from, to, times|
      #       # Perform more complex argument matching using dynamic arguments
      #       expect(from).to include "_#{to}"
      #     }
      def have_enqueued_job: (?untyped? job) -> untyped

      alias enqueue_job have_enqueued_job

      # @api public
      # Passes if a job has been enqueued. May chain at_least, at_most or exactly to specify a number of times.
      #
      # @example
      #     before { ActiveJob::Base.queue_adapter.enqueued_jobs.clear }
      #
      #     HeavyLiftingJob.perform_later
      #     expect(HeavyLiftingJob).to have_been_enqueued
      #
      #     HelloJob.perform_later
      #     HeavyLiftingJob.perform_later
      #     expect(HeavyLiftingJob).to have_been_enqueued.exactly(:once)
      #
      #     3.times { HelloJob.perform_later }
      #     expect(HelloJob).to have_been_enqueued.at_least(2).times
      #
      #     HelloJob.perform_later
      #     expect(HelloJob).to enqueue_job(HelloJob).at_most(:twice)
      #
      #     HelloJob.perform_later
      #     HeavyLiftingJob.perform_later
      #     expect(HelloJob).to have_been_enqueued
      #     expect(HeavyLiftingJob).to have_been_enqueued
      #
      #     HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
      #     expect(HelloJob).to have_been_enqueued.with(42).on_queue("low").at(Date.tomorrow.noon)
      #
      #     HelloJob.set(queue: "low").perform_later(42)
      #     expect(HelloJob).to have_been_enqueued.with(42).on_queue("low").at(:no_wait)
      def have_been_enqueued: () -> untyped

      # @api public
      # Passes if a job has been performed inside block. May chain at_least, at_most or exactly to specify a number of times.
      #
      # @example
      #     expect {
      #       perform_jobs { HeavyLiftingJob.perform_later }
      #     }.to have_performed_job
      #
      #     expect {
      #       perform_jobs {
      #         HelloJob.perform_later
      #         HeavyLiftingJob.perform_later
      #       }
      #     }.to have_performed_job(HelloJob).exactly(:once)
      #
      #     expect {
      #       perform_jobs { 3.times { HelloJob.perform_later } }
      #     }.to have_performed_job(HelloJob).at_least(2).times
      #
      #     expect {
      #       perform_jobs { HelloJob.perform_later }
      #     }.to have_performed_job(HelloJob).at_most(:twice)
      #
      #     expect {
      #       perform_jobs {
      #         HelloJob.perform_later
      #         HeavyLiftingJob.perform_later
      #       }
      #     }.to have_performed_job(HelloJob).and have_performed_job(HeavyLiftingJob)
      #
      #     expect {
      #       perform_jobs {
      #         HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
      #       }
      #     }.to have_performed_job.with(42).on_queue("low").at(Date.tomorrow.noon)
      def have_performed_job: (?untyped? job) -> untyped

      alias perform_job have_performed_job

      # @api public
      # Passes if a job has been performed. May chain at_least, at_most or exactly to specify a number of times.
      #
      # @example
      #     before do
      #       ActiveJob::Base.queue_adapter.performed_jobs.clear
      #       ActiveJob::Base.queue_adapter.perform_enqueued_jobs = true
      #       ActiveJob::Base.queue_adapter.perform_enqueued_at_jobs = true
      #     end
      #
      #     HeavyLiftingJob.perform_later
      #     expect(HeavyLiftingJob).to have_been_performed
      #
      #     HelloJob.perform_later
      #     HeavyLiftingJob.perform_later
      #     expect(HeavyLiftingJob).to have_been_performed.exactly(:once)
      #
      #     3.times { HelloJob.perform_later }
      #     expect(HelloJob).to have_been_performed.at_least(2).times
      #
      #     HelloJob.perform_later
      #     HeavyLiftingJob.perform_later
      #     expect(HelloJob).to have_been_performed
      #     expect(HeavyLiftingJob).to have_been_performed
      #
      #     HelloJob.set(wait_until: Date.tomorrow.noon, queue: "low").perform_later(42)
      #     expect(HelloJob).to have_been_performed.with(42).on_queue("low").at(Date.tomorrow.noon)
      def have_been_performed: () -> untyped

      private

      # @private
      def check_active_job_adapter: () -> (nil | untyped)
    end
  end
end

module RSpec
  module Rails
    # @private
    module FeatureCheck
      def self?.has_active_job?: () -> untyped

      def self?.has_active_record?: () -> untyped

      def self?.has_active_record_migration?: () -> untyped

      def self?.has_action_mailer?: () -> untyped

      def self?.has_action_mailer_preview?: () -> untyped

      def self?.has_action_cable_testing?: () -> untyped

      def self?.has_action_mailer_parameterized?: () -> untyped

      def self?.has_action_mailer_unified_delivery?: () -> untyped

      def self?.has_action_mailer_legacy_delivery_job?: () -> untyped

      def self?.has_action_mailbox?: () -> untyped

      def self?.type_metatag: (untyped `type`) -> ::String
    end
  end
end

module RSpec
  module Rails
    # Builds paths for view specs using a particular route set.
    class ViewPathBuilder
      def initialize: (untyped route_set) -> void

      # Given a hash of parameters, build a view path, if possible.
      # Returns nil if no path can be built from the given params.
      #
      # @example
      #     # path can be built because all required params are present in the hash
      #     view_path_builder = ViewPathBuilder.new(::Rails.application.routes)
      #     view_path_builder.path_for({ :controller => 'posts', :action => 'show', :id => '54' })
      #     # => "/post/54"
      #
      # @example
      #     # path cannot be built because the params are missing a required element (:id)
      #     view_path_builder.path_for({ :controller => 'posts', :action => 'delete' })
      #     # => ActionController::UrlGenerationError: No route matches {:action=>"delete", :controller=>"posts"}
      def path_for: (untyped path_params) -> untyped
    end
  end
end

# rubocop: disable Metrics/ModuleLength
module RSpec
  module Rails
    # Fake class to document RSpec Rails configuration options. In practice,
    # these are dynamically added to the normal RSpec configuration object.
    class Configuration
    end

    # Mappings used by `infer_spec_type_from_file_location!`.
    #
    # @api private
    DIRECTORY_MAPPINGS: { channel: ::Array["spec" | "channels"], controller: ::Array["spec" | "controllers"], generator: ::Array["spec" | "generator"], helper: ::Array["spec" | "helpers"], job: ::Array["spec" | "jobs"], mailer: ::Array["spec" | "mailers"], model: ::Array["spec" | "models"], request: ::Array["spec" | "(requests|integration|api)"], routing: ::Array["spec" | "routing"], view: ::Array["spec" | "views"], feature: ::Array["spec" | "features"], system: ::Array["spec" | "system"], mailbox: ::Array["spec" | "mailboxes"] }

    # Sets up the different example group modules for the different spec types
    #
    # @api private
    def self.add_test_type_configurations: (untyped config) -> untyped

    def self.initialize_configuration: (untyped config) -> untyped
  end
end

module RSpec
  module Rails
    # Adds methods (generally to ActionView::TestCase::TestController).
    # Intended for use in view specs.
    module ViewSpecMethods
      # Adds methods `extra_params=` and `extra_params` to the indicated class.
      # When class is `::ActionView::TestCase::TestController`, these methods
      # are exposed in view specs on the `controller` object.
      def self?.add_to: (untyped klass) -> (nil | untyped)

      # Removes methods `extra_params=` and `extra_params` from the indicated class.
      def self?.remove_from: (untyped klass) -> untyped
    end
  end
end

module RSpec
  module Rails
    # @private
    module FileFixtureSupport
      extend ActiveSupport::Concern

      include ActiveSupport::Testing::FileFixtures
    end
  end
end


