module GraphQL
  # Raised when a argument is configured with `loads:` and the client provides an `ID`,
  # but no object is loaded for that ID.
  #
  # @see GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader#load_application_object_failed, A hook which you can override in resolvers, mutations and input objects.
  class LoadApplicationObjectFailedError < GraphQL::ExecutionError
    # @return [GraphQL::Schema::Argument] the argument definition for the argument that was looked up
    attr_reader argument: untyped

    # @return [String] The ID provided by the client
    attr_reader id: untyped

    # @return [Object] The value found with this ID
    attr_reader object: untyped

    def initialize: (argument: untyped argument, id: untyped id, object: untyped object) -> void
  end
end

module GraphQL
  class ParseError < GraphQL::Error
    attr_reader line: untyped

    attr_reader col: untyped

    attr_reader query: untyped

    def initialize: (untyped message, untyped line, untyped col, untyped query, ?filename: untyped? filename) -> void

    def to_h: () -> ::Hash[::String, untyped]
  end
end

module GraphQL
  module Pagination
    # A Connection wraps a list of items and provides cursor-based pagination over it.
    #
    # Connections were introduced by Facebook's `Relay` front-end framework, but
    # proved to be generally useful for GraphQL APIs. When in doubt, use connections
    # to serve lists (like Arrays, ActiveRecord::Relations) via GraphQL.
    #
    # Unlike the previous connection implementation, these default to bidirectional pagination.
    #
    # Pagination arguments and context may be provided at initialization or assigned later (see {Schema::Field::ConnectionExtension}).
    class Connection
      class PaginationImplementationMissingError < GraphQL::Error
      end

      # @return [Object] A list object, from the application. This is the unpaginated value passed into the connection.
      attr_reader items: untyped

      # @return [GraphQL::Query::Context]
      attr_accessor context: untyped

      # @return [Object] the object this collection belongs to
      attr_accessor parent: untyped

      # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
      attr_accessor before_value: untyped

      # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
      attr_accessor after_value: untyped

      # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
      attr_accessor first_value: untyped

      # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
      attr_accessor last_value: untyped

      # @return [String, nil] the client-provided cursor. `""` is treated as `nil`.
      def before: () -> untyped

      # @return [String, nil] the client-provided cursor. `""` is treated as `nil`.
      def after: () -> untyped

      # @return [Hash<Symbol => Object>] The field arguments from the field that returned this connection
      attr_accessor arguments: untyped

      # @param items [Object] some unpaginated collection item, like an `Array` or `ActiveRecord::Relation`
      # @param context [Query::Context]
      # @param parent [Object] The object this collection belongs to
      # @param first [Integer, nil] The limit parameter from the client, if it provided one
      # @param after [String, nil] A cursor for pagination, if the client provided one
      # @param last [Integer, nil] Limit parameter from the client, if provided
      # @param before [String, nil] A cursor for pagination, if the client provided one.
      # @param arguments [Hash] The arguments to the field that returned the collection wrapped by this connection
      # @param max_page_size [Integer, nil] A configured value to cap the result size. Applied as `first` if neither first or last are given.
      def initialize: (untyped items, ?parent: untyped? parent, ?field: untyped? field, ?context: untyped? context, ?first: untyped? first, ?after: untyped? after, ?max_page_size: ::Symbol max_page_size, ?last: untyped? last, ?before: untyped? before, ?edge_class: untyped? edge_class, ?arguments: untyped? arguments) -> void

      def max_page_size=: (untyped new_value) -> untyped

      def max_page_size: () -> untyped

      def has_max_page_size_override?: () -> untyped

      attr_writer first: untyped

      # @return [Integer, nil]
      #   A clamped `first` value.
      #   (The underlying instance variable doesn't have limits on it.)
      #   If neither `first` nor `last` is given, but `max_page_size` is present, max_page_size is used for first.
      def first: () -> untyped

      # This is called by `Relay::RangeAdd` -- it can be overridden
      # when `item` needs some modifications based on this connection's state.
      #
      # @param item [Object] An item newly added to `items`
      # @return [Edge]
      def range_add_edge: (untyped item) -> untyped

      attr_writer last: untyped

      # @return [Integer, nil] A clamped `last` value. (The underlying instance variable doesn't have limits on it)
      def last: () -> untyped

      # @return [Array<Edge>] {nodes}, but wrapped with Edge instances
      def edges: () -> untyped

      # @return [Class] A wrapper class for edges of this connection
      attr_accessor edge_class: untyped

      # @return [GraphQL::Schema::Field] The field this connection was returned by
      attr_accessor field: untyped

      # @return [Array<Object>] A slice of {items}, constrained by {@first_value}/{@after_value}/{@last_value}/{@before_value}
      def nodes: () -> untyped

      # A dynamic alias for compatibility with {Relay::BaseConnection}.
      # @deprecated use {#nodes} instead
      def edge_nodes: () -> untyped

      # The connection object itself implements `PageInfo` fields
      def page_info: () -> untyped

      # @return [Boolean] True if there are more items after this page
      def has_next_page: () -> untyped

      # @return [Boolean] True if there were items before these items
      def has_previous_page: () -> untyped

      # @return [String] The cursor of the first item in {nodes}
      def start_cursor: () -> untyped

      # @return [String] The cursor of the last item in {nodes}
      def end_cursor: () -> untyped

      # Return a cursor for this item.
      # @param item [Object] one of the passed in {items}, taken from {nodes}
      # @return [String]
      def cursor_for: (untyped item) -> untyped

      private

      # @param argument [nil, Integer] `first` or `last`, as provided by the client
      # @param max_page_size [nil, Integer]
      # @return [nil, Integer] `nil` if the input was `nil`, otherwise a value between `0` and `max_page_size`
      def limit_pagination_argument: (untyped argument, untyped max_page_size) -> untyped

      def decode: (untyped cursor) -> untyped

      def encode: (untyped cursor) -> untyped

      # A wrapper around paginated items. It includes a {cursor} for pagination
      # and could be extended with custom relationship-level data.
      class Edge
        attr_reader node: untyped

        def initialize: (untyped node, untyped connection) -> void

        def parent: () -> untyped

        def cursor: () -> untyped
      end
    end
  end
end

module GraphQL
  module Pagination
    # Customizes `RelationConnection` to work with `ActiveRecord::Relation`s.
    class ActiveRecordRelationConnection < Pagination::RelationConnection
      private

      def relation_larger_than: (untyped relation, untyped initial_offset, untyped size) -> untyped

      def relation_count: (untyped relation) -> untyped

      def relation_limit: (untyped relation) -> untyped

      def relation_offset: (untyped relation) -> untyped

      def null_relation: (untyped relation) -> untyped

      def set_limit: (untyped nodes, untyped limit) -> untyped

      def set_offset: (untyped nodes, untyped offset) -> untyped

      def already_loaded?: (untyped relation) -> untyped
    end
  end
end

module GraphQL
  module Pagination
    # A generic class for working with database query objects.
    class RelationConnection < Pagination::Connection
      def nodes: () -> untyped

      def has_previous_page: () -> untyped

      def has_next_page: () -> untyped

      def cursor_for: (untyped item) -> untyped

      private

      # @param relation [Object] A database query object
      # @param _initial_offset [Integer] The number of items already excluded from the relation
      # @param size [Integer] The value against which we check the relation size
      # @return [Boolean] True if the number of items in this relation is larger than `size`
      def relation_larger_than: (untyped relation, untyped _initial_offset, untyped size) -> untyped

      # @param relation [Object] A database query object
      # @return [Integer, nil] The offset value, or nil if there isn't one
      def relation_offset: (untyped relation) -> untyped

      # @param relation [Object] A database query object
      # @return [Integer, nil] The limit value, or nil if there isn't one
      def relation_limit: (untyped relation) -> untyped

      # @param relation [Object] A database query object
      # @return [Integer, nil] The number of items in this relation (hopefully determined without loading all records into memory!)
      def relation_count: (untyped relation) -> untyped

      # @param relation [Object] A database query object
      # @return [Object] A modified query object which will return no records
      def null_relation: (untyped relation) -> untyped

      # @return [Integer]
      def offset_from_cursor: (untyped cursor) -> untyped

      # Abstract this operation so we can always ignore inputs less than zero.
      # (Sequel doesn't like it, understandably.)
      def set_offset: (untyped relation, untyped offset_value) -> untyped

      # Abstract this operation so we can always ignore inputs less than zero.
      # (Sequel doesn't like it, understandably.)
      def set_limit: (untyped relation, untyped limit_value) -> untyped

      def calculate_sliced_nodes_parameters: () -> untyped

      # Apply `before` and `after` to the underlying `items`,
      # returning a new relation.
      def sliced_nodes: () -> untyped

      # @return [Integer, nil]
      def before_offset: () -> untyped

      # @return [Integer, nil]
      def after_offset: () -> untyped

      # Apply `first` and `last` to `sliced_nodes`,
      # returning a new relation
      def limited_nodes: () -> untyped

      # Load nodes after applying first/last/before/after,
      # returns an array of nodes
      def load_nodes: () -> untyped
    end
  end
end

module GraphQL
  module Pagination
    # Customizes `RelationConnection` to work with `Sequel::Dataset`s.
    class SequelDatasetConnection < Pagination::RelationConnection
      private

      def relation_offset: (untyped relation) -> untyped

      def relation_limit: (untyped relation) -> untyped

      def relation_count: (untyped relation) -> untyped

      def null_relation: (untyped relation) -> untyped
    end
  end
end

module GraphQL
  module Pagination
    class ArrayConnection < Pagination::Connection
      def nodes: () -> untyped

      def has_previous_page: () -> untyped

      def has_next_page: () -> untyped

      def cursor_for: (untyped item) -> untyped

      private

      def index_from_cursor: (untyped cursor) -> untyped

      # Populate all the pagination info _once_,
      # It doesn't do anything on subsequent calls.
      def load_nodes: () -> untyped
    end
  end
end

module GraphQL
  module Pagination
    # A schema-level connection wrapper manager.
    #
    # Attach as a plugin.
    #
    # @example Adding a custom wrapper
    #   class MySchema < GraphQL::Schema
    #     connections.add(MyApp::SearchResults, MyApp::SearchResultsConnection)
    #   end
    #
    # @example Removing default connection support for arrays (they can still be manually wrapped)
    #   class MySchema < GraphQL::Schema
    #     connections.delete(Array)
    #   end
    #
    # @see {Schema.connections}
    class Connections
      class ImplementationMissingError < GraphQL::Error
      end

      def initialize: (schema: untyped schema) -> void

      def add: (untyped nodes_class, untyped implementation) -> untyped

      def delete: (untyped nodes_class) -> untyped

      def all_wrappers: () -> untyped

      def wrapper_for: (untyped items, ?wrappers: untyped wrappers) -> untyped

      # Used by the runtime to wrap values in connection wrappers.
      # @api Private
      def wrap: (untyped field, untyped parent, untyped items, untyped arguments, untyped context) -> untyped

      # use an override if there is one
      # @api private
      def edge_class_for_field: (untyped field) -> untyped

      attr_reader wrappers: untyped

      private

      def add_default: () -> untyped
    end
  end
end

module GraphQL
  module Pagination
    class MongoidRelationConnection < Pagination::RelationConnection
      def relation_offset: (untyped relation) -> untyped

      def relation_limit: (untyped relation) -> untyped

      def relation_count: (untyped relation) -> untyped

      def null_relation: (untyped relation) -> untyped
    end
  end
end

module GraphQL
  module Tracing
    class StatsdTracing < PlatformTracing
      # @param statsd [Object] A statsd client
      def initialize: (statsd: untyped statsd, **untyped rest) -> void

      def platform_trace: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String
    end
  end
end

module GraphQL
  module Tracing
    # This implementation forwards events to a notification handler (i.e.
    # ActiveSupport::Notifications or Dry::Monitor::Notifications)
    # with a `graphql` suffix.
    #
    # @see KEYS for event names
    class NotificationsTracing
      # A cache of frequently-used keys to avoid needless string allocations
      KEYS: ::Hash[::String, "lex.graphql" | "parse.graphql" | "validate.graphql" | "analyze_multiplex.graphql" | "analyze_query.graphql" | "execute_query.graphql" | "execute_query_lazy.graphql" | "execute_field.graphql" | "execute_field_lazy.graphql" | "authorized.graphql" | "authorized_lazy.graphql" | "resolve_type.graphql"]

      MAX_KEYS_SIZE: 100

      # Initialize a new NotificationsTracing instance
      #
      # @param [Object] notifications_engine The notifications engine to use
      def initialize: (untyped notifications_engine) -> void

      # Sends a GraphQL tracing event to the notification handler
      #
      # @example
      # . notifications_engine = Dry::Monitor::Notifications.new(:graphql)
      # . tracer = GraphQL::Tracing::NotificationsTracing.new(notifications_engine)
      # . tracer.trace("lex") { ... }
      #
      # @param [string] key The key for the event
      # @param [Hash] metadata The metadata for the event
      # @yield The block to execute for the event
      def trace: (untyped key, untyped metadata) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  module Tracing
    class AppsignalTracing < PlatformTracing
      # @param set_action_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
      #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
      #   It can also be specified per-query with `context[:set_appsignal_action_name]`.
      def initialize: (?::Hash[untyped, untyped] options) -> void

      def platform_trace: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String
    end
  end
end

module GraphQL
  module Tracing
    class PrometheusTracing < PlatformTracing
      # class GraphQLCollector < ::PrometheusExporter::Server::TypeCollector
      #   def initialize: () -> void

      #   def type: () -> "graphql"

      #   def collect: (untyped object) -> untyped

      #   def metrics: () -> ::Array[untyped]
      # end
    end
  end
end

module GraphQL
  module Tracing
    # This implementation forwards events to ActiveSupport::Notifications
    # with a `graphql` suffix.
    #
    # @see KEYS for event names
    module ActiveSupportNotificationsTracing
      # A cache of frequently-used keys to avoid needless string allocations
      KEYS: untyped

      NOTIFICATIONS_ENGINE: untyped

      def self.trace: (untyped key, untyped metadata) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  module Tracing
    # Each platform provides:
    # - `.platform_keys`
    # - `#platform_trace`
    # - `#platform_field_key(type, field)`
    # @api private
    class PlatformTracing
      attr_accessor self.platform_keys: untyped

      def initialize: (?::Hash[untyped, untyped] options) -> void

      def trace: (untyped key, untyped data) { () -> untyped } -> untyped

      def self.use: (untyped schema_defn, ?::Hash[untyped, untyped] options) -> untyped

      private

      # Get the transaction name based on the operation type and name if possible, or fall back to a user provided
      # one. Useful for anonymous queries.
      def transaction_name: (untyped query) -> ::String

      def fallback_transaction_name: (untyped context) -> untyped

      attr_reader options: untyped

      # Different kind of schema objects have different kinds of keys:
      #
      # - Object types: `.authorized`
      # - Union/Interface types: `.resolve_type`
      # - Fields: execution
      #
      # So, they can all share one cache.
      #
      # If the key isn't present, the given block is called and the result is cached for `key`.
      #
      # @return [String]
      def cached_platform_key: (untyped ctx, untyped key) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  module Tracing
    class ScoutTracing < PlatformTracing
      INSTRUMENT_OPTS: { scope: true }

      # @param set_transaction_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
      #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
      #   It can also be specified per-query with `context[:set_scout_transaction_name]`.
      def initialize: (?::Hash[untyped, untyped] options) -> void

      def platform_trace: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String
    end
  end
end

module GraphQL
  module Tracing
    class PrometheusTracing < PlatformTracing
      DEFAULT_WHITELIST: ::Array["execute_field" | "execute_field_lazy"]

      DEFAULT_COLLECTOR_TYPE: "graphql"

      def initialize: (?::Hash[untyped, untyped] opts) -> void

      def platform_trace: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String

      private

      def instrument_execution: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def observe: (untyped platform_key, untyped key, untyped duration) -> untyped
    end
  end
end

module GraphQL
  module Tracing
    class DataDogTracing < PlatformTracing
      def platform_trace: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def service_name: () -> untyped

      def tracer: () -> untyped

      def analytics_available?: () -> untyped

      def analytics_enabled?: () -> untyped

      def analytics_sample_rate: () -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String
    end
  end
end

module GraphQL
  module Tracing
    class NewRelicTracing < PlatformTracing
      # @param set_transaction_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
      #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
      #   It can also be specified per-query with `context[:set_new_relic_transaction_name]`.
      def initialize: (?::Hash[untyped, untyped] options) -> void

      def platform_trace: (untyped platform_key, untyped key, untyped data) { () -> untyped } -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String
    end
  end
end

module GraphQL
  module Tracing
    # This class uses the AppopticsAPM SDK from the appoptics_apm gem to create
    # traces for GraphQL.
    #
    # There are 4 configurations available. They can be set in the
    # appoptics_apm config file or in code. Please see:
    # {https://docs.appoptics.com/kb/apm_tracing/ruby/configure}
    #
    #     AppOpticsAPM::Config[:graphql][:enabled] = true|false
    #     AppOpticsAPM::Config[:graphql][:transaction_name]  = true|false
    #     AppOpticsAPM::Config[:graphql][:sanitize_query] = true|false
    #     AppOpticsAPM::Config[:graphql][:remove_comments] = true|false
    class AppOpticsTracing < GraphQL::Tracing::PlatformTracing
      # These GraphQL events will show up as 'graphql.prep' spans
      PREP_KEYS: ::Array["lex" | "parse" | "validate" | "analyze_query" | "analyze_multiplex"]

      # These GraphQL events will show up as 'graphql.execute' spans
      EXEC_KEYS: ::Array["execute_multiplex" | "execute_query" | "execute_query_lazy"]

      def self.version: () -> untyped

      def platform_trace: (untyped platform_key, untyped _key, untyped data) { () -> untyped } -> untyped

      def platform_field_key: (untyped `type`, untyped field) -> ::String

      def platform_authorized_key: (untyped `type`) -> ::String

      def platform_resolve_type_key: (untyped `type`) -> ::String

      private

      def gql_config: () -> untyped

      def transaction_name: (untyped query) -> (nil | untyped)

      def multiplex_transaction_name: (untyped names) -> (nil | untyped)

      def span_name: (untyped key) -> ("graphql.prep" | "graphql.execute" | untyped)

      # rubocop:disable Metrics/AbcSize, Metrics/MethodLength
      def metadata: (untyped data, untyped layer) -> untyped

      def graphql_context: (untyped context, untyped layer) -> ::Array[::Array[:Path | untyped]]

      def graphql_query: (untyped query) -> (::Array[untyped] | ::Array[::Array[:InboundQuery | untyped] | ::Array[:Operation | untyped]])

      def graphql_query_string: (untyped query_string) -> ::Array[:InboundQuery | untyped]

      def graphql_multiplex: (untyped data) -> ::Array[:Operations | untyped]

      def sanitize: (untyped query) -> (nil | untyped)

      def remove_comments: (untyped query) -> (nil | untyped)
    end
  end
end

module GraphQL
  # A GraphQL schema which may be queried with {GraphQL::Query}.
  #
  # The {Schema} contains:
  #
  #  - types for exposing your application
  #  - query analyzers for assessing incoming queries (including max depth & max complexity restrictions)
  #  - execution strategies for running incoming queries
  #
  # Schemas start with root types, {Schema#query}, {Schema#mutation} and {Schema#subscription}.
  # The schema will traverse the tree of fields & types, using those as starting points.
  # Any undiscoverable types may be provided with the `types` configuration.
  #
  # Schemas can restrict large incoming queries with `max_depth` and `max_complexity` configurations.
  # (These configurations can be overridden by specific calls to {Schema#execute})
  #
  # Schemas can specify how queries should be executed against them.
  # `query_execution_strategy`, `mutation_execution_strategy` and `subscription_execution_strategy`
  # each apply to corresponding root types.
  #  #
  # @example defining a schema
  #   class MySchema < GraphQL::Schema
  #     query QueryType
  #     # If types are only connected by way of interfaces, they must be added here
  #     orphan_types ImageType, AudioType
  #   end
  #
  class Schema
    extend GraphQL::Schema::Member::HasAstNode

    extend GraphQL::Schema::FindInheritedValue

    class DuplicateTypeNamesError < GraphQL::Error
      def initialize: (type_name: untyped type_name, first_definition: untyped first_definition, second_definition: untyped second_definition, path: untyped path) -> void
    end

    class DuplicateNamesError < GraphQL::Error
    end

    class UnresolvedLateBoundTypeError < GraphQL::Error
      attr_reader type: untyped

      def initialize: (type: untyped `type`) -> void
    end

    # Error that is raised when [#Schema#from_definition] is passed an invalid schema definition string.
    class InvalidDocumentError < Error
    end

    # Create schema with the result of an introspection query.
    # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
    # @return [Class<GraphQL::Schema>] the schema described by `input`
    def self.from_introspection: (untyped introspection_result) -> untyped

    # Create schema from an IDL schema or file containing an IDL definition.
    # @param definition_or_path [String] A schema definition string, or a path to a file containing the definition
    # @param default_resolve [<#call(type, field, obj, args, ctx)>] A callable for handling field resolution
    # @param parser [Object] An object for handling definition string parsing (must respond to `parse`)
    # @param using [Hash] Plugins to attach to the created schema with `use(key, value)`
    # @return [Class] the schema described by `document`
    def self.from_definition: (untyped definition_or_path, ?default_resolve: untyped? default_resolve, ?parser: untyped parser, ?using: ::Hash[untyped, untyped] using) -> untyped

    def self.deprecated_graphql_definition: () -> untyped

    # @return [GraphQL::Subscriptions]
    attr_accessor self.subscriptions: untyped

    # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
    # @see {#as_json}
    # @return [String]
    def self.to_json: (**untyped args) -> untyped

    # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [Hash] GraphQL result
    def self.as_json: (?only: untyped? only, ?except: untyped? except, ?context: ::Hash[untyped, untyped] context) -> untyped

    # Return the GraphQL IDL for the schema
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [String]
    def self.to_definition: (?only: untyped? only, ?except: untyped? except, ?context: ::Hash[untyped, untyped] context) -> untyped

    # Return the GraphQL::Language::Document IDL AST for the schema
    # @return [GraphQL::Language::Document]
    def self.to_document: () -> untyped

    # @return [String, nil]
    def self.description: (?untyped? new_description) -> untyped

    def self.find: (untyped path) -> untyped

    def self.default_filter: () -> untyped

    def self.default_mask: (?untyped? new_mask) -> untyped

    def self.static_validator: () -> untyped

    def self.use: (untyped plugin, **untyped kwargs) -> untyped

    def self.plugins: () -> untyped

    # Build a map of `{ name => type }` and return it
    # @return [Hash<String => Class>] A dictionary of type classes by their GraphQL name
    # @see get_type Which is more efficient for finding _one type_ by name, because it doesn't merge hashes.
    def self.types: (?untyped context) -> untyped

    # @param type_name [String]
    # @return [Module, nil] A type, or nil if there's no type called `type_name`
    def self.get_type: (untyped type_name, ?untyped context) -> untyped

    # @api private
    attr_writer self.connections: untyped

    # @return [GraphQL::Pagination::Connections] if installed
    def self.connections: () -> untyped

    def self.new_connections?: () -> untyped

    def self.query: (?untyped? new_query_object) -> untyped

    def self.mutation: (?untyped? new_mutation_object) -> untyped

    def self.subscription: (?untyped? new_subscription_object) -> untyped

    # @see [GraphQL::Schema::Warden] Restricted access to root types
    # @return [GraphQL::ObjectType, nil]
    def self.root_type_for_operation: (untyped operation) -> untyped

    def self.root_types: () -> untyped

    # @param type [Module] The type definition whose possible types you want to see
    # @return [Hash<String, Module>] All possible types, if no `type` is given.
    # @return [Array<Module>] Possible types for `type`, if it's given.
    def self.possible_types: (?untyped? `type`, ?untyped context) -> untyped

    def self.union_memberships: (?untyped? `type`) -> untyped

    # @api private
    # @see GraphQL::Dataloader
    def self.dataloader_class: () -> untyped

    attr_writer self.dataloader_class: untyped

    def self.references_to: (?untyped? to_type, ?from: untyped? from) -> untyped

    def self.type_from_ast: (untyped ast_node, ?context: untyped? context) -> untyped

    def self.get_field: (untyped type_or_name, untyped field_name, ?untyped context) -> untyped

    def self.get_fields: (untyped `type`, ?untyped context) -> untyped

    def self.introspection: (?untyped? new_introspection_namespace) -> untyped

    def self.introspection_system: () -> untyped

    def self.cursor_encoder: (?untyped? new_encoder) -> untyped

    def self.default_max_page_size: (?untyped? new_default_max_page_size) -> untyped

    def self.query_execution_strategy: (?untyped? new_query_execution_strategy) -> untyped

    def self.mutation_execution_strategy: (?untyped? new_mutation_execution_strategy) -> untyped

    def self.subscription_execution_strategy: (?untyped? new_subscription_execution_strategy) -> untyped

    attr_writer self.validate_timeout: untyped

    def self.validate_timeout: (?untyped? new_validate_timeout) -> untyped

    # Validate a query string according to this schema.
    # @param string_or_document [String, GraphQL::Language::Nodes::Document]
    # @return [Array<GraphQL::StaticValidation::Error >]
    def self.validate: (untyped string_or_document, ?rules: untyped? rules, ?context: untyped? context) -> untyped

    attr_writer self.validate_max_errors: untyped

    def self.validate_max_errors: (?untyped? new_validate_max_errors) -> untyped

    attr_writer self.max_complexity: untyped

    def self.max_complexity: (?untyped? max_complexity) -> untyped

    attr_writer self.analysis_engine: untyped

    def self.analysis_engine: () -> untyped

    def self.using_ast_analysis?: () -> true

    def self.interpreter?: () -> true

    attr_writer self.interpreter: untyped

    def self.error_bubbling: (?untyped? new_error_bubbling) -> untyped

    attr_writer self.error_bubbling: untyped

    attr_writer self.max_depth: untyped

    def self.max_depth: (?untyped? new_max_depth) -> untyped

    def self.disable_introspection_entry_points: () -> untyped

    def self.disable_schema_introspection_entry_point: () -> untyped

    def self.disable_type_introspection_entry_point: () -> untyped

    def self.disable_introspection_entry_points?: () -> untyped

    def self.disable_schema_introspection_entry_point?: () -> untyped

    def self.disable_type_introspection_entry_point?: () -> untyped

    def self.orphan_types: (*untyped new_orphan_types) -> untyped

    def self.default_execution_strategy: () -> untyped

    def self.default_analysis_engine: () -> untyped

    def self.context_class: (?untyped? new_context_class) -> untyped

    def self.rescue_from: (*untyped err_classes) { () -> untyped } -> untyped

    NEW_HANDLER_HASH: untyped

    def self.error_handlers: () -> untyped

    # @api private
    def self.handle_or_reraise: (untyped context, untyped err) -> untyped

    # rubocop:disable Lint/DuplicateMethods
    module ResolveTypeWithType
      def resolve_type: (untyped `type`, untyped obj, untyped ctx) -> untyped
    end

    def self.resolve_type: (untyped `type`, untyped obj, untyped ctx) -> untyped

    def self.inherited: (untyped child_class) -> untyped

    def self.object_from_id: (untyped node_id, untyped ctx) -> untyped

    def self.id_from_object: (untyped object, untyped `type`, untyped ctx) -> untyped

    def self.visible?: (untyped member, untyped ctx) -> untyped

    def self.accessible?: (untyped member, untyped ctx) -> untyped

    # This hook is called when a client tries to access one or more
    # fields that fail the `accessible?` check.
    #
    # By default, an error is added to the response. Override this hook to
    # track metrics or return a different error to the client.
    #
    # @param error [InaccessibleFieldsError] The analysis error for this check
    # @return [AnalysisError, nil] Return an error to skip the query
    def self.inaccessible_fields: (untyped error) -> untyped

    # This hook is called when an object fails an `authorized?` check.
    # You might report to your bug tracker here, so you can correct
    # the field resolvers not to return unauthorized objects.
    #
    # By default, this hook just replaces the unauthorized object with `nil`.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized object (accessible as `unauthorized_error.object`). If an
    # error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedError]
    # @return [Object] The returned object will be put in the GraphQL response
    def self.unauthorized_object: (untyped unauthorized_error) -> nil

    # This hook is called when a field fails an `authorized?` check.
    #
    # By default, this hook implements the same behavior as unauthorized_object.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized field . If an error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedFieldError]
    # @return [Field] The returned field will be put in the GraphQL response
    def self.unauthorized_field: (untyped unauthorized_error) -> untyped

    def self.type_error: (untyped type_error, untyped ctx) -> untyped

    # A function to call when {#execute} receives an invalid query string
    #
    # The default is to add the error to `context.errors`
    # @param err [GraphQL::ParseError] The error encountered during parsing
    # @param ctx [GraphQL::Query::Context] The context for the query where the error occurred
    # @return void
    def self.parse_error: (untyped parse_err, untyped ctx) -> untyped

    def self.lazy_resolve: (untyped lazy_class, untyped value_method) -> untyped

    def self.instrument: (untyped instrument_step, untyped instrumenter, ?::Hash[untyped, untyped] options) -> untyped

    # Add several directives at once
    # @param new_directives [Class]
    def self.directives: (*untyped new_directives) -> untyped

    # Attach a single directive to this schema
    # @param new_directive [Class]
    # @return void
    def self.directive: (untyped new_directive) -> untyped

    def self.default_directives: () -> untyped

    def self.tracer: (untyped new_tracer) -> untyped

    def self.tracers: () -> untyped

    def self.query_analyzer: (untyped new_analyzer) -> untyped

    def self.query_analyzers: () -> untyped

    def self.multiplex_analyzer: (untyped new_analyzer) -> untyped

    def self.multiplex_analyzers: () -> untyped

    def self.sanitized_printer: (?untyped? new_sanitized_printer) -> untyped

    # Execute a query on itself.
    # @see {Query#initialize} for arguments.
    # @return [Hash] query result, ready to be serialized as JSON
    def self.execute: (?untyped? query_str, **untyped kwargs) -> untyped

    # Execute several queries on itself, concurrently.
    #
    # @example Run several queries at once
    #   context = { ... }
    #   queries = [
    #     { query: params[:query_1], variables: params[:variables_1], context: context },
    #     { query: params[:query_2], variables: params[:variables_2], context: context },
    #   ]
    #   results = MySchema.multiplex(queries)
    #   render json: {
    #     result_1: results[0],
    #     result_2: results[1],
    #   }
    #
    # @see {Query#initialize} for query keyword arguments
    # @see {Execution::Multiplex#run_all} for multiplex keyword arguments
    # @param queries [Array<Hash>] Keyword arguments for each query
    # @param context [Hash] Multiplex-level context
    # @return [Array<Hash>] One result for each query in the input
    def self.multiplex: (untyped queries, **untyped kwargs) -> untyped

    def self.instrumenters: () -> untyped

    # @api private
    def self.add_subscription_extension_if_necessary: () -> untyped

    def self.query_stack_error: (untyped query, untyped err) -> untyped

    # Call the given block at the right time, either:
    # - Right away, if `value` is not registered with `lazy_resolve`
    # - After resolving `value`, if it's registered with `lazy_resolve` (eg, `Promise`)
    # @api private
    def self.after_lazy: (untyped value) { (untyped) -> untyped } -> untyped

    # Override this method to handle lazy objects in a custom way.
    # @param value [Object] an instance of a class registered with {.lazy_resolve}
    # @return [Object] A GraphQL-ready (non-lazy) object
    # @api private
    def self.sync_lazy: (untyped value) -> untyped

    # @return [Symbol, nil] The method name to lazily resolve `obj`, or nil if `obj`'s class wasn't registered with {#lazy_resolve}.
    def self.lazy_method_name: (untyped obj) -> untyped

    # @return [Boolean] True if this object should be lazily resolved
    def self.lazy?: (untyped obj) -> untyped

    # Return a lazy if any of `maybe_lazies` are lazy,
    # otherwise, call the block eagerly and return the result.
    # @param maybe_lazies [Array]
    # @api private
    def self.after_any_lazies: (untyped maybe_lazies) { (untyped) -> untyped } -> untyped

    private

    # @param t [Module, Array<Module>]
    # @return [void]
    def self.add_type_and_traverse: (untyped t, root: untyped root) -> untyped

    def self.lazy_methods: () -> untyped

    def self.own_types: () -> untyped

    def self.non_introspection_types: () -> untyped

    def self.own_plugins: () -> untyped

    def self.own_orphan_types: () -> untyped

    def self.own_possible_types: () -> untyped

    def self.own_union_memberships: () -> untyped

    def self.own_directives: () -> untyped

    def self.own_instrumenters: () -> untyped

    def self.own_tracers: () -> untyped

    def self.own_query_analyzers: () -> untyped

    def self.own_multiplex_analyzers: () -> untyped
  end
end

module GraphQL
  class RuntimeTypeError < GraphQL::Error
  end
end

module GraphQL
  # Wrap unhandled errors with {TracedError}.
  #
  # {TracedError} provides a GraphQL backtrace with arguments and return values.
  # The underlying error is available as {TracedError#cause}.
  #
  # @example toggling backtrace annotation
  #   class MySchema < GraphQL::Schema
  #     if Rails.env.development? || Rails.env.test?
  #       use GraphQL::Backtrace
  #     end
  #   end
  #
  class Backtrace
    # include Enumerable

    # extend Forwardable

    def self.use: (untyped schema_defn) -> untyped

    def initialize: (untyped context, ?value: untyped? value) -> void

    def inspect: () -> untyped

    alias to_s inspect

    def to_a: () -> untyped

    # Used for internal bookkeeping
    # @api private
    class Frame
      attr_reader path: untyped

      attr_reader query: untyped

      attr_reader ast_node: untyped

      attr_reader object: untyped

      attr_reader field: untyped

      attr_reader arguments: untyped

      attr_reader parent_frame: untyped

      def initialize: (path: untyped path, query: untyped query, ast_node: untyped ast_node, object: untyped object, field: untyped field, arguments: untyped arguments, parent_frame: untyped parent_frame) -> void
    end
  end
end

module GraphQL
  module Types
    # @see {Types::BigInt} for handling integers outside 32-bit range.
    class Int < GraphQL::Schema::Scalar
      MIN: untyped

      MAX: untyped

      def self.coerce_input: (untyped value, untyped ctx) -> (nil | untyped)

      def self.coerce_result: (untyped value, untyped ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    # An untyped JSON scalar that maps to Ruby hashes, arrays, strings, integers, floats, booleans and nils.
    # This should be used judiciously because it subverts the GraphQL type system.
    #
    # Use it for fields or arguments as follows:
    #
    #     field :template_parameters, GraphQL::Types::JSON, null: false
    #
    #     argument :template_parameters, GraphQL::Types::JSON, null: false
    #
    class JSON < GraphQL::Schema::Scalar
      def self.coerce_input: (untyped value, untyped _context) -> untyped

      def self.coerce_result: (untyped value, untyped _context) -> untyped
    end
  end
end

module GraphQL
  module Types
    class String < GraphQL::Schema::Scalar
      def self.coerce_result: (untyped value, untyped ctx) -> untyped

      def self.coerce_input: (untyped value, untyped _ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    # This scalar takes `Time`s and transmits them as strings,
    # using ISO 8601 format.
    #
    # Use it for fields or arguments as follows:
    #
    #     field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    #
    #     argument :deliver_at, GraphQL::Types::ISO8601DateTime, null: false
    #
    # Alternatively, use this built-in scalar as inspiration for your
    # own DateTime type.
    class ISO8601DateTime < GraphQL::Schema::Scalar
      # It's not compatible with Rails' default,
      # i.e. ActiveSupport::JSON::Encoder.time_precision (3 by default)
      DEFAULT_TIME_PRECISION: 0

      # @return [Integer]
      def self.time_precision: () -> untyped

      # @param [Integer] value
      def self.time_precision=: (untyped value) -> untyped

      # @param value [Time,Date,DateTime,String]
      # @return [String]
      def self.coerce_result: (untyped value, untyped _ctx) -> untyped

      # @param str_value [String]
      # @return [Time]
      def self.coerce_input: (untyped str_value, untyped _ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    # This module contains some types and fields that could support Relay conventions in GraphQL.
    #
    # You can use these classes out of the box if you want, but if you want to use your _own_
    # GraphQL extensions along with the features in this code, you could also
    # open up the source files and copy the relevant methods and configuration into
    # your own classes.
    #
    # For example, the provided object types extend {Types::Relay::BaseObject},
    # but you might want to:
    #
    # 1. Migrate the extensions from {Types::Relay::BaseObject} into _your app's_ base object
    # 2. Copy {Relay::BaseConnection}, {Relay::BaseEdge}, etc into _your app_, and
    #   change them to extend _your_ base object.
    #
    # Similarly, `BaseField`'s extensions could be migrated to your app
    # and `Node` could be implemented to mix in your base interface module.
    module Relay
    end
  end
end

module GraphQL
  module Types
    class Boolean < GraphQL::Schema::Scalar
      def self.coerce_input: (untyped value, untyped _ctx) -> untyped

      def self.coerce_result: (untyped value, untyped _ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    class BigInt < GraphQL::Schema::Scalar
      def self.coerce_input: (untyped value, untyped _ctx) -> untyped

      def self.coerce_result: (untyped value, untyped _ctx) -> untyped

      def self.parse_int: (untyped value) -> untyped
    end
  end
end

module GraphQL
  module Types
    class Float < GraphQL::Schema::Scalar
      def self.coerce_input: (untyped value, untyped _ctx) -> untyped

      def self.coerce_result: (untyped value, untyped _ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    # This scalar takes `Date`s and transmits them as strings,
    # using ISO 8601 format.
    #
    # Use it for fields or arguments as follows:
    #
    #     field :published_at, GraphQL::Types::ISO8601Date, null: false
    #
    #     argument :deliver_at, GraphQL::Types::ISO8601Date, null: false
    #
    # Alternatively, use this built-in scalar as inspiration for your
    # own Date type.
    class ISO8601Date < GraphQL::Schema::Scalar
      # @param value [Date,Time,DateTime,String]
      # @return [String]
      def self.coerce_result: (untyped value, untyped _ctx) -> untyped

      # @param str_value [String, Date, DateTime, Time]
      # @return [Date, nil]
      def self.coerce_input: (untyped value, untyped ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    class ID < GraphQL::Schema::Scalar
      def self.coerce_result: (untyped value, untyped _ctx) -> untyped

      def self.coerce_input: (untyped value, untyped _ctx) -> untyped
    end
  end
end

module GraphQL
  module Types
    module Relay
      # Include this module to your root Query type to get a Relay-style `nodes(id: ID!): [Node]` field that uses the schema's `object_from_id` hook.
      module HasNodesField
        def self.included: (untyped child_class) -> untyped

        def self.field_options: () -> { name: "nodes", type: ::Array[untyped | { null: true }], null: false, description: "Fetches a list of objects given a list of IDs.", relay_nodes_field: true }

        def self.field_block: () -> untyped
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      # This can be used for Relay's `Node` interface,
      # or you can take it as inspiration for your own implementation
      # of the `Node` interface.
      module Node
        include GraphQL::Schema::Interface

        include Types::Relay::NodeBehaviors
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      module EdgeBehaviors
        def self.included: (untyped child_class) -> untyped

        module ClassMethods
          # Get or set the Object type that this edge wraps.
          #
          # @param node_type [Class] A `Schema::Object` subclass
          # @param null [Boolean]
          # @param field_options [Hash] Any extra arguments to pass to the `field :node` configuration
          def node_type: (?untyped? node_type, ?null: untyped null, ?field_options: untyped? field_options) -> untyped

          def authorized?: (untyped obj, untyped ctx) -> true

          def accessible?: (untyped ctx) -> untyped

          def visible?: (untyped ctx) -> untyped

          # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
          # Use `node_nullable(false)` in your base class to make non-null `node` field.
          def node_nullable: (?untyped? new_value) -> untyped
        end
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      # Include this module to your root Query type to get a Relay-compliant `node(id: ID!): Node` field that uses the schema's `object_from_id` hook.
      module HasNodeField
        def self.included: (untyped child_class) -> untyped

        def self.field_options: () -> { name: "node", type: untyped, null: true, description: "Fetches an object given its ID.", relay_node_field: true }

        def self.field_block: () -> untyped
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      module ConnectionBehaviors
        # extend Forwardable

        def self.included: (untyped child_class) -> untyped

        module ClassMethods
          # @return [Class]
          attr_reader node_type: untyped

          # @return [Class]
          attr_reader edge_class: untyped

          # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
          #
          # This method will use the inputs to create:
          # - `edges` field
          # - `nodes` field
          # - description
          #
          # It's called when you subclass this base connection, trying to use the
          # class name to set defaults. You can call it again in the class definition
          # to override the default (or provide a value, if the default lookup failed).
          # @param field_options [Hash] Any extra keyword arguments to pass to the `field :edges, ...` and `field :nodes, ...` configurations
          def edge_type: (untyped edge_type_class, ?edge_class: untyped edge_class, ?node_type: untyped node_type, ?nodes_field: untyped nodes_field, ?node_nullable: untyped node_nullable, ?edges_nullable: untyped edges_nullable, ?edge_nullable: untyped edge_nullable, ?field_options: untyped? field_options) -> untyped

          # Filter this list according to the way its node type would scope them
          def scope_items: (untyped items, untyped context) -> untyped

          # Add the shortcut `nodes` field to this connection and its subclasses
          def nodes_field: (?node_nullable: untyped node_nullable, ?field_options: untyped? field_options) -> untyped

          def authorized?: (untyped obj, untyped ctx) -> true

          def accessible?: (untyped ctx) -> untyped

          def visible?: (untyped ctx) -> untyped

          # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
          # Use `node_nullable(false)` in your base class to make non-null `node` and `nodes` fields.
          def node_nullable: (?untyped? new_value) -> untyped

          # Set the default `edges_nullable` for this class and its child classes. (Defaults to `true`.)
          # Use `edges_nullable(false)` in your base class to make non-null `edges` fields.
          def edges_nullable: (?untyped? new_value) -> untyped

          # Set the default `edge_nullable` for this class and its child classes. (Defaults to `true`.)
          # Use `edge_nullable(false)` in your base class to make non-null `edge` fields.
          def edge_nullable: (?untyped? new_value) -> untyped

          # Set the default `nodes_field` for this class and its child classes. (Defaults to `true`.)
          # Use `nodes_field(false)` in your base class to prevent adding of a nodes field.
          def has_nodes_field: (?untyped? new_value) -> untyped

          private

          def define_nodes_field: (untyped nullable, ?field_options: untyped? field_options) -> untyped
        end

        def self.add_page_info_field: (untyped obj_type) -> untyped
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      module PageInfoBehaviors
        def self.included: (untyped child_class) -> untyped
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      module DefaultRelay
        def self.extended: (untyped child_class) -> untyped

        def default_relay: (untyped new_value) -> untyped

        def default_relay?: () -> untyped
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      # Use this to implement Relay connections, or take it as inspiration
      # for Relay classes in your own app.
      #
      # You may wish to copy this code into your own base class,
      # so you can extend your own `BaseObject` instead of `GraphQL::Schema::Object`.
      #
      # @example Implementation a connection and edge
      #   class BaseObject < GraphQL::Schema::Object; end
      #
      #   # Given some object in your app ...
      #   class Types::Post < BaseObject
      #   end
      #
      #   # Make a couple of base classes:
      #   class Types::BaseEdge < GraphQL::Types::Relay::BaseEdge; end
      #   class Types::BaseConnection < GraphQL::Types::Relay::BaseConnection; end
      #
      #   # Then extend them for the object in your app
      #   class Types::PostEdge < Types::BaseEdge
      #     node_type Types::Post
      #   end
      #
      #   class Types::PostConnection < Types::BaseConnection
      #     edge_type Types::PostEdge,
      #               edges_nullable: true,
      #               edge_nullable: true,
      #               node_nullable: true,
      #               nodes_field: true
      #
      #     # Alternatively, you can call the class methods followed by your edge type
      #     # edges_nullable true
      #     # edge_nullable true
      #     # nodes_nullable true
      #     # has_nodes_field true
      #     # edge_type Types::PostEdge
      #   end
      #
      # @see Relay::BaseEdge for edge types
      class BaseConnection < Schema::Object
        include ConnectionBehaviors
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      # A class-based definition for Relay edges.
      #
      # Use this as a parent class in your app, or use it as inspiration for your
      # own base `Edge` class.
      #
      # For example, you may want to extend your own `BaseObject` instead of the
      # built-in `GraphQL::Schema::Object`.
      #
      # @example Making a UserEdge type
      #   # Make a base class for your app
      #   class Types::BaseEdge < GraphQL::Types::Relay::BaseEdge
      #   end
      #
      #   # Then extend your own base class
      #   class Types::UserEdge < Types::BaseEdge
      #     node_type(Types::User)
      #   end
      #
      # @see {Relay::BaseConnection} for connection types
      class BaseEdge < GraphQL::Schema::Object
        include Types::Relay::EdgeBehaviors
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      module NodeBehaviors
        def self.included: (untyped child_module) -> untyped

        def default_global_id: () -> untyped
      end
    end
  end
end

module GraphQL
  module Types
    module Relay
      # The return type of a connection's `pageInfo` field
      class PageInfo < GraphQL::Schema::Object
        include PageInfoBehaviors
      end
    end
  end
end

module GraphQL
  # A rake task for dumping a schema as IDL or JSON.
  #
  # By default, schemas are looked up by name as constants using `schema_name:`.
  # You can provide a `load_schema` function to return your schema another way.
  #
  # `load_context:`, `only:` and `except:` are supported so that
  # you can keep an eye on how filters affect your schema.
  #
  # @example Dump a Schema to .graphql + .json files
  #   require "graphql/rake_task"
  #   GraphQL::RakeTask.new(schema_name: "MySchema")
  #
  #   # $ rake graphql:schema:dump
  #   # Schema IDL dumped to ./schema.graphql
  #   # Schema JSON dumped to ./schema.json
  #
  # @example Invoking the task from Ruby
  #   require "rake"
  #   Rake::Task["graphql:schema:dump"].invoke
  class RakeTask
    # include Rake::DSL

    DEFAULT_OPTIONS: { namespace: "graphql", dependencies: nil, schema_name: nil, load_schema: untyped, load_context: untyped, only: nil, except: nil, directory: ".", idl_outfile: "schema.graphql", json_outfile: "schema.json" }

    # @return [String] Namespace for generated tasks
    attr_writer namespace: untyped

    def rake_namespace: () -> untyped

    # @return [Array<String>]
    attr_accessor dependencies: untyped

    # @return [String] By default, used to find the schema as a constant.
    # @see {#load_schema} for loading a schema another way
    attr_accessor schema_name: untyped

    # @return [<#call(task)>] A proc for loading the target GraphQL schema
    attr_accessor load_schema: untyped

    # @return [<#call(task)>] A callable for loading the query context
    attr_accessor load_context: untyped

    # @return [<#call(member, ctx)>, nil] A filter for this task
    attr_accessor only: untyped

    # @return [<#call(member, ctx)>, nil] A filter for this task
    attr_accessor except: untyped

    # @return [String] target for IDL task
    attr_accessor idl_outfile: untyped

    # @return [String] target for JSON task
    attr_accessor json_outfile: untyped

    # @return [String] directory for IDL & JSON files
    attr_accessor directory: untyped

    # Set the parameters of this task by passing keyword arguments
    # or assigning attributes inside the block
    def initialize: (?::Hash[untyped, untyped] options) { (untyped) -> untyped } -> void

    private

    # Use the provided `method_name` to generate a string from the specified schema
    # then write it to `file`.
    def write_outfile: (untyped method_name, untyped file) -> untyped

    def idl_path: () -> untyped

    def json_path: () -> untyped

    def load_rails_environment_if_defined: () -> untyped

    # Use the Rake DSL to add tasks
    def define_task: () -> untyped
  end
end


module GraphQL
  # This plugin supports Fiber-based concurrency, along with {GraphQL::Dataloader::Source}.
  #
  # @example Installing Dataloader
  #
  #   class MySchema < GraphQL::Schema
  #     use GraphQL::Dataloader
  #   end
  #
  # @example Waiting for batch-loaded data in a GraphQL field
  #
  #   field :team, Types::Team, null: true
  #
  #   def team
  #     dataloader.with(Sources::Record, Team).load(object.team_id)
  #   end
  #
  class Dataloader
    attr_accessor self.default_nonblocking: untyped

    AsyncDataloader: untyped

    def self.use: (untyped schema, ?nonblocking: untyped? nonblocking) -> untyped

    # Call the block with a Dataloader instance,
    # then run all enqueued jobs and return the result of the block.
    def self.with_dataloading: () { () -> untyped } -> untyped

    def initialize: (?nonblocking: untyped nonblocking) -> void

    def nonblocking?: () -> untyped

    # Get a Source instance from this dataloader, for calling `.load(...)` or `.request(...)` on.
    #
    # @param source_class [Class<GraphQL::Dataloader::Source]
    # @param batch_parameters [Array<Object>]
    # @return [GraphQL::Dataloader::Source] An instance of {source_class}, initialized with `self, *batch_parameters`,
    #   and cached for the lifetime of this {Multiplex}.
    # truffle-ruby wasn't doing well with the implementation below
    # def with: (untyped source_class, *untyped batch_args) -> untyped

    def with: (untyped source_class, *untyped batch_args, **untyped batch_kwargs) -> untyped

    # Tell the dataloader that this fiber is waiting for data.
    #
    # Dataloader will resume the fiber after the requested data has been loaded (by another Fiber).
    #
    # @return [void]
    def yield: () -> nil

    # @api private Nothing to see here
    def append_job: () { () -> untyped } -> nil

    # Use a self-contained queue for the work in the block.
    def run_isolated: () { () -> untyped } -> untyped

    # @api private Move along, move along
    def run: () -> nil

    def join_queues: (untyped previous_queue, untyped next_queue) -> untyped

    private

    # If there are pending sources, return a fiber for running them.
    # Otherwise, return `nil`.
    #
    # @return [Fiber, nil]
    def create_source_fiber: () -> untyped

    def resume: (untyped fiber) -> untyped

    # Copies the thread local vars into the fiber thread local vars. Many
    # gems (such as RequestStore, MiniRacer, etc.) rely on thread local vars
    # to keep track of execution context, and without this they do not
    # behave as expected.
    #
    # @see https://github.com/rmosolgo/graphql-ruby/issues/3449
    def spawn_fiber: () { () -> untyped } -> untyped
  end
end

module GraphQL
  module Analysis
    module AST
      # Analyze a multiplex, and all queries within.
      # Multiplex analyzers are ran for all queries, keeping state.
      # Query analyzers are ran per query, without carrying state between queries.
      #
      # @param multiplex [GraphQL::Execution::Multiplex]
      # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
      # @return [Array<Any>] Results from multiplex analyzers
      def self?.analyze_multiplex: (untyped multiplex, untyped analyzers) -> untyped

      # @param query [GraphQL::Query]
      # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
      # @return [Array<Any>] Results from those analyzers
      def self?.analyze_query: (untyped query, untyped analyzers, ?multiplex_analyzers: untyped multiplex_analyzers) -> untyped

      def self?.analysis_errors: (untyped results) -> untyped
    end
  end
end

module GraphQL
  module Analysis
    # Calculate the complexity of a query, using {Field#complexity} values.
    module AST
      class QueryComplexity < Analyzer
        # State for the query complexity calculation:
        # - `complexities_on_type` holds complexity scores for each type
        def initialize: (untyped query) -> void

        # Overide this method to use the complexity result
        def result: () -> untyped

        class ScopedTypeComplexity
          # A single proc for {#scoped_children} hashes. Use this to avoid repeated allocations,
          # since the lexical binding isn't important.
          HASH_CHILDREN: untyped

          attr_reader field_definition: untyped

          attr_reader response_path: untyped

          attr_reader query: untyped

          # @param parent_type [Class] The owner of `field_definition`
          # @param field_definition [GraphQL::Field, GraphQL::Schema::Field] Used for getting the `.complexity` configuration
          # @param query [GraphQL::Query] Used for `query.possible_types`
          # @param response_path [Array<String>] The path to the response key for the field
          def initialize: (untyped parent_type, untyped field_definition, untyped query, untyped response_path) -> void

          # @return [Array<GraphQL::Language::Nodes::Field>]
          attr_reader nodes: untyped

          # Returns true if this field has no selections, ie, it's a scalar.
          # We need a quick way to check whether we should continue traversing.
          def terminal?: () -> untyped

          # This value is only calculated when asked for to avoid needless hash allocations.
          # Also, if it's never asked for, we determine that this scope complexity
          # is a scalar field ({#terminal?}).
          # @return [Hash<Hash<Class => ScopedTypeComplexity>]
          def scoped_children: () -> untyped

          def own_complexity: (untyped child_complexity) -> untyped
        end

        def on_enter_field: (untyped node, untyped parent, untyped visitor) -> (nil | untyped)

        def on_leave_field: (untyped node, untyped parent, untyped visitor) -> (nil | untyped)

        private

        # @return [Integer]
        def max_possible_complexity: () -> untyped

        # @param query [GraphQL::Query] Used for `query.possible_types`
        # @param scoped_children_hashes [Array<Hash>] Array of scoped children hashes
        # @return [Integer]
        def merged_max_complexity_for_scopes: (untyped query, untyped scoped_children_hashes) -> untyped

        def applies_to?: (untyped query, untyped left_scope, untyped right_scope) -> untyped

        # A hook which is called whenever a field's max complexity is calculated.
        # Override this method to capture individual field complexity details.
        #
        # @param scoped_type_complexity [ScopedTypeComplexity]
        # @param max_complexity [Numeric] Field's maximum complexity including child complexity
        # @param child_complexity [Numeric, nil] Field's child complexity
        def field_complexity: (untyped scoped_type_complexity, max_complexity: untyped max_complexity, ?child_complexity: untyped? child_complexity) -> nil

        # @param children_for_scope [Array<Hash>] An array of `scoped_children[scope]` hashes
        # (`{field_key => complexity}`)
        # @return [Integer] Complexity value for all these selections in the current scope
        def merged_max_complexity: (untyped query, untyped children_for_scope) -> untyped
      end
    end
  end
end

module GraphQL
  module Analysis
    # A query reducer for measuring the depth of a given query.
    #
    # See https://graphql-ruby.org/queries/ast_analysis.html for more examples.
    #
    # @example Logging the depth of a query
    #   class LogQueryDepth < GraphQL::Analysis::QueryDepth
    #     def result
    #       log("GraphQL query depth: #{@max_depth}")
    #     end
    #   end
    #
    #   # In your Schema file:
    #
    #   class MySchema < GraphQL::Schema
    #     query_analyzer LogQueryDepth
    #   end
    #
    #   # When you run the query, the depth will get logged:
    #
    #   Schema.execute(query_str)
    #   # GraphQL query depth: 8
    #
    module AST
      class QueryDepth < Analyzer
        def initialize: (untyped query) -> void

        def on_enter_field: (untyped node, untyped parent, untyped visitor) -> (nil | untyped)

        def on_leave_field: (untyped node, untyped parent, untyped visitor) -> (nil | untyped)

        def result: () -> untyped
      end
    end
  end
end

module GraphQL
  module Analysis
    module AST
      class FieldUsage < Analyzer
        def initialize: (untyped query) -> void

        def on_leave_field: (untyped node, untyped parent, untyped visitor) -> untyped

        def result: () -> { used_fields: untyped, used_deprecated_fields: untyped, used_deprecated_arguments: untyped }

        private

        def extract_deprecated_arguments: (untyped argument_values) -> untyped
      end
    end
  end
end

module GraphQL
  module Analysis
    module AST
      # Used under the hood to implement complexity validation,
      # see {Schema#max_complexity} and {Query#max_complexity}
      class MaxQueryComplexity < QueryComplexity
        def result: () -> (nil | untyped)
      end
    end
  end
end

module GraphQL
  module Analysis
    module AST
      # Depth first traversal through a query AST, calling AST analyzers
      # along the way.
      #
      # The visitor is a special case of GraphQL::Language::Visitor, visiting
      # only the selected operation, providing helpers for common use cases such
      # as skipped fields and visiting fragment spreads.
      #
      # @see {GraphQL::Analysis::AST::Analyzer} AST Analyzers for queries
      class Visitor < GraphQL::Language::Visitor
        def initialize: (query: untyped query, analyzers: untyped analyzers) -> void

        # @return [GraphQL::Query] the query being visited
        attr_reader query: untyped

        # @return [Array<GraphQL::ObjectType>] Types whose scope we've entered
        attr_reader object_types: untyped

        # @return [Array<GraphQL::AnalysisError]
        attr_reader rescued_errors: untyped

        def visit: () -> (nil | untyped)

        # @return [GraphQL::Execution::Interpreter::Arguments] Arguments for this node, merging default values, literal values and query variables
        # @see {GraphQL::Query#arguments_for}
        def arguments_for: (untyped ast_node, untyped field_definition) -> untyped

        # @return [Boolean] If the visitor is currently inside a fragment definition
        def visiting_fragment_definition?: () -> untyped

        # @return [Boolean] If the current node should be skipped because of a skip or include directive
        def skipping?: () -> untyped

        # @return [Array<String>] The path to the response key for the current field
        def response_path: () -> untyped

        def on_operation_definition: (untyped node, untyped parent) -> untyped

        def on_fragment_definition: (untyped node, untyped parent) -> untyped

        def on_inline_fragment: (untyped node, untyped parent) -> untyped

        def on_field: (untyped node, untyped parent) -> untyped

        def on_directive: (untyped node, untyped parent) -> untyped

        def on_argument: (untyped node, untyped parent) -> untyped

        def on_fragment_spread: (untyped node, untyped parent) -> untyped

        def on_abstract_node: (untyped node, untyped parent) -> untyped

        # @return [GraphQL::BaseType] The current object type
        def type_definition: () -> untyped

        # @return [GraphQL::BaseType] The type which the current type came from
        def parent_type_definition: () -> untyped

        # @return [GraphQL::Field, nil] The most-recently-entered GraphQL::Field, if currently inside one
        def field_definition: () -> untyped

        # @return [GraphQL::Field, nil] The GraphQL field which returned the object that the current field belongs to
        def previous_field_definition: () -> untyped

        # @return [GraphQL::Directive, nil] The most-recently-entered GraphQL::Directive, if currently inside one
        def directive_definition: () -> untyped

        # @return [GraphQL::Argument, nil] The most-recently-entered GraphQL::Argument, if currently inside one
        def argument_definition: () -> untyped

        # @return [GraphQL::Argument, nil] The previous GraphQL argument
        def previous_argument_definition: () -> untyped

        private

        # Visit a fragment spread inline instead of visiting the definition
        # by itself.
        def enter_fragment_spread_inline: (untyped fragment_spread) -> untyped

        # Visit a fragment spread inline instead of visiting the definition
        # by itself.
        def leave_fragment_spread_inline: (untyped _fragment_spread) -> untyped

        def skip?: (untyped ast_node) -> untyped

        def call_analyzers: (untyped method, untyped node, untyped parent) -> untyped

        def on_fragment_with_type: (untyped node) { (untyped) -> untyped } -> untyped
      end
    end
  end
end

module GraphQL
  module Analysis
    module AST
      class MaxQueryDepth < QueryDepth
        def result: () -> untyped
      end
    end
  end
end

module GraphQL
  module Analysis
    module AST
      # Query analyzer for query ASTs. Query analyzers respond to visitor style methods
      # but are prefixed by `enter` and `leave`.
      #
      # When an analyzer is initialized with a Multiplex, you can always get the current query from
      # `visitor.query` in the visit methods.
      #
      # @param [GraphQL::Query, GraphQL::Execution::Multiplex] The query or multiplex to analyze
      class Analyzer
        def initialize: (untyped subject) -> void

        # Analyzer hook to decide at analysis time whether a query should
        # be analyzed or not.
        # @return [Boolean] If the query should be analyzed or not
        def analyze?: () -> true

        # The result for this analyzer. Returning {GraphQL::AnalysisError} results
        # in a query error.
        # @return [Any] The analyzer result
        def result: () -> untyped

        private

        def self.build_visitor_hooks: (untyped member_name) -> untyped

        public

        # @return [GraphQL::Query, GraphQL::Execution::Multiplex] Whatever this analyzer is analyzing
        attr_reader subject: untyped

        # @return [GraphQL::Query, nil] `nil` if this analyzer is visiting a multiplex
        #  (When this is `nil`, use `visitor.query` inside visit methods to get the current query)
        attr_reader query: untyped

        # @return [GraphQL::Execution::Multiplex, nil] `nil` if this analyzer is visiting a query
        attr_reader multiplex: untyped
      end
    end
  end
end

module GraphQL
  class NameValidator
    VALID_NAME_REGEX: ::Regexp

    def self.validate!: (untyped name) -> untyped
  end
end

module GraphQL
  class RakeTask
    # extend Rake::DSL
  end
end

module GraphQL
  module Language
    # @api private
    def self.serialize: (untyped value) -> untyped
  end
end

module GraphQL
  module StaticValidation
    class InterpreterVisitor < BaseVisitor
      include GraphQL::StaticValidation::DefinitionDependencies

      # include ContextMethods
    end
  end
end

module GraphQL
  module StaticValidation
    # Default rules for {GraphQL::StaticValidation::Validator}
    #
    # Order is important here. Some validators return {GraphQL::Language::Visitor::SKIP}
    # which stops the visit on that node. That way it doesn't try to find fields on types that
    # don't exist, etc.
    ALL_RULES: ::Array[untyped]
  end
end

module GraphQL
  module StaticValidation
    # The validation context gets passed to each validator.
    #
    # It exposes a {GraphQL::Language::Visitor} where validators may add hooks. ({Language::Visitor#visit} is called in {Validator#validate})
    #
    # It provides access to the schema & fragments which validators may read from.
    #
    # It holds a list of errors which each validator may add to.
    #
    # It also provides limited access to the {TypeStack} instance,
    # which tracks state as you climb in and out of different fields.
    class ValidationContext
      # extend Forwardable

      attr_reader query: untyped

      attr_reader errors: untyped

      attr_reader visitor: untyped

      attr_reader on_dependency_resolve_handlers: untyped

      attr_reader max_errors: untyped

      def initialize: (untyped query, untyped visitor_class, untyped max_errors) -> void

      def on_dependency_resolve: () { () -> untyped } -> untyped

      def validate_literal: (untyped ast_value, untyped `type`) -> untyped

      def too_many_errors?: () -> untyped

      def schema_directives: () -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    # - Ride along with `GraphQL::Language::Visitor`
    # - Track type info, expose it to validators
    class TypeStack
      # These are jumping-off points for infering types down the tree
      TYPE_INFERRENCE_ROOTS: ::Array[untyped]

      # @return [GraphQL::Schema] the schema whose types are present in this document
      attr_reader schema: untyped

      # When it enters an object (starting with query or mutation root), it's pushed on this stack.
      # When it exits, it's popped off.
      # @return [Array<GraphQL::ObjectType, GraphQL::Union, GraphQL::Interface>]
      attr_reader object_types: untyped

      # When it enters a field, it's pushed on this stack (useful for nested fields, args).
      # When it exits, it's popped off.
      # @return [Array<GraphQL::Field>] fields which have been entered
      attr_reader field_definitions: untyped

      # Directives are pushed on, then popped off while traversing the tree
      # @return [Array<GraphQL::Node::Directive>] directives which have been entered
      attr_reader directive_definitions: untyped

      # @return [Array<GraphQL::Node::Argument>] arguments which have been entered
      attr_reader argument_definitions: untyped

      # @return [Array<String>] fields which have been entered (by their AST name)
      attr_reader path: untyped

      # @param schema [GraphQL::Schema] the schema whose types to use when climbing this document
      # @param visitor [GraphQL::Language::Visitor] a visitor to follow & watch the types
      def initialize: (untyped schema, untyped visitor) -> void

      private

      module FragmentWithTypeStrategy
        def push: (untyped stack, untyped node) -> untyped

        def pop: (untyped stack, untyped node) -> untyped
      end

      module FragmentDefinitionStrategy
        extend FragmentWithTypeStrategy

        def self?.push_path_member: (untyped stack, untyped node) -> untyped
      end

      module InlineFragmentStrategy
        extend FragmentWithTypeStrategy

        def self?.push_path_member: (untyped stack, untyped node) -> untyped
      end

      module OperationDefinitionStrategy
        def self?.push: (untyped stack, untyped node) -> untyped

        def self?.pop: (untyped stack, untyped node) -> untyped
      end

      module FieldStrategy
        def self?.push: (untyped stack, untyped node) -> untyped

        def self?.pop: (untyped stack, untyped node) -> untyped
      end

      module DirectiveStrategy
        def self?.push: (untyped stack, untyped node) -> untyped

        def self?.pop: (untyped stack, untyped node) -> untyped
      end

      module ArgumentStrategy
        # Push `argument_defn` onto the stack.
        # It's possible that `argument_defn` will be nil.
        # Push it anyways so `pop` has something to pop.
        def self?.push: (untyped stack, untyped node) -> untyped

        def self?.pop: (untyped stack, untyped node) -> untyped
      end

      module FragmentSpreadStrategy
        def self?.push: (untyped stack, untyped node) -> untyped

        def self?.pop: (untyped stack, untyped node) -> untyped
      end

      PUSH_STRATEGIES: ::Hash[untyped, untyped]

      class EnterWithStrategy
        def initialize: (untyped stack, untyped strategy) -> void

        def call: (untyped node, untyped parent) -> untyped
      end

      class LeaveWithStrategy
        def initialize: (untyped stack, untyped strategy) -> void

        def call: (untyped node, untyped parent) -> untyped
      end
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentsAreNamed
      def on_fragment_definition: (untyped node, untyped _parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FieldsAreDefinedOnTypeError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader field_name: untyped

      def initialize: (untyped message, type: untyped `type`, field: untyped field, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "undefinedField"
    end
  end
end

module GraphQL
  module StaticValidation
    class InputObjectNamesAreUniqueError < StaticValidation::Error
      attr_reader name: untyped

      def initialize: (untyped message, name: untyped name, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "inputFieldNotUnique"
    end
  end
end

module GraphQL
  module StaticValidation
    module VariablesAreInputTypes
      def on_variable_definition: (untyped node, untyped parent) -> untyped

      private

      def get_type_name: (untyped ast_type) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class OperationNamesAreValidError < StaticValidation::Error
      attr_reader operation_name: untyped

      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes, ?name: untyped? name) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "uniquelyNamedOperations"
    end
  end
end

module GraphQL
  module StaticValidation
    class ArgumentLiteralsAreCompatibleError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader argument_name: untyped

      attr_reader argument: untyped

      attr_reader value: untyped

      def initialize: (untyped message, type: untyped `type`, ?path: untyped? path, ?nodes: untyped nodes, ?argument_name: untyped? argument_name, ?extensions: untyped? extensions, ?coerce_extensions: untyped? coerce_extensions, ?argument: untyped? argument, ?value: untyped? value) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "argumentLiteralsIncompatible"
    end
  end
end

module GraphQL
  module StaticValidation
    class DirectivesAreDefinedError < StaticValidation::Error
      attr_reader directive_name: untyped

      def initialize: (untyped message, directive: untyped directive, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "undefinedDirective"
    end
  end
end

module GraphQL
  module StaticValidation
    module ArgumentsAreDefined
      def on_argument: (untyped node, untyped parent) -> untyped

      private

      # TODO smell: these methods are added to all visitors, since they're included in a module.
      def parent_name: (untyped parent, untyped type_defn) -> untyped

      def node_type: (untyped parent) -> untyped

      def parent_definition: (untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module FieldsWillMerge
      # Validates that a selection set is valid if all fields (including spreading any
      # fragments) either correspond to distinct response names or can be merged
      # without ambiguity.
      #
      # Original Algorithm: https://github.com/graphql/graphql-js/blob/master/src/validation/rules/OverlappingFieldsCanBeMerged.js
      NO_ARGS: ::Hash[untyped, untyped]

      Field: untyped

      FragmentSpread: untyped

      def initialize: () -> void

      def on_operation_definition: (untyped node, untyped _parent) -> untyped

      def on_field: (untyped node, untyped _parent) -> untyped

      private

      def field_conflicts: () -> untyped

      def arg_conflicts: () -> untyped

      def setting_errors: () { () -> untyped } -> untyped

      def conflicts_within_selection_set: (untyped node, untyped parent_type) -> (nil | untyped)

      def find_conflicts_between_fragments: (untyped fragment_spread1, untyped fragment_spread2, mutually_exclusive: untyped mutually_exclusive) -> (nil | untyped)

      def find_conflicts_between_fields_and_fragment: (untyped fragment_spread, untyped fields, mutually_exclusive: untyped mutually_exclusive) -> (nil | untyped)

      def find_conflicts_within: (untyped response_keys) -> untyped

      def find_conflict: (untyped response_key, untyped field1, untyped field2, ?mutually_exclusive: bool mutually_exclusive) -> (nil | untyped)

      def find_conflicts_between_sub_selection_sets: (untyped field1, untyped field2, mutually_exclusive: untyped mutually_exclusive) -> (nil | untyped)

      def find_conflicts_between: (untyped response_keys, untyped response_keys2, mutually_exclusive: untyped mutually_exclusive) -> untyped

      NO_SELECTIONS: ::Array[::Hash[untyped, untyped] | ::Array[untyped]]

      def fields_and_fragments_from_selection: (untyped node, owner_type: untyped owner_type, parents: untyped parents) -> untyped

      def find_fields_and_fragments: (untyped selections, owner_type: untyped owner_type, parents: untyped parents, fields: untyped fields, fragment_spreads: untyped fragment_spreads) -> ::Array[untyped]

      def same_arguments?: (untyped field1, untyped field2) -> (false | untyped)

      def serialize_arg: (untyped arg_value) -> untyped

      def serialize_field_args: (untyped field) -> untyped

      def compared_fragments_key: (untyped frag1, untyped frag2, untyped exclusive) -> ::String

      # Given two list of parents, find out if they are mutually exclusive
      # In this context, `parents` represends the "self scope" of the field,
      # what types may be found at this point in the query.
      def mutually_exclusive?: (untyped parents1, untyped parents2) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module VariableNamesAreUnique
      def on_operation_definition: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FieldsHaveAppropriateSelectionsError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader node_name: untyped

      def initialize: (untyped message, node_name: untyped node_name, ?path: untyped? path, ?nodes: untyped nodes, ?type: untyped? `type`) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "selectionMismatch"
    end
  end
end

module GraphQL
  module StaticValidation
    class RequiredArgumentsArePresentError < StaticValidation::Error
      attr_reader class_name: untyped

      attr_reader name: untyped

      attr_reader arguments: untyped

      def initialize: (untyped message, class_name: untyped class_name, name: untyped name, arguments: untyped arguments, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "missingRequiredArguments"
    end
  end
end

module GraphQL
  module StaticValidation
    module UniqueDirectivesPerLocation
      DIRECTIVE_NODE_HOOKS: ::Array[:on_fragment_definition | :on_fragment_spread | :on_inline_fragment | :on_operation_definition | :on_scalar_type_definition | :on_object_type_definition | :on_input_value_definition | :on_field_definition | :on_interface_type_definition | :on_union_type_definition | :on_enum_type_definition | :on_enum_value_definition | :on_input_object_type_definition | :on_field]

      private

      def validate_directive_location: (untyped node) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class QueryRootExistsError < StaticValidation::Error
      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "missingQueryConfiguration"
    end
  end
end

module GraphQL
  module StaticValidation
    module RequiredInputObjectAttributesArePresent
      def on_input_object: (untyped node, untyped parent) -> untyped

      private

      def get_parent_type: (untyped context, untyped parent) -> untyped

      def validate_input_object: (untyped ast_node, untyped context, untyped parent) -> (nil | untyped)
    end
  end
end

module GraphQL
  module StaticValidation
    class UniqueDirectivesPerLocationError < StaticValidation::Error
      attr_reader directive_name: untyped

      def initialize: (untyped message, directive: untyped directive, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "directiveNotUniqueForLocation"
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentsAreFinite
      def on_document: (untyped _n, untyped _p) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module MutationRootExists
      def on_operation_definition: (untyped node, untyped _parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class SubscriptionRootExistsError < StaticValidation::Error
      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "missingSubscriptionConfiguration"
    end
  end
end

module GraphQL
  module StaticValidation
    class DirectivesAreInValidLocationsError < StaticValidation::Error
      attr_reader target_name: untyped

      attr_reader name: untyped

      def initialize: (untyped message, target: untyped target, ?path: untyped? path, ?nodes: untyped nodes, ?name: untyped? name) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "directiveCannotBeApplied"
    end
  end
end

module GraphQL
  module StaticValidation
    module VariableUsagesAreAllowed
      def initialize: () -> void

      def on_operation_definition: (untyped node, untyped parent) -> untyped

      def on_argument: (untyped node, untyped parent) -> untyped

      private

      def validate_usage: (untyped argument_owner, untyped arg_node, untyped ast_var) -> (nil | untyped)

      def create_error: (untyped error_message, untyped var_type, untyped ast_var, untyped arg_defn, untyped arg_node) -> untyped

      def wrap_var_type_with_depth_of_arg: (untyped var_type, untyped arg_node) -> untyped

      # @return [Integer] Returns the max depth of `array`, or `0` if it isn't an array at all
      def depth_of_array: (untyped array) -> untyped

      def list_dimension: (untyped `type`) -> untyped

      def non_null_levels_match: (untyped arg_type, untyped var_type) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentsAreUsedError < StaticValidation::Error
      attr_reader fragment_name: untyped

      def initialize: (untyped message, fragment: untyped fragment, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "useAndDefineFragment"
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentTypesExist
      def on_fragment_definition: (untyped node, untyped _parent) -> untyped

      def on_inline_fragment: (untyped node, untyped _parent) -> untyped

      private

      def validate_type_exists: (untyped fragment_node) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentNamesAreUnique
      def initialize: () -> void

      def on_fragment_definition: (untyped node, untyped parent) -> untyped

      def on_document: (untyped _n, untyped _p) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentSpreadsArePossibleError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader fragment_name: untyped

      attr_reader parent_name: untyped

      def initialize: (untyped message, type: untyped `type`, fragment_name: untyped fragment_name, parent: untyped parent, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "cannotSpreadFragment"
    end
  end
end

module GraphQL
  module StaticValidation
    class ArgumentsAreDefinedError < StaticValidation::Error
      attr_reader name: untyped

      attr_reader type_name: untyped

      attr_reader argument_name: untyped

      attr_reader parent: untyped

      def initialize: (untyped message, name: untyped name, type: untyped `type`, argument_name: untyped argument_name, parent: untyped parent, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "argumentNotAccepted"
    end
  end
end

module GraphQL
  module StaticValidation
    class VariablesAreUsedAndDefinedError < StaticValidation::Error
      attr_reader variable_name: untyped

      attr_reader violation: untyped

      VIOLATIONS: { VARIABLE_NOT_USED: "variableNotUsed", VARIABLE_NOT_DEFINED: "variableNotDefined" }

      def initialize: (untyped message, name: untyped name, error_type: untyped error_type, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentTypesExistError < StaticValidation::Error
      attr_reader type_name: untyped

      def initialize: (untyped message, type: untyped `type`, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "undefinedType"
    end
  end
end

module GraphQL
  module StaticValidation
    class NoDefinitionsArePresentError < StaticValidation::Error
      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "queryContainsSchemaDefinitions"
    end
  end
end

module GraphQL
  module StaticValidation
    class RequiredInputObjectAttributesArePresentError < StaticValidation::Error
      attr_reader argument_type: untyped

      attr_reader argument_name: untyped

      attr_reader input_object_type: untyped

      def initialize: (untyped message, path: untyped path, nodes: untyped nodes, argument_type: untyped argument_type, argument_name: untyped argument_name, input_object_type: untyped input_object_type) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "missingRequiredInputObjectAttribute"
    end
  end
end

module GraphQL
  module StaticValidation
    class VariablesAreInputTypesError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader variable_name: untyped

      def initialize: (untyped message, type: untyped `type`, name: untyped name, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "variableRequiresValidType"
    end
  end
end

module GraphQL
  module StaticValidation
    module OperationNamesAreValid
      def initialize: () -> void

      def on_operation_definition: (untyped node, untyped parent) -> untyped

      def on_document: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module DirectivesAreInValidLocations
      include GraphQL::Language

      def on_directive: (untyped node, untyped parent) -> untyped

      private

      LOCATION_MESSAGE_NAMES: ::Hash[untyped, "queries" | "mutations" | "subscriptions" | "fields" | "fragment definitions" | "fragment spreads" | "inline fragments"]

      SIMPLE_LOCATIONS: ::Hash[untyped, untyped]

      SIMPLE_LOCATION_NODES: untyped

      def validate_location: (untyped ast_directive, untyped ast_parent, untyped directives) -> untyped

      def assert_includes_location: (untyped directive_defn, untyped directive_ast, untyped required_location) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentsAreOnCompositeTypes
      def on_fragment_definition: (untyped node, untyped parent) -> untyped

      def on_inline_fragment: (untyped node, untyped parent) -> untyped

      private

      def validate_type_is_composite: (untyped node) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module VariableDefaultValuesAreCorrectlyTyped
      def on_variable_definition: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    # The problem is
    #   - Variable $usage must be determined at the OperationDefinition level
    #   - You can't tell how fragments use variables until you visit FragmentDefinitions (which may be at the end of the document)
    #
    #  So, this validator includes some crazy logic to follow fragment spreads recursively, while avoiding infinite loops.
    #
    # `graphql-js` solves this problem by:
    #   - re-visiting the AST for each validator
    #   - allowing validators to say `followSpreads: true`
    #
    module VariablesAreUsedAndDefined
      class VariableUsage
        attr_accessor ast_node: untyped

        attr_accessor used_by: untyped

        attr_accessor declared_by: untyped

        attr_accessor path: untyped

        def used?: () -> untyped

        def declared?: () -> untyped
      end

      def initialize: () -> void

      def on_operation_definition: (untyped node, untyped parent) -> untyped

      def on_fragment_definition: (untyped node, untyped parent) -> untyped

      # For FragmentSpreads:
      #  - find the context on the stack
      #  - mark the context as containing this spread
      def on_fragment_spread: (untyped node, untyped parent) -> untyped

      # For VariableIdentifiers:
      #  - mark the variable as used
      #  - assign its AST node
      def on_variable_identifier: (untyped node, untyped parent) -> untyped

      def on_document: (untyped node, untyped parent) -> untyped

      private

      # Follow spreads in `node`, looking them up from `spreads_for_context` and finding their match in `fragment_definitions`.
      # Use those fragments to update {VariableUsage}s in `parent_variables`.
      # Avoid infinite loops by skipping anything in `visited_fragments`.
      def follow_spreads: (untyped node, untyped parent_variables, untyped spreads_for_context, untyped fragment_definitions, untyped visited_fragments) -> untyped

      # Determine all the error messages,
      # Then push messages into the validation context
      def create_errors: (untyped node_variables) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module DirectivesAreDefined
      def initialize: () -> void

      def on_directive: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module FieldsAreDefinedOnType
      def on_field: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentsAreUsed
      def on_document: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module NoDefinitionsArePresent
      include GraphQL::StaticValidation::Error::ErrorHelper

      def initialize: () -> void

      def on_invalid_node: (untyped node, untyped parent) -> nil

      alias on_directive_definition on_invalid_node

      alias on_schema_definition on_invalid_node

      alias on_scalar_type_definition on_invalid_node

      alias on_object_type_definition on_invalid_node

      alias on_input_object_type_definition on_invalid_node

      alias on_interface_type_definition on_invalid_node

      alias on_union_type_definition on_invalid_node

      alias on_enum_type_definition on_invalid_node

      alias on_schema_extension on_invalid_node

      alias on_scalar_type_extension on_invalid_node

      alias on_object_type_extension on_invalid_node

      alias on_input_object_type_extension on_invalid_node

      alias on_interface_type_extension on_invalid_node

      alias on_union_type_extension on_invalid_node

      alias on_enum_type_extension on_invalid_node

      def on_document: (untyped node, untyped parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class MutationRootExistsError < StaticValidation::Error
      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "missingMutationConfiguration"
    end
  end
end

module GraphQL
  module StaticValidation
    class ArgumentNamesAreUniqueError < StaticValidation::Error
      attr_reader name: untyped

      def initialize: (untyped message, name: untyped name, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "argumentNotUnique"
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentsAreOnCompositeTypesError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader argument_name: untyped

      def initialize: (untyped message, type: untyped `type`, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "fragmentOnNonCompositeType"
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentsAreFiniteError < StaticValidation::Error
      attr_reader fragment_name: untyped

      def initialize: (untyped message, name: untyped name, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "infiniteLoop"
    end
  end
end

module GraphQL
  module StaticValidation
    module InputObjectNamesAreUnique
      def on_input_object: (untyped node, untyped parent) -> untyped

      private

      def validate_input_fields: (untyped node) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentNamesAreUniqueError < StaticValidation::Error
      attr_reader fragment_name: untyped

      def initialize: (untyped message, name: untyped name, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "fragmentNotUnique"
    end
  end
end

module GraphQL
  module StaticValidation
    class VariableUsagesAreAllowedError < StaticValidation::Error
      attr_reader type_name: untyped

      attr_reader variable_name: untyped

      attr_reader argument_name: untyped

      attr_reader error_message: untyped

      def initialize: (untyped message, type: untyped `type`, name: untyped name, argument: untyped argument, error: untyped error, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "variableMismatch"
    end
  end
end

module GraphQL
  module StaticValidation
    module ArgumentLiteralsAreCompatible
      def on_argument: (untyped node, untyped parent) -> (nil | untyped)
    end
  end
end

module GraphQL
  module StaticValidation
    class VariableDefaultValuesAreCorrectlyTypedError < StaticValidation::Error
      attr_reader variable_name: untyped

      attr_reader type_name: untyped

      attr_reader violation: untyped

      VIOLATIONS: { INVALID_TYPE: "defaultValueInvalidType", INVALID_ON_NON_NULL: "defaultValueInvalidOnNonNullVariable" }

      def initialize: (untyped message, name: untyped name, error_type: untyped error_type, ?path: untyped? path, ?nodes: untyped nodes, ?type: untyped? `type`) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FragmentsAreNamedError < StaticValidation::Error
      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "anonymousFragment"
    end
  end
end

module GraphQL
  module StaticValidation
    # Scalars _can't_ have selections
    # Objects _must_ have selections
    module FieldsHaveAppropriateSelections
      include GraphQL::StaticValidation::Error::ErrorHelper

      def on_field: (untyped node, untyped parent) -> untyped

      def on_operation_definition: (untyped node, untyped _parent) -> untyped

      private

      def validate_field_selections: (untyped ast_node, untyped resolved_type) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module SubscriptionRootExists
      def on_operation_definition: (untyped node, untyped _parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module FragmentSpreadsArePossible
      def initialize: () -> void

      def on_inline_fragment: (untyped node, untyped parent) -> untyped

      def on_fragment_spread: (untyped node, untyped parent) -> untyped

      def on_document: (untyped node, untyped parent) -> untyped

      private

      def validate_fragment_in_scope: (untyped parent_type, untyped child_type, untyped node, untyped context, untyped path) -> (nil | untyped)

      class FragmentSpread
        attr_reader node: untyped

        attr_reader parent_type: untyped

        attr_reader path: untyped

        def initialize: (node: untyped node, parent_type: untyped parent_type, path: untyped path) -> void
      end
    end
  end
end

module GraphQL
  module StaticValidation
    module ArgumentNamesAreUnique
      include GraphQL::StaticValidation::Error::ErrorHelper

      def on_field: (untyped node, untyped parent) -> untyped

      def on_directive: (untyped node, untyped parent) -> untyped

      def validate_arguments: (untyped node) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class FieldsWillMergeError < StaticValidation::Error
      attr_reader field_name: untyped

      attr_reader kind: untyped

      def initialize: (kind: untyped kind, field_name: untyped field_name) -> void

      def message: () -> ::String

      def path: () -> ::Array[untyped]

      def conflicts: () -> untyped

      def add_conflict: (untyped node, untyped conflict_str) -> (nil | untyped)

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "fieldConflict"
    end
  end
end

module GraphQL
  module StaticValidation
    class VariableNamesAreUniqueError < StaticValidation::Error
      attr_reader variable_name: untyped

      def initialize: (untyped message, name: untyped name, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "variableNotUnique"
    end
  end
end

module GraphQL
  module StaticValidation
    module QueryRootExists
      def on_operation_definition: (untyped node, untyped _parent) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    module RequiredArgumentsArePresent
      def on_field: (untyped node, untyped _parent) -> untyped

      def on_directive: (untyped node, untyped _parent) -> untyped

      private

      def assert_required_args: (untyped ast_node, untyped defn) -> (nil | untyped)
    end
  end
end

module GraphQL
  module StaticValidation
    # Generates GraphQL-compliant validation message.
    class Error
      # Convenience for validators
      module ErrorHelper
        # Error `error_message` is located at `node`
        def error: (untyped error_message, untyped nodes, ?context: untyped? context, ?path: untyped? path, ?extensions: ::Hash[untyped, untyped] extensions) -> untyped
      end

      attr_reader message: untyped

      attr_accessor path: untyped

      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      private

      attr_reader nodes: untyped

      def locations: () -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class ValidationTimeoutError < StaticValidation::Error
      def initialize: (untyped message, ?path: untyped? path, ?nodes: untyped nodes) -> void

      # A hash representation of this Message
      def to_h: () -> untyped

      def code: () -> "validationTimeout"
    end
  end
end

module GraphQL
  module StaticValidation
    # Initialized with a {GraphQL::Schema}, then it can validate {GraphQL::Language::Nodes::Documents}s based on that schema.
    #
    # By default, it's used by {GraphQL::Query}
    #
    # @example Validate a query
    #   validator = GraphQL::StaticValidation::Validator.new(schema: MySchema)
    #   query = GraphQL::Query.new(MySchema, query_string)
    #   errors = validator.validate(query)[:errors]
    #
    class Validator
      # @param schema [GraphQL::Schema]
      # @param rules [Array<#validate(context)>] a list of rules to use when validating
      def initialize: (schema: untyped schema, ?rules: untyped rules) -> void

      # Validate `query` against the schema. Returns an array of message hashes.
      # @param query [GraphQL::Query]
      # @param validate [Boolean]
      # @param timeout [Float] Number of seconds to wait before aborting validation. Any positive number may be used, including Floats to specify fractional seconds.
      # @param max_errors [Integer] Maximum number of errors before aborting validation. Any positive number will limit the number of errors. Defaults to nil for no limit.
      # @return [Array<Hash>]
      def validate: (untyped query, ?validate: bool validate, ?timeout: untyped? timeout, ?max_errors: untyped? max_errors) -> untyped

      # Invoked when static validation times out.
      # @param query [GraphQL::Query]
      # @param context [GraphQL::StaticValidation::ValidationContext]
      def handle_timeout: (untyped query, untyped context) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    class BaseVisitor < GraphQL::Language::Visitor
      def initialize: (untyped document, untyped context) -> void

      attr_reader context: untyped

      # @return [Array<GraphQL::ObjectType>] Types whose scope we've entered
      attr_reader object_types: untyped

      # @return [Array<String>] The nesting of the current position in the AST
      def path: () -> untyped

      # Build a class to visit the AST and perform validation,
      # or use a pre-built class if rules is `ALL_RULES` or empty.
      # @param rules [Array<Module, Class>]
      # @return [Class] A class for validating `rules` during visitation
      def self.including_rules: (untyped rules) -> untyped

      module ContextMethods
        def on_operation_definition: (untyped node, untyped parent) -> untyped

        def on_fragment_definition: (untyped node, untyped parent) -> untyped

        def on_inline_fragment: (untyped node, untyped parent) -> untyped

        def on_field: (untyped node, untyped parent) -> untyped

        def on_directive: (untyped node, untyped parent) -> untyped

        def on_argument: (untyped node, untyped parent) -> untyped

        def on_fragment_spread: (untyped node, untyped parent) -> untyped

        def on_input_object: (untyped node, untyped parent) -> untyped

        # @return [GraphQL::BaseType] The current object type
        def type_definition: () -> untyped

        # @return [GraphQL::BaseType] The type which the current type came from
        def parent_type_definition: () -> untyped

        # @return [GraphQL::Field, nil] The most-recently-entered GraphQL::Field, if currently inside one
        def field_definition: () -> untyped

        # @return [GraphQL::Directive, nil] The most-recently-entered GraphQL::Directive, if currently inside one
        def directive_definition: () -> untyped

        # @return [GraphQL::Argument, nil] The most-recently-entered GraphQL::Argument, if currently inside one
        def argument_definition: () -> untyped

        private

        def on_fragment_with_type: (untyped node) { (untyped) -> untyped } -> untyped

        def push_type: (untyped t) -> untyped
      end

      private

      def add_error: (untyped error, ?path: untyped? path) -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    # Track fragment dependencies for operations
    # and expose the fragment definitions which
    # are used by a given operation
    module DefinitionDependencies
      attr_reader dependencies: untyped

      def initialize: () -> void

      def on_document: (untyped node, untyped parent) -> untyped

      def on_operation_definition: (untyped node, untyped prev_node) -> untyped

      def on_fragment_definition: (untyped node, untyped parent) -> untyped

      def on_fragment_spread: (untyped node, untyped parent) -> untyped

      # A map of operation definitions to an array of that operation's dependencies
      # @return [DependencyMap]
      def dependency_map: () { () -> untyped } -> untyped

      # Map definition AST nodes to the definition AST nodes they depend on.
      # Expose circular dependencies.
      class DependencyMap
        # @return [Array<GraphQL::Language::Nodes::FragmentDefinition>]
        attr_reader cyclical_definitions: untyped

        # @return [Hash<Node, Array<GraphQL::Language::Nodes::FragmentSpread>>]
        attr_reader unmet_dependencies: untyped

        # @return [Array<GraphQL::Language::Nodes::FragmentDefinition>]
        attr_reader unused_dependencies: untyped

        def initialize: () -> void

        # @return [Array<GraphQL::Language::Nodes::AbstractNode>] dependencies for `definition_node`
        def []: (untyped definition_node) -> untyped
      end

      class NodeWithPath
        # extend Forwardable

        attr_reader node: untyped

        attr_reader path: untyped

        def initialize: (untyped node, untyped path) -> void
      end

      private

      # Return a hash of { node => [node, node ... ]} pairs
      # Keys are top-level definitions
      # Values are arrays of flattened dependencies
      def resolve_dependencies: () { (untyped, untyped, untyped) -> untyped } -> untyped
    end
  end
end

module GraphQL
  module StaticValidation
    # Test whether `ast_value` is a valid input for `type`
    class LiteralValidator
      def initialize: (context: untyped context) -> void

      def validate: (untyped ast_value, untyped `type`) -> untyped

      private

      def recursively_validate: (untyped ast_value, untyped `type`) -> untyped

      # When `error_bubbling` is false, we want to bail on the first failure that we find.
      # Use `throw` to escape the current call stack, returning the invalid response.
      def maybe_raise_if_invalid: (untyped ast_value) { () -> untyped } -> untyped

      # The GraphQL grammar supports variables embedded within scalars but graphql.js
      # doesn't support it so we won't either for simplicity
      def constant_scalar?: (untyped ast_value) -> untyped

      def required_input_fields_are_present: (untyped `type`, untyped ast_node) -> untyped

      def present_input_field_values_are_valid: (untyped `type`, untyped ast_node) -> untyped

      def ensure_array: (untyped value) -> untyped

      def merge_results: (untyped results_list) -> untyped
    end
  end
end

module GraphQL
  class Backtrace
    # TODO this is not fiber-friendly
    module Tracer
      # Implement the {GraphQL::Tracing} API.
      def self?.trace: (untyped key, untyped metadata) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  class Backtrace
    # When {Backtrace} is enabled, raised errors are wrapped with {TracedError}.
    class TracedError < GraphQL::Error
      # @return [Array<String>] Printable backtrace of GraphQL error context
      attr_reader graphql_backtrace: untyped

      # @return [GraphQL::Query::Context] The context at the field where the error was raised
      attr_reader context: untyped

      MESSAGE_TEMPLATE: ::String

      # This many lines of the original Ruby backtrace
      # are included in the message
      CAUSE_BACKTRACE_PREVIEW_LENGTH: 10

      def initialize: (untyped err, untyped current_ctx) -> void
    end
  end
end

module GraphQL
  class Backtrace
    # A class for turning a context into a human-readable table or array
    class Table
      MIN_COL_WIDTH: 4

      MAX_COL_WIDTH: 100

      HEADERS: ::Array["Loc" | "Field" | "Object" | "Arguments" | "Result"]

      def initialize: (untyped context, value: untyped value) -> void

      # @return [String] A table layout of backtrace with metadata
      def to_table: () -> untyped

      # @return [Array<String>] An array of position + field name entries
      def to_backtrace: () -> untyped

      private

      def rows: () -> untyped

      # @return [String]
      def render_table: (untyped rows) -> untyped

      # @return [Array] 5 items for a backtrace table (not `key`)
      def build_rows: (untyped context_entry, rows: untyped rows, ?top: bool `top`) -> untyped

      def value_at: (untyped runtime, untyped path) -> untyped
    end
  end
end

module GraphQL
  class Backtrace
    module InspectResult
      def self?.inspect_result: (untyped obj) -> untyped

      def self?.inspect_truncated: (untyped obj) -> untyped
    end
  end
end

module GraphQL
  # This error is raised when `Types::Int` is given an input value outside of 32-bit integer range.
  #
  # For really big integer values, consider `GraphQL::Types::BigInt`
  #
  # @see GraphQL::Types::Int which raises this error
  class IntegerDecodingError < GraphQL::RuntimeTypeError
    # The value which couldn't be decoded
    attr_reader integer_value: untyped

    def initialize: (untyped value) -> void
  end
end

module GraphQL
  module Introspection
    def self.query: (?include_deprecated_args: bool include_deprecated_args, ?include_schema_description: bool include_schema_description, ?include_is_repeatable: bool include_is_repeatable, ?include_specified_by_url: bool include_specified_by_url) -> ::String
  end
end

module GraphQL
  # Error raised when the value provided for a field
  # can't be resolved to one of the possible types for the field.
  class UnresolvedTypeError < GraphQL::RuntimeTypeError
    # @return [Object] The runtime value which couldn't be successfully resolved with `resolve_type`
    attr_reader value: untyped

    # @return [GraphQL::Field] The field whose value couldn't be resolved (`field.type` is type which couldn't be resolved)
    attr_reader field: untyped

    # @return [GraphQL::BaseType] The owner of `field`
    attr_reader parent_type: untyped

    # @return [Object] The return of {Schema#resolve_type} for `value`
    attr_reader resolved_type: untyped

    # @return [Array<GraphQL::BaseType>] The allowed options for resolving `value` to `field.type`
    attr_reader possible_types: untyped

    def initialize: (untyped value, untyped field, untyped parent_type, untyped resolved_type, untyped possible_types) -> void
  end
end

module GraphQL
  # @api private
  class Filter
    def initialize: (?only: untyped? only, ?except: untyped? except) -> void

    # Returns true if `member, ctx` passes this filter
    def call: (untyped member, untyped ctx) -> untyped

    def merge: (?only: untyped? only, ?except: untyped? except) -> untyped

    private

    class MergedOnly
      def initialize: (untyped first, untyped second) -> void

      def call: (untyped member, untyped ctx) -> untyped

      def self.build: (untyped onlies) -> untyped
    end

    class MergedExcept < MergedOnly
      def call: (untyped member, untyped ctx) -> untyped
    end
  end
end

module GraphQL
  # Raised automatically when a field's resolve function returns `nil`
  # for a non-null field.
  class InvalidNullError < GraphQL::RuntimeTypeError
    # @return [GraphQL::BaseType] The owner of {#field}
    attr_reader parent_type: untyped

    # @return [GraphQL::Field] The field which failed to return a value
    attr_reader field: untyped

    # @return [nil, GraphQL::ExecutionError] The invalid value for this field
    attr_reader value: untyped

    def initialize: (untyped parent_type, untyped field, untyped value) -> void

    # @return [Hash] An entry for the response's "errors" key
    def to_h: () -> ::Hash[::String, untyped]

    # @deprecated always false
    def parent_error?: () -> false

    attr_accessor self.parent_class: untyped

    def self.subclass_for: (untyped parent_class) -> untyped

    def self.inspect: () -> untyped
  end
end

module GraphQL
  class CoercionError < GraphQL::Error
    # @return [Hash] Optional custom data for error objects which will be added
    # under the `extensions` key.
    attr_accessor extensions: untyped

    def initialize: (untyped message, ?extensions: untyped? extensions) -> void
  end
end

module GraphQL
  # Type kinds are the basic categories which a type may belong to (`Object`, `Scalar`, `Union`...)
  module TypeKinds
    # These objects are singletons, eg `GraphQL::TypeKinds::UNION`, `GraphQL::TypeKinds::SCALAR`.
    class TypeKind
      attr_reader name: untyped

      attr_reader description: untyped

      def initialize: (untyped name, ?abstract: bool abstract, ?fields: bool fields, ?wraps: bool wraps, ?input: bool input, ?description: untyped? description) -> void

      # Does this TypeKind have multiple possible implementors?
      # @deprecated Use `abstract?` instead of `resolves?`.
      def resolves?: () -> untyped

      # Is this TypeKind abstract?
      def abstract?: () -> untyped

      # Does this TypeKind have queryable fields?
      def fields?: () -> untyped

      # Does this TypeKind modify another type?
      def wraps?: () -> untyped

      # Is this TypeKind a valid query input?
      def input?: () -> untyped

      def to_s: () -> untyped

      # Is this TypeKind composed of many values?
      def composite?: () -> untyped

      def scalar?: () -> untyped

      def object?: () -> untyped

      def interface?: () -> untyped

      def union?: () -> untyped

      def enum?: () -> untyped

      def input_object?: () -> untyped

      def list?: () -> untyped

      def non_null?: () -> untyped
    end

    TYPE_KINDS: ::Array[untyped]
  end
end

module GraphQL
  # This error is raised when `Types::Int` is asked to return a value outside of 32-bit integer range.
  #
  # For values outside that range, consider:
  #
  # - `ID` for database primary keys or other identifiers
  # - `GraphQL::Types::BigInt` for really big integer values
  #
  # @see GraphQL::Types::Int which raises this error
  class IntegerEncodingError < GraphQL::RuntimeTypeError
    # The value which couldn't be encoded
    attr_reader integer_value: untyped

    # @return [GraphQL::Schema::Field] The field that returned a too-big integer
    attr_reader field: untyped

    # @return [Array<String, Integer>] Where the field appeared in the GraphQL response
    attr_reader path: untyped

    def initialize: (untyped value, context: untyped context) -> void
  end
end

module GraphQL
  module Language
    class Printer
      # Turn an arbitrary AST node back into a string.
      #
      # @example Turning a document into a query string
      #    document = GraphQL.parse(query_string)
      #    GraphQL::Language::Printer.new.print(document)
      #    # => "{ ... }"
      #
      #
      # @example Building a custom printer
      #
      #  class MyPrinter < GraphQL::Language::Printer
      #    def print_argument(arg)
      #      "#{arg.name}: <HIDDEN>"
      #    end
      #  end
      #
      #  MyPrinter.new.print(document)
      #  # => "mutation { pay(creditCard: <HIDDEN>) { success } }"
      #
      #
      # @param indent [String] Whitespace to add to the printed node
      # @return [String] Valid GraphQL for `node`
      def print: (untyped node, ?indent: ::String indent) -> untyped

      def print_document: (untyped document) -> untyped

      def print_argument: (untyped argument) -> ::String

      def print_directive: (untyped directive) -> untyped

      def print_enum: (untyped enum) -> ::String

      def print_null_value: () -> "null"

      def print_field: (untyped field, ?indent: ::String indent) -> untyped

      def print_fragment_definition: (untyped fragment_def, ?indent: ::String indent) -> untyped

      def print_fragment_spread: (untyped fragment_spread, ?indent: ::String indent) -> untyped

      def print_inline_fragment: (untyped inline_fragment, ?indent: ::String indent) -> untyped

      def print_input_object: (untyped input_object) -> ::String

      def print_list_type: (untyped list_type) -> ::String

      def print_non_null_type: (untyped non_null_type) -> ::String

      def print_operation_definition: (untyped operation_definition, ?indent: ::String indent) -> untyped

      def print_type_name: (untyped type_name) -> ::String

      def print_variable_definition: (untyped variable_definition) -> untyped

      def print_variable_identifier: (untyped variable_identifier) -> ::String

      def print_schema_definition: (untyped schema) -> (nil | untyped)

      def print_scalar_type_definition: (untyped scalar_type) -> untyped

      def print_object_type_definition: (untyped object_type) -> untyped

      def print_implements: (untyped `type`) -> ::String

      def print_input_value_definition: (untyped input_value) -> untyped

      def print_arguments: (untyped arguments, ?indent: ::String indent) -> (::String | untyped)

      def print_field_definition: (untyped field) -> untyped

      def print_interface_type_definition: (untyped interface_type) -> untyped

      def print_union_type_definition: (untyped union_type) -> untyped

      def print_enum_type_definition: (untyped enum_type) -> untyped

      def print_enum_value_definition: (untyped enum_value) -> untyped

      def print_input_object_type_definition: (untyped input_object_type) -> untyped

      def print_directive_definition: (untyped directive) -> untyped

      def print_description: (untyped node, ?indent: ::String indent, ?first_in_block: bool first_in_block) -> (::String | untyped)

      def print_field_definitions: (untyped fields) -> untyped

      def print_directives: (untyped directives) -> untyped

      def print_selections: (untyped selections, ?indent: ::String indent) -> untyped

      def print_node: (untyped node, ?indent: ::String indent) -> untyped

      private

      attr_reader node: untyped
    end
  end
end

module GraphQL
  module Language
    module BlockString
      # Remove leading and trailing whitespace from a block string.
      # See "Block Strings" in https://github.com/facebook/graphql/blob/master/spec/Section%202%20--%20Language.md
      def self.trim_whitespace: (untyped str) -> (::String | untyped)

      def self.print: (untyped str, ?indent: ::String indent) -> untyped

      private

      def self.break_line: (untyped line, untyped length) -> (::Array[untyped] | untyped)
    end
  end
end

module GraphQL
  module Language
    module DefinitionSlice
      extend ::GraphQL::Language::DefinitionSlice

      def slice: (untyped document, untyped name) -> untyped

      private

      class DependencyVisitor < GraphQL::Language::Visitor
        def initialize: (untyped doc, untyped definitions, untyped names) -> void

        def on_fragment_spread: (untyped node, untyped parent) -> untyped

        def self.find_definition_dependencies: (untyped definitions, untyped name, untyped names) -> nil
      end
    end
  end
end

module GraphQL
  module Language
    module Nodes
      # {AbstractNode} is the base class for all nodes in a GraphQL AST.
      #
      # It provides some APIs for working with ASTs:
      # - `children` returns all AST nodes attached to this one. Used for tree traversal.
      # - `scalars` returns all scalar (Ruby) values attached to this one. Used for comparing nodes.
      # - `to_query_string` turns an AST node into a GraphQL string
      class AbstractNode
        module DefinitionNode
          # This AST node's {#line} returns the first line, which may be the description.
          # @return [Integer] The first line of the definition (not the description)
          attr_reader definition_line: untyped

          def initialize: (?::Hash[untyped, untyped] options) -> void
        end

        attr_reader line: untyped

        attr_reader col: untyped

        attr_reader filename: untyped

        # Initialize a node by extracting its position,
        # then calling the class's `initialize_node` method.
        # @param options [Hash] Initial attributes for this node
        def initialize: (?::Hash[untyped, untyped] options) -> void

        # Value equality
        # @return [Boolean] True if `self` is equivalent to `other`
        def ==: (untyped other) -> (true | untyped)

        NO_CHILDREN: ::Array[untyped]

        # @return [Array<GraphQL::Language::Nodes::AbstractNode>] all nodes in the tree below this one
        def children: () -> untyped

        # @return [Array<Integer, Float, String, Boolean, Array>] Scalar values attached to this node
        def scalars: () -> untyped

        # This might be unnecessary, but its easiest to add it here.
        def initialize_copy: (untyped other) -> untyped

        def children_method_name: () -> untyped

        def position: () -> ::Array[untyped]

        def to_query_string: (?printer: untyped printer) -> untyped

        # This creates a copy of `self`, with `new_options` applied.
        # @param new_options [Hash]
        # @return [AbstractNode] a shallow copy of `self`
        def merge: (untyped new_options) -> untyped

        # Copy `self`, but modify the copy so that `previous_child` is replaced by `new_child`
        def replace_child: (untyped previous_child, untyped new_child) -> untyped

        # TODO DRY with `replace_child`
        def delete_child: (untyped previous_child) -> untyped

        def merge!: (untyped new_options) -> untyped

        # Add a default `#visit_method` and `#children_method_name` using the class name
        def self.inherited: (untyped child_class) -> untyped

        private

        # Name accessors which return lists of nodes,
        # along with the kind of node they return, if possible.
        # - Add a reader for these children
        # - Add a persistent update method to add a child
        # - Generate a `#children` method
        def self.children_methods: (untyped children_of_type) -> untyped

        # These methods return a plain Ruby value, not another node
        # - Add reader methods
        # - Add a `#scalars` method
        def self.scalar_methods: (*untyped method_names) -> untyped

        def self.generate_initialize_node: () -> untyped
      end

      # Base class for non-null type names and list type names
      class WrapperType < AbstractNode
      end

      # Base class for nodes whose only value is a name (no child nodes or other scalars)
      class NameOnlyNode < AbstractNode
      end

      # A key-value pair for a field's inputs
      class Argument < AbstractNode
        def children: () -> untyped
      end

      class Directive < AbstractNode
      end

      class DirectiveLocation < NameOnlyNode
      end

      class DirectiveDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      # This is the AST root for normal queries
      #
      # @example Deriving a document by parsing a string
      #   document = GraphQL.parse(query_string)
      #
      # @example Creating a string from a document
      #   document.to_query_string
      #   # { ... }
      #
      # @example Creating a custom string from a document
      #  class VariableScrubber < GraphQL::Language::Printer
      #    def print_argument(arg)
      #      "#{arg.name}: <HIDDEN>"
      #    end
      #  end
      #
      #  document.to_query_string(printer: VariableScrubber.new)
      #
      class Document < AbstractNode
        def slice_definition: (untyped name) -> untyped
      end

      # An enum value. The string is available as {#name}.
      class Enum < NameOnlyNode
      end

      # A null value literal.
      class NullValue < NameOnlyNode
      end

      # A single selection in a GraphQL query.
      class Field < AbstractNode
        NONE: ::Array[untyped]

        def initialize_node: (untyped attributes) -> untyped
      end

      # A reusable fragment, defined at document-level.
      class FragmentDefinition < AbstractNode
        # @!attribute type
        #   @return [String] the type condition for this fragment (name of type which it may apply to)
        def initialize_node: (?name: untyped? name, ?type: untyped? `type`, ?directives: untyped directives, ?selections: untyped selections) -> untyped
      end

      # Application of a named fragment in a selection
      class FragmentSpread < AbstractNode
      end

      # An unnamed fragment, defined directly in the query with `... {  }`
      class InlineFragment < AbstractNode
      end

      # A collection of key-value inputs which may be a field argument
      class InputObject < AbstractNode
        # @return [Hash<String, Any>] Recursively turn this input object into a Ruby Hash
        def to_h: (?::Hash[untyped, untyped] options) -> untyped

        private

        def serialize_value_for_hash: (untyped value) -> untyped
      end

      # A list type definition, denoted with `[...]` (used for variable type definitions)
      class ListType < WrapperType
      end

      # A non-null type definition, denoted with `...!` (used for variable type definitions)
      class NonNullType < WrapperType
      end

      # An operation-level query variable
      class VariableDefinition < AbstractNode
      end

      # A query, mutation or subscription.
      # May be anonymous or named.
      # May be explicitly typed (eg `mutation { ... }`) or implicitly a query (eg `{ ... }`).
      class OperationDefinition < AbstractNode
      end

      # A type name, used for variable definitions
      class TypeName < NameOnlyNode
      end

      # Usage of a variable in a query. Name does _not_ include `$`.
      class VariableIdentifier < NameOnlyNode
      end

      class SchemaDefinition < AbstractNode
        # include DefinitionNode
      end

      class SchemaExtension < AbstractNode
      end

      class ScalarTypeDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class ScalarTypeExtension < AbstractNode
      end

      class InputValueDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class FieldDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped

        # this is so that `children_method_name` of `InputValueDefinition` works properly
        # with `#replace_child`
        # alias fields arguments

        def merge: (untyped new_options) -> untyped
      end

      class ObjectTypeDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class ObjectTypeExtension < AbstractNode
      end

      class InterfaceTypeDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class InterfaceTypeExtension < AbstractNode
      end

      class UnionTypeDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped

        attr_reader types: untyped
      end

      class UnionTypeExtension < AbstractNode
        attr_reader types: untyped
      end

      class EnumValueDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class EnumTypeDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class EnumTypeExtension < AbstractNode
      end

      class InputObjectTypeDefinition < AbstractNode
        # include DefinitionNode

        attr_reader description: untyped
      end

      class InputObjectTypeExtension < AbstractNode
      end
    end
  end
end

module GraphQL
  module Language
    module Lexer
      def self.tokenize: (untyped query_string) -> untyped

      # Replace any escaped unicode or whitespace with the _actual_ characters
      # To avoid allocating more strings, this modifies the string passed into it
      def self.replace_escaped_characters_in_place: (untyped raw_string) -> nil

      private

      attr_accessor self._graphql_lexer_trans_keys: untyped

      attr_accessor self._graphql_lexer_char_class: untyped

      attr_accessor self._graphql_lexer_index_offsets: untyped

      attr_accessor self._graphql_lexer_indicies: untyped

      attr_accessor self._graphql_lexer_index_defaults: untyped

      attr_accessor self._graphql_lexer_trans_cond_spaces: untyped

      attr_accessor self._graphql_lexer_cond_targs: untyped

      attr_accessor self._graphql_lexer_cond_actions: untyped

      attr_accessor self._graphql_lexer_to_state_actions: untyped

      attr_accessor self._graphql_lexer_from_state_actions: untyped

      attr_accessor self._graphql_lexer_eof_trans: untyped

      attr_accessor self._graphql_lexer_nfa_targs: untyped

      attr_accessor self._graphql_lexer_nfa_offsets: untyped

      attr_accessor self._graphql_lexer_nfa_push_actions: untyped

      attr_accessor self._graphql_lexer_nfa_pop_trans: untyped

      attr_accessor self.graphql_lexer_start: untyped

      attr_accessor self.graphql_lexer_first_final: untyped

      attr_accessor self.graphql_lexer_error: untyped

      attr_accessor self.graphql_lexer_en_str: untyped

      attr_accessor self.graphql_lexer_en_main: untyped

      def self.run_lexer: (untyped query_string) -> untyped

      def self.record_comment: (untyped ts, untyped te, untyped meta) -> untyped

      def self.emit: (untyped token_name, untyped ts, untyped te, untyped meta, ?untyped? token_value) -> untyped

      ESCAPES: ::Regexp

      # ESCAPES_REPLACE: ::Hash[::String, "\"" | "\\" | "/" | ::String]

      UTF_8: ::Regexp

      UTF_8_REPLACE: untyped

      VALID_STRING: untyped

      PACK_DIRECTIVE: "c*"

      UTF_8_ENCODING: "UTF-8"

      def self.emit_string: (untyped ts, untyped te, untyped meta, block: untyped block) -> untyped
    end
  end
end

module GraphQL
  module Language
    # @api private
    #
    # {GraphQL::Language::DocumentFromSchemaDefinition} is used to convert a {GraphQL::Schema} object
    # To a {GraphQL::Language::Document} AST node.
    #
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @param include_introspection_types [Boolean] Whether or not to include introspection types in the AST
    # @param include_built_in_scalars [Boolean] Whether or not to include built in scalars in the AST
    # @param include_built_in_directives [Boolean] Whether or not to include built in directives in the AST
    class DocumentFromSchemaDefinition
      def initialize: (untyped schema, ?context: untyped? context, ?only: untyped? only, ?except: untyped? except, ?include_introspection_types: bool include_introspection_types, ?include_built_in_directives: bool include_built_in_directives, ?include_built_in_scalars: bool include_built_in_scalars, ?always_include_schema: bool always_include_schema) -> void

      def document: () -> untyped

      def build_schema_node: () -> untyped

      def build_object_type_node: (untyped object_type) -> untyped

      def build_field_node: (untyped field) -> untyped

      def build_union_type_node: (untyped union_type) -> untyped

      def build_interface_type_node: (untyped interface_type) -> untyped

      def build_enum_type_node: (untyped enum_type) -> untyped

      def build_enum_value_node: (untyped enum_value) -> untyped

      def build_scalar_type_node: (untyped scalar_type) -> untyped

      def build_argument_node: (untyped argument) -> untyped

      def build_input_object_node: (untyped input_object) -> untyped

      def build_directive_node: (untyped directive) -> untyped

      def build_directive_location_nodes: (untyped locations) -> untyped

      def build_directive_location_node: (untyped location) -> untyped

      def build_type_name_node: (untyped `type`) -> untyped

      def build_default_value: (untyped default_value, untyped `type`) -> untyped

      def build_type_definition_node: (untyped `type`) -> untyped

      def build_argument_nodes: (untyped arguments) -> untyped

      def build_directive_nodes: (untyped directives) -> untyped

      def build_definition_nodes: () -> untyped

      def build_type_definition_nodes: (untyped types) -> untyped

      def build_field_nodes: (untyped fields) -> untyped

      private

      def include_schema_node?: () -> untyped

      def schema_respects_root_name_conventions?: (untyped schema) -> untyped

      def directives: (untyped member) -> untyped

      def definition_directives: (untyped member) -> untyped

      def ast_directives: (untyped member) -> untyped

      attr_reader schema: untyped

      attr_reader warden: untyped

      attr_reader always_include_schema: untyped

      attr_reader include_introspection_types: untyped

      attr_reader include_built_in_directives: untyped

      attr_reader include_built_in_scalars: untyped
    end
  end
end

module GraphQL
  module Language
    class Parser < Racc::Parser
      Racc_arg: ::Array[untyped]

      Racc_token_to_s_table: ::Array["$end" | "error" | "LCURLY" | "RCURLY" | "QUERY" | "MUTATION" | "SUBSCRIPTION" | "LPAREN" | "RPAREN" | "VAR_SIGN" | "COLON" | "BANG" | "LBRACKET" | "RBRACKET" | "EQUALS" | "ON" | "SCHEMA" | "SCALAR" | "TYPE" | "IMPLEMENTS" | "INTERFACE" | "UNION" | "ENUM" | "INPUT" | "DIRECTIVE" | "IDENTIFIER" | "FRAGMENT" | "REPEATABLE" | "TRUE" | "FALSE" | "FLOAT" | "INT" | "STRING" | "NULL" | "DIR_SIGN" | "ELLIPSIS" | "EXTEND" | "AMP" | "PIPE" | "$start" | "target" | "document" | "definitions_list" | "definition" | "executable_definition" | "type_system_definition" | "type_system_extension" | "operation_definition" | "fragment_definition" | "operation_type" | "operation_name_opt" | "variable_definitions_opt" | "directives_list_opt" | "selection_set" | "selection_list" | "name" | "variable_definitions_list" | "variable_definition" | "type" | "default_value_opt" | "nullable_type" | "literal_value" | "selection_set_opt" | "selection" | "field" | "fragment_spread" | "inline_fragment" | "arguments_opt" | "name_without_on" | "schema_keyword" | "enum_name" | "enum_value_definition" | "description_opt" | "enum_value_definitions" | "arguments_list" | "argument" | "input_value" | "null_value" | "enum_value" | "list_value" | "object_literal_value" | "variable" | "object_value" | "list_value_list" | "object_value_list" | "object_value_field" | "object_literal_value_list" | "object_literal_value_field" | "directives_list" | "directive" | "fragment_name_opt" | "schema_definition" | "type_definition" | "directive_definition" | "operation_type_definition_list" | "operation_type_definition" | "scalar_type_definition" | "object_type_definition" | "interface_type_definition" | "union_type_definition" | "enum_type_definition" | "input_object_type_definition" | "schema_extension" | "type_extension" | "scalar_type_extension" | "object_type_extension" | "interface_type_extension" | "union_type_extension" | "enum_type_extension" | "input_object_type_extension" | "implements" | "field_definition_list" | "implements_opt" | "union_members" | "input_value_definition_list" | "description" | "interfaces_list" | "legacy_interfaces_list" | "input_value_definition" | "arguments_definitions_opt" | "field_definition" | "directive_repeatable_opt" | "directive_locations"]

      Racc_debug_parser: false

      def _reduce_none: (untyped val, untyped _values, untyped result) -> untyped
    end
  end
end

module GraphQL
  module Language
    # Depth-first traversal through the tree, calling hooks at each stop.
    #
    # @example Create a visitor counting certain field names
    #   class NameCounter < GraphQL::Language::Visitor
    #     def initialize(document, field_name)
    #       super(document)
    #       @field_name = field_name
    #       @count = 0
    #     end
    #
    #     attr_reader :count
    #
    #     def on_field(node, parent)
    #       # if this field matches our search, increment the counter
    #       if node.name == @field_name
    #         @count += 1
    #       end
    #       # Continue visiting subfields:
    #       super
    #     end
    #   end
    #
    #   # Initialize a visitor
    #   visitor = NameCounter.new(document, "name")
    #   # Run it
    #   visitor.visit
    #   # Check the result
    #   visitor.count
    #   # => 3
    class Visitor
      # If any hook returns this value, the {Visitor} stops visiting this
      # node right away
      # @deprecated Use `super` to continue the visit; or don't call it to halt.
      SKIP: :_skip

      class DeleteNode
      end

      # When this is returned from a visitor method,
      # Then the `node` passed into the method is removed from `parent`'s children.
      DELETE_NODE: untyped

      def initialize: (untyped document) -> void

      # @return [GraphQL::Language::Nodes::Document] The document with any modifications applied
      attr_reader result: untyped

      # Get a {NodeVisitor} for `node_class`
      # @param node_class [Class] The node class that you want to listen to
      # @return [NodeVisitor]
      #
      # @example Run a hook whenever you enter a new Field
      #   visitor[GraphQL::Language::Nodes::Field] << ->(node, parent) { p "Here's a field" }
      # @deprecated see `on_` methods, like {#on_field}
      def []: (untyped node_class) -> untyped

      # Visit `document` and all children, applying hooks as you go
      # @return [void]
      def visit: () -> untyped

      # Call the user-defined handler for `node`.
      def visit_node: (untyped node, untyped parent) -> untyped

      # The default implementation for visiting an AST node.
      # It doesn't _do_ anything, but it continues to visiting the node's children.
      # To customize this hook, override one of its make_visit_methodes (or the base method?)
      # in your subclasses.
      #
      # For compatibility, it calls hook procs, too.
      # @param node [GraphQL::Language::Nodes::AbstractNode] the node being visited
      # @param parent [GraphQL::Language::Nodes::AbstractNode, nil] the previously-visited node, or `nil` if this is the root node.
      # @return [Array, nil] If there were modifications, it returns an array of new nodes, otherwise, it returns `nil`.
      def on_abstract_node: (untyped node, untyped parent) -> untyped

      # We don't use `alias` here because it breaks `super`
      def self.make_visit_method: (untyped node_method) -> untyped

      private

      # Run the hooks for `node`, and if the hooks return a copy of `node`,
      # copy `parent` so that it contains the copy of that node as a child,
      # then return the copies
      # If a non-array value is returned, consuming functions should ignore
      # said value
      def on_node_with_modifications: (untyped node, untyped parent) -> untyped

      def begin_visit: (untyped node, untyped parent) -> untyped

      # Should global `leave` visitors come first or last?
      def end_visit: (untyped node, untyped parent) -> untyped

      # If one of the visitors returns SKIP, stop visiting this node
      def self.apply_hooks: (untyped hooks, untyped node, untyped parent) -> (false | true)

      # Collect `enter` and `leave` hooks for classes in {GraphQL::Language::Nodes}
      #
      # Access {NodeVisitor}s via {GraphQL::Language::Visitor#[]}
      class NodeVisitor
        # @return [Array<Proc>] Hooks to call when entering a node of this type
        attr_reader enter: untyped

        # @return [Array<Proc>] Hooks to call when leaving a node of this type
        attr_reader leave: untyped

        def initialize: () -> void

        # Shorthand to add a hook to the {#enter} array
        # @param hook [Proc] A hook to add
        def <<: (untyped hook) -> untyped
      end
    end
  end
end

module GraphQL
  module Language
    class Cache
      def initialize: (untyped path) -> void

      DIGEST: untyped

      def fetch: (untyped filename) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  module Language
    # A custom printer used to print sanitized queries. It inlines provided variables
    # within the query for facilitate logging and analysis of queries.
    #
    # The printer returns `nil` if the query is invalid.
    #
    # Since the GraphQL Ruby AST for a GraphQL query doesnt contain any reference
    # on the type of fields or arguments, we have to track the current object, field
    # and input type while printing the query.
    #
    # @example Printing a scrubbed string
    #   printer = QueryPrinter.new(query)
    #   puts printer.sanitized_query_string
    #
    # @see {Query#sanitized_query_string}
    class SanitizedPrinter < GraphQL::Language::Printer
      REDACTED: "\"<REDACTED>\""

      def initialize: (untyped query, ?inline_variables: bool inline_variables) -> void

      # @return [String, nil] A scrubbed query string, if the query was valid.
      def sanitized_query_string: () -> untyped

      def print_node: (untyped node, ?indent: ::String indent) -> untyped

      # Indicates whether or not to redact non-null values for the given argument. Defaults to redacting all strings
      # arguments but this can be customized by subclasses.
      def redact_argument_value?: (untyped argument, untyped value) -> untyped

      # Returns the value to use for redacted versions of the given argument. Defaults to the
      # string "<REDACTED>".
      def redacted_argument_value: (untyped argument) -> untyped

      def print_argument: (untyped argument) -> untyped

      def coerce_argument_value_to_list?: (untyped `type`, untyped value) -> untyped

      def print_variable_identifier: (untyped variable_id) -> untyped

      def print_field: (untyped field, ?indent: ::String indent) -> untyped

      def print_inline_fragment: (untyped inline_fragment, ?indent: ::String indent) -> untyped

      def print_fragment_definition: (untyped fragment_def, ?indent: ::String indent) -> untyped

      def print_directive: (untyped directive) -> untyped

      # Print the operation definition but do not include the variable
      # definitions since we will inline them within the query
      def print_operation_definition: (untyped operation_definition, ?indent: ::String indent) -> untyped

      private

      def value_to_ast: (untyped value, untyped `type`) -> untyped

      attr_reader query: untyped
    end
  end
end

module GraphQL
  module Language
    # Exposes {.generate}, which turns AST nodes back into query strings.
    module Generation
      extend ::GraphQL::Language::Generation

      # Turn an AST node back into a string.
      #
      # @example Turning a document into a query
      #    document = GraphQL.parse(query_string)
      #    GraphQL::Language::Generation.generate(document)
      #    # => "{ ... }"
      #
      # @param node [GraphQL::Language::Nodes::AbstractNode] an AST node to recursively stringify
      # @param indent [String] Whitespace to add to each printed node
      # @param printer [GraphQL::Language::Printer] An optional custom printer for printing AST nodes. Defaults to GraphQL::Language::Printer
      # @return [String] Valid GraphQL for `node`
      def generate: (untyped node, ?indent: ::String indent, ?printer: untyped printer) -> untyped
    end
  end
end

module GraphQL
  module Language
    # Emitted by the lexer and passed to the parser.
    # Contains type, value and position data.
    class Token
      # @return [Symbol] The kind of token this is
      attr_reader name: untyped

      # @return [String] The text of this token
      attr_reader value: untyped

      attr_reader prev_token: untyped

      attr_reader line: untyped

      attr_reader col: untyped

      def initialize: (untyped name, untyped value, untyped line, untyped col, untyped prev_token) -> void

      alias to_s value

      def to_i: () -> untyped

      def to_f: () -> untyped

      def line_and_column: () -> ::Array[untyped]

      def inspect: () -> ::String
    end
  end
end



module GraphQL
  module Introspection
    class DirectiveLocationEnum < GraphQL::Schema::Enum
    end
  end
end

module GraphQL
  module Introspection
    class EnumValueType < Introspection::BaseObject
      def name: () -> untyped

      def is_deprecated: () -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class InputValueType < Introspection::BaseObject
      def is_deprecated: () -> untyped

      def default_value: () -> untyped

      private

      # Recursively serialize, taking care not to add quotes to enum values
      def serialize_default_value: (untyped value, untyped `type`) -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class FieldType < Introspection::BaseObject
      def is_deprecated: () -> untyped

      def args: (include_deprecated: untyped include_deprecated) -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class TypeKindEnum < GraphQL::Schema::Enum
    end
  end
end

# This query is used by graphql-client so don't add the includeDeprecated
# argument for inputFields since the server may not support it. Two stage
# introspection queries will be required to handle this in clients.
GraphQL::Introspection::INTROSPECTION_QUERY: untyped

module GraphQL
  module Introspection
    class DynamicFields < Introspection::BaseObject
      def __typename: () -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class DirectiveType < Introspection::BaseObject
      def args: (include_deprecated: untyped include_deprecated) -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class TypeType < Introspection::BaseObject
      def specified_by_url: () -> untyped

      def kind: () -> untyped

      def enum_values: (include_deprecated: untyped include_deprecated) -> untyped

      def interfaces: () -> untyped

      def input_fields: (include_deprecated: untyped include_deprecated) -> untyped

      def possible_types: () -> untyped

      def fields: (include_deprecated: untyped include_deprecated) -> untyped

      def of_type: () -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class EntryPoints < Introspection::BaseObject
      def __schema: () -> untyped

      def __type: (name: untyped name) -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class SchemaType < Introspection::BaseObject
      def schema_description: () -> untyped

      def types: () -> untyped

      def query_type: () -> untyped

      def mutation_type: () -> untyped

      def subscription_type: () -> untyped

      def directives: () -> untyped

      private

      def permitted_root_type: (untyped op_type) -> untyped
    end
  end
end

module GraphQL
  module Introspection
    class BaseObject < GraphQL::Schema::Object
      def self.field: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  module Dig
    # implemented using the old activesupport #dig instead of the ruby built-in
    # so we can use some of the magic in Schema::InputObject and Interpreter::Arguments
    # to handle stringified/symbolized keys.
    #
    # @param args [Array<[String, Symbol>] Retrieves the value object corresponding to the each key objects repeatedly
    # @return [Object]
    def dig: (untyped own_key, *untyped rest_keys) -> untyped
  end
end


module GraphQL
  class Subscriptions
    class DefaultSubscriptionResolveExtension < GraphQL::Schema::FieldExtension
      def resolve: (context: untyped context, object: untyped object, arguments: untyped arguments) { (untyped, untyped) -> untyped } -> untyped

      def after_resolve: (value: untyped value, context: untyped context, object: untyped object, arguments: untyped arguments, **untyped rest) -> untyped

      private

      def arguments_without_field_extras: (arguments: untyped arguments) -> untyped
    end
  end
end

module GraphQL
  class Subscriptions
    # A subscriptions implementation that sends data
    # as ActionCable broadcastings.
    #
    # Some things to keep in mind:
    #
    # - No queueing system; ActiveJob should be added
    # - Take care to reload context when re-delivering the subscription. (see {Query#subscription_update?})
    # - Avoid the async ActionCable adapter and use the redis or PostgreSQL adapters instead. Otherwise calling #trigger won't work from background jobs or the Rails console.
    #
    # @example Adding ActionCableSubscriptions to your schema
    #   class MySchema < GraphQL::Schema
    #     # ...
    #     use GraphQL::Subscriptions::ActionCableSubscriptions
    #   end
    #
    # @example Implementing a channel for GraphQL Subscriptions
    #   class GraphqlChannel < ApplicationCable::Channel
    #     def subscribed
    #       @subscription_ids = []
    #     end
    #
    #     def execute(data)
    #       query = data["query"]
    #       variables = ensure_hash(data["variables"])
    #       operation_name = data["operationName"]
    #       context = {
    #         # Re-implement whatever context methods you need
    #         # in this channel or ApplicationCable::Channel
    #         # current_user: current_user,
    #         # Make sure the channel is in the context
    #         channel: self,
    #       }
    #
    #       result = MySchema.execute(
    #         query: query,
    #         context: context,
    #         variables: variables,
    #         operation_name: operation_name
    #       )
    #
    #       payload = {
    #         result: result.to_h,
    #         more: result.subscription?,
    #       }
    #
    #       # Track the subscription here so we can remove it
    #       # on unsubscribe.
    #       if result.context[:subscription_id]
    #         @subscription_ids << result.context[:subscription_id]
    #       end
    #
    #       transmit(payload)
    #     end
    #
    #     def unsubscribed
    #       @subscription_ids.each { |sid|
    #         MySchema.subscriptions.delete_subscription(sid)
    #       }
    #     end
    #
    #     private
    #
    #       def ensure_hash(ambiguous_param)
    #         case ambiguous_param
    #         when String
    #           if ambiguous_param.present?
    #             ensure_hash(JSON.parse(ambiguous_param))
    #           else
    #             {}
    #           end
    #         when Hash, ActionController::Parameters
    #           ambiguous_param
    #         when nil
    #           {}
    #         else
    #           raise ArgumentError, "Unexpected parameter: #{ambiguous_param}"
    #         end
    #       end
    #   end
    #
    class ActionCableSubscriptions < GraphQL::Subscriptions
      SUBSCRIPTION_PREFIX: "graphql-subscription:"

      EVENT_PREFIX: "graphql-event:"

      # @param serializer [<#dump(obj), #load(string)] Used for serializing messages before handing them to `.broadcast(msg)`
      # @param namespace [string] Used to namespace events and subscriptions (default: '')
      def initialize: (?serializer: untyped serializer, ?namespace: ::String namespace, ?action_cable: untyped action_cable, ?action_cable_coder: untyped action_cable_coder, **untyped rest) -> void

      # An event was triggered; Push the data over ActionCable.
      # Subscribers will re-evaluate locally.
      def execute_all: (untyped event, untyped object) -> untyped

      # This subscription was re-evaluated.
      # Send it to the specific stream where this client was waiting.
      def deliver: (untyped subscription_id, untyped result) -> untyped

      # A query was run where these events were subscribed to.
      # Store them in memory in _this_ ActionCable frontend.
      # It will receive notifications when events come in
      # and re-evaluate the query locally.
      def write_subscription: (untyped query, untyped events) -> untyped

      # Every subscribing channel is listening here, but only one of them takes any action.
      # This is so we can reuse payloads when possible, and make one payload to send to
      # all subscribers.
      #
      # But the problem is, any channel could close at any time, so each channel has to
      # be ready to take over the primary position.
      #
      # To make sure there's always one-and-only-one channel building payloads,
      # let the listener belonging to the first event on the list be
      # the one to build and publish payloads.
      #
      def setup_stream: (untyped channel, untyped initial_event) -> untyped

      # This is called to turn an ActionCable-broadcasted string (JSON)
      # into a query-ready application object.
      # @param message [String] n ActionCable-broadcasted string (JSON)
      # @param context [GraphQL::Query::Context] the context of the first event for a given subscription fingerprint
      def load_action_cable_message: (untyped message, untyped context) -> untyped

      # Return the query from "storage" (in memory)
      def read_subscription: (untyped subscription_id) -> untyped

      # The channel was closed, forget about it.
      def delete_subscription: (untyped subscription_id) -> untyped

      private

      def stream_subscription_name: (untyped subscription_id) -> untyped

      def stream_event_name: (untyped event) -> untyped
    end
  end
end

module GraphQL
  class Subscriptions
    # Detect whether the current operation:
    # - Is a subscription operation
    # - Is completely broadcastable
    #
    # Assign the result to `context.namespace(:subscriptions)[:subscription_broadcastable]`
    # @api private
    # @see Subscriptions#broadcastable? for a public API
    class BroadcastAnalyzer < GraphQL::Analysis::AST::Analyzer
      def initialize: (untyped subject) -> void

      # Only analyze subscription operations
      def analyze?: () -> untyped

      def on_enter_field: (untyped node, untyped parent, untyped visitor) -> (nil | untyped)

      # Assign the result to context.
      # (This method is allowed to return an error, but we don't need to)
      # @return [void]
      def result: () -> nil

      private

      # Modify `@subscription_broadcastable` based on `field_defn`'s configuration (and/or the default value)
      def apply_broadcastable: (untyped field_defn) -> untyped
    end
  end
end

module GraphQL
  class Subscriptions
    # Serialization helpers for passing subscription data around.
    # @api private
    module Serialize
      GLOBALID_KEY: "__gid__"

      SYMBOL_KEY: "__sym__"

      SYMBOL_KEYS_KEY: "__sym_keys__"

      TIMESTAMP_KEY: "__timestamp__"

      TIMESTAMP_FORMAT: "%Y-%m-%d %H:%M:%S.%N%z"

      # eg '2020-01-01 23:59:59.123456789+05:00'
      OPEN_STRUCT_KEY: "__ostruct__"

      # @param str [String] A serialized object from {.dump}
      # @return [Object] An object equivalent to the one passed to {.dump}
      def self?.load: (untyped str) -> untyped

      # @param obj [Object] Some subscription-related data to dump
      # @return [String] The stringified object
      def self?.dump: (untyped obj) -> untyped

      # This is for turning objects into subscription scopes.
      # It's a one-way transformation, can't reload this :'(
      # @param obj [Object]
      # @return [String]
      def self?.dump_recursive: (untyped obj) -> untyped

      private

      # @param value [Object] A parsed JSON object
      # @return [Object] An object that load Global::Identification recursive
      def self.load_value: (untyped value) -> untyped

      # @param obj [Object] Some subscription-related data to dump
      # @return [Object] The object that converted Global::Identification
      def self.dump_value: (untyped obj) -> untyped
    end
  end
end

module GraphQL
  class Subscriptions
    # This thing can be:
    # - Subscribed to by `subscription { ... }`
    # - Triggered by `MySchema.subscriber.trigger(name, arguments, obj)`
    #
    class Event
      # @return [String] Corresponds to the Subscription root field name
      attr_reader name: untyped

      # @return [GraphQL::Execution::Interpreter::Arguments]
      attr_reader arguments: untyped

      # @return [GraphQL::Query::Context]
      attr_reader context: untyped

      # @return [String] An opaque string which identifies this event, derived from `name` and `arguments`
      attr_reader topic: untyped

      def initialize: (name: untyped name, arguments: untyped arguments, ?field: untyped? field, ?context: untyped? context, ?scope: untyped? scope) -> void

      # @return [String] an identifier for this unit of subscription
      def self.serialize: (untyped _name, untyped arguments, untyped field, scope: untyped scope, ?context: untyped context) -> untyped

      # @return [String] a logical identifier for this event. (Stable when the query is broadcastable.)
      def fingerprint: () -> untyped

      private

      # This method does not support cyclic references in the Hash,
      # nor does it support Hashes whose keys are not sortable
      # with respect to their peers ( cases where a <=> b might throw an error )
      def self.deep_sort_hash_keys: (untyped hash_to_sort) -> untyped

      def self.deep_sort_array_hashes: (untyped array_to_inspect) -> untyped

      def self.stringify_args: (untyped arg_owner, untyped args, untyped context) -> untyped

      def self.get_arg_definition: (untyped arg_owner, untyped arg_name, untyped context) -> untyped
    end
  end
end

module GraphQL
  class Subscriptions
    # Wrap the root fields of the subscription type with special logic for:
    # - Registering the subscription during the first execution
    # - Evaluating the triggered portion(s) of the subscription during later execution
    class Instrumentation
      def initialize: (schema: untyped schema) -> void

      # If needed, prepare to gather events which this query subscribes to
      def before_query: (untyped query) -> untyped

      # After checking the root fields, pass the gathered events to the store
      def after_query: (untyped query) -> untyped
    end
  end
end

module GraphQL
  class Schema
    # Used to convert your {GraphQL::Schema} to a GraphQL schema string
    #
    # @example print your schema to standard output (via helper)
    #   puts GraphQL::Schema::Printer.print_schema(MySchema)
    #
    # @example print your schema to standard output
    #   puts GraphQL::Schema::Printer.new(MySchema).print_schema
    #
    # @example print a single type to standard output
    #   class Types::Query < GraphQL::Schema::Object
    #     description "The query root of this schema"
    #
    #     field :post, Types::Post, null: true
    #   end
    #
    #   class Types::Post < GraphQL::Schema::Object
    #     description "A blog post"
    #
    #     field :id, ID, null: false
    #     field :title, String, null: false
    #     field :body, String, null: false
    #   end
    #
    #   class MySchema < GraphQL::Schema
    #     query(Types::Query)
    #   end
    #
    #   printer = GraphQL::Schema::Printer.new(MySchema)
    #   puts printer.print_type(Types::Post)
    #
    class Printer < GraphQL::Language::Printer
      attr_reader schema: untyped

      attr_reader warden: untyped

      # @param schema [GraphQL::Schema]
      # @param context [Hash]
      # @param only [<#call(member, ctx)>]
      # @param except [<#call(member, ctx)>]
      # @param introspection [Boolean] Should include the introspection types in the string?
      def initialize: (untyped schema, ?context: untyped? context, ?only: untyped? only, ?except: untyped? except, ?introspection: bool introspection) -> void

      # Return the GraphQL schema string for the introspection type system
      def self.print_introspection_schema: () -> untyped

      # Return a GraphQL schema string for the defined types in the schema
      # @param schema [GraphQL::Schema]
      # @param context [Hash]
      # @param only [<#call(member, ctx)>]
      # @param except [<#call(member, ctx)>]
      def self.print_schema: (untyped schema, **untyped args) -> untyped

      # Return a GraphQL schema string for the defined types in the schema
      def print_schema: () -> untyped

      def print_type: (untyped `type`) -> untyped

      class IntrospectionPrinter < GraphQL::Language::Printer
        def print_schema_definition: (untyped schema) -> ::String
      end
    end
  end
end

module GraphQL
  class Schema
    class Union < GraphQL::Schema::Member
      extend GraphQL::Schema::Member::HasUnresolvedTypeError

      def self.inherited: (untyped child_class) -> untyped

      def self.possible_types: (*untyped types, ?context: untyped context, **untyped options) -> untyped

      def self.all_possible_types: () -> untyped

      def self.type_membership_class: (?untyped? membership_class) -> untyped

      def self.kind: () -> untyped

      def self.type_memberships: () -> untyped

      # Update a type membership whose `.object_type` is a string or late-bound type
      # so that the type membership's `.object_type` is the given `object_type`.
      # (This is used for updating the union after the schema as lazily loaded the union member.)
      # @api private
      def self.assign_type_membership_object_type: (untyped object_type) -> nil

      private

      def self.assert_valid_union_member: (untyped type_defn) -> untyped
    end
  end
end

module GraphQL
  # Extend this class to define GraphQL enums in your schema.
  #
  # By default, GraphQL enum values are translated into Ruby strings.
  # You can provide a custom value with the `value:` keyword.
  #
  # @example
  #   # equivalent to
  #   # enum PizzaTopping {
  #   #   MUSHROOMS
  #   #   ONIONS
  #   #   PEPPERS
  #   # }
  #   class PizzaTopping < GraphQL::Enum
  #     value :MUSHROOMS
  #     value :ONIONS
  #     value :PEPPERS
  #   end
  class Schema
    class Enum < GraphQL::Schema::Member
      extend GraphQL::Schema::Member::ValidatesInput

      class UnresolvedValueError < GraphQL::Error
        def initialize: (value: untyped value, enum: untyped enum, context: untyped context) -> void
      end

      # Define a value for this enum
      # @param graphql_name [String, Symbol] the GraphQL value for this, usually `SCREAMING_CASE`
      # @param description [String], the GraphQL description for this value, present in documentation
      # @param value [Object], the translated Ruby value for this object (defaults to `graphql_name`)
      # @param deprecation_reason [String] if this object is deprecated, include a message here
      # @return [void]
      # @see {Schema::EnumValue} which handles these inputs by default
      def self.value: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

      # @return [Array<GraphQL::Schema::EnumValue>] Possible values of this enum
      def self.enum_values: (?untyped context) -> untyped

      # @return [Array<Schema::EnumValue>] An unfiltered list of all definitions
      def self.all_enum_value_definitions: () -> untyped

      # @return [Hash<String => GraphQL::Schema::EnumValue>] Possible values of this enum, keyed by name.
      def self.values: (?untyped context) -> untyped

      # @return [Class] for handling `value(...)` inputs and building `GraphQL::Enum::EnumValue`s out of them
      def self.enum_value_class: (?untyped? new_enum_value_class) -> untyped

      def self.kind: () -> untyped

      def self.validate_non_null_input: (untyped value_name, untyped ctx) -> untyped

      def self.coerce_result: (untyped value, untyped ctx) -> untyped

      def self.coerce_input: (untyped value_name, untyped ctx) -> untyped

      def self.inherited: (untyped child_class) -> untyped

      private

      def self.own_values: () -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this to specifically reject or permit `nil` values (given as `null` from GraphQL).
      #
      # @example require a non-null value for an argument if it is provided
      #   argument :name, String, required: false, validates: { allow_null: false }
      class AllowNullValidator < Validator
        MESSAGE: "%{validated} can't be null"

        def initialize: (untyped allow_null_positional, ?allow_null: untyped? allow_null, ?message: untyped message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this to assert that string values match (or don't match) the given RegExp.
      #
      # @example requiring input to match a pattern
      #
      #   argument :handle, String, required: true,
      #     validates: { format: { with: /\A[a-z0-9_]+\Z/ } }
      #
      # @example reject inputs that match a pattern
      #
      #   argument :word_that_doesnt_begin_with_a_vowel, String, required: true,
      #     validates: { format: { without: /\A[aeiou]/ } }
      #
      #   # It's pretty hard to come up with a legitimate use case for `without:`
      #
      class FormatValidator < Validator
        # @param with [RegExp, nil]
        # @param without [Regexp, nil]
        # @param message [String]
        def initialize: (?with: untyped? with, ?without: untyped? without, ?message: ::String message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this to specifically reject values that respond to `.blank?` and respond truthy for that method.
      #
      # @example Require a non-empty string for an argument
      #   argument :name, String, required: true, validate: { allow_blank: false }
      class AllowBlankValidator < Validator
        def initialize: (untyped allow_blank_positional, ?allow_blank: untyped? allow_blank, ?message: ::String message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this to enforce a `.length` restriction on incoming values. It works for both Strings and Lists.
      #
      # @example Allow no more than 10 IDs
      #
      #   argument :ids, [ID], required: true, validates: { length: { maximum: 10 } }
      #
      # @example Require three selections
      #
      #   argument :ice_cream_preferences, [ICE_CREAM_FLAVOR], required: true, validates: { length: { is: 3 } }
      #
      class LengthValidator < Validator
        # @param maximum [Integer]
        # @param too_long [String] Used when `maximum` is exceeded or value is greater than `within`
        # @param minimum [Integer]
        # @param too_short [String] Used with value is less than `minimum` or less than `within`
        # @param is [Integer] Exact length requirement
        # @param wrong_length [String] Used when value doesn't match `is`
        # @param within [Range] An allowed range (becomes `minimum:` and `maximum:` under the hood)
        # @param message [String]
        def initialize: (?maximum: untyped? maximum, ?too_long: ::String too_long, ?minimum: untyped? minimum, ?too_short: ::String too_short, ?is: untyped? is, ?within: untyped? within, ?wrong_length: ::String wrong_length, ?message: untyped? message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> (nil | untyped)
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this to specifically reject values from an argument.
      #
      # @example disallow certain values
      #
      #   argument :favorite_non_prime, Integer, required: true,
      #     validates: { exclusion: { in: [2, 3, 5, 7, ... ]} }
      #
      class ExclusionValidator < Validator
        # @param message [String]
        # @param in [Array] The values to reject
        def initialize: (in: untyped `in`, ?message: ::String message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this to assert numerical comparisons hold true for inputs.
      #
      # @example Require a number between 0 and 1
      #
      #   argument :batting_average, Float, required: true, validates: { numericality: { within: 0..1 } }
      #
      # @example Require the number 42
      #
      #   argument :the_answer, Integer, required: true, validates: { numericality: { equal_to: 42 } }
      #
      # @example Require a real number
      #
      #   argument :items_count, Integer, required: true, validates: { numericality: { greater_than_or_equal_to: 0 } }
      #
      class NumericalityValidator < Validator
        # @param greater_than [Integer]
        # @param greater_than_or_equal_to [Integer]
        # @param less_than [Integer]
        # @param less_than_or_equal_to [Integer]
        # @param equal_to [Integer]
        # @param other_than [Integer]
        # @param odd [Boolean]
        # @param even [Boolean]
        # @param within [Range]
        # @param message [String] used for all validation failures
        def initialize: (?greater_than: untyped? greater_than, ?greater_than_or_equal_to: untyped? greater_than_or_equal_to, ?less_than: untyped? less_than, ?less_than_or_equal_to: untyped? less_than_or_equal_to, ?equal_to: untyped? equal_to, ?other_than: untyped? other_than, ?odd: untyped? odd, ?even: untyped? even, ?within: untyped? within, ?message: ::String message, ?null_message: untyped null_message, **untyped default_options) -> void

        def validate: (untyped object, untyped context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # Use this validator to require _one_ of the named arguments to be present.
      # Or, use Arrays of symbols to name a valid _set_ of arguments.
      #
      # (This is for specifying mutually exclusive sets of arguments.)
      #
      # @example Require exactly one of these arguments
      #
      #   field :update_amount, IngredientAmount, null: false do
      #     argument :ingredient_id, ID, required: true
      #     argument :cups, Integer, required: false
      #     argument :tablespoons, Integer, required: false
      #     argument :teaspoons, Integer, required: false
      #     validates required: { one_of: [:cups, :tablespoons, :teaspoons] }
      #   end
      #
      # @example Require one of these _sets_ of arguments
      #
      #  field :find_object, Node, null: true do
      #    argument :node_id, ID, required: false
      #    argument :object_type, String, required: false
      #    argument :object_id, Integer, required: false
      #    # either a global `node_id` or an `object_type`/`object_id` pair is required:
      #    validates required: { one_of: [:node_id, [:object_type, :object_id]] }
      #  end
      #
      # @example require _some_ value for an argument, even if it's null
      #   field :update_settings, AccountSettings do
      #     # `required: :nullable` means this argument must be given, but may be `null`
      #     argument :age, Integer, required: :nullable
      #   end
      #
      class RequiredValidator < Validator
        # @param one_of [Symbol, Array<Symbol>] An argument, or a list of arguments, that represents a valid set of inputs for this field
        # @param message [String]
        def initialize: (?one_of: untyped? one_of, ?argument: untyped? argument, ?message: ::String message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # You can use this to allow certain values for an argument.
      #
      # Usually, a {GraphQL::Schema::Enum} is better for this, because it's self-documenting.
      #
      # @example only allow certain values for an argument
      #
      #   argument :favorite_prime, Integer, required: true,
      #     validates: { inclusion: { in: [2, 3, 5, 7, 11, ... ] } }
      #
      class InclusionValidator < Validator
        # @param message [String]
        # @param in [Array] The values to allow
        def initialize: (in: untyped `in`, ?message: ::String message, **untyped default_options) -> void

        def validate: (untyped _object, untyped _context, untyped value) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    # Restrict access to a {GraphQL::Schema} with a user-defined filter.
    #
    # When validating and executing a query, all access to schema members
    # should go through a warden. If you access the schema directly,
    # you may show a client something that it shouldn't be allowed to see.
    #
    # @example Hiding private fields
    #   private_members = -> (member, ctx) { member.metadata[:private] }
    #   result = Schema.execute(query_string, except: private_members)
    #
    # @example Custom filter implementation
    #   # It must respond to `#call(member)`.
    #   class MissingRequiredFlags
    #     def initialize(user)
    #       @user = user
    #     end
    #
    #     # Return `false` if any required flags are missing
    #     def call(member, ctx)
    #       member.metadata[:required_flags].any? do |flag|
    #         !@user.has_flag?(flag)
    #       end
    #     end
    #   end
    #
    #   # Then, use the custom filter in query:
    #   missing_required_flags = MissingRequiredFlags.new(current_user)
    #
    #   # This query can only access members which match the user's flags
    #   result = Schema.execute(query_string, except: missing_required_flags)
    #
    # @api private
    class Warden
      def self.from_context: (untyped context) -> untyped

      # @param visibility_method [Symbol] a Warden method to call for this entry
      # @param entry [Object, Array<Object>] One or more definitions for a given name in a GraphQL Schema
      # @param context [GraphQL::Query::Context]
      # @param warden [Warden]
      # @return [Object] `entry` or one of `entry`'s items if exactly one of them is visible for this context
      # @return [nil] If neither `entry` nor any of `entry`'s items are visible for this context
      def self.visible_entry?: (untyped visibility_method, untyped entry, untyped context, ?untyped warden) -> untyped

      # This is used when a caller provides a Hash for context.
      # We want to call the schema's hooks, but we don't have a full-blown warden.
      # The `context` arguments to these methods exist purely to simplify the code that
      # calls methods on this object, so it will have everything it needs.
      class PassThruWarden
        def self.visible_field?: (untyped field, untyped ctx) -> untyped

        def self.visible_argument?: (untyped arg, untyped ctx) -> untyped

        def self.visible_type?: (untyped `type`, untyped ctx) -> untyped

        def self.visible_enum_value?: (untyped ev, untyped ctx) -> untyped

        def self.visible_type_membership?: (untyped tm, untyped ctx) -> untyped
      end

      # @param filter [<#call(member)>] Objects are hidden when `.call(member, ctx)` returns true
      # @param context [GraphQL::Query::Context]
      # @param schema [GraphQL::Schema]
      def initialize: (untyped filter, context: untyped context, schema: untyped schema) -> void

      # @return [Hash<String, GraphQL::BaseType>] Visible types in the schema
      def types: () -> untyped

      # @return [GraphQL::BaseType, nil] The type named `type_name`, if it exists (else `nil`)
      def get_type: (untyped type_name) -> untyped

      # @return [Array<GraphQL::BaseType>] Visible and reachable types in the schema
      def reachable_types: () -> untyped

      # @return Boolean True if the type is visible and reachable in the schema
      def reachable_type?: (untyped type_name) -> untyped

      # @return [GraphQL::Field, nil] The field named `field_name` on `parent_type`, if it exists
      def get_field: (untyped parent_type, untyped field_name) -> untyped

      # @return [GraphQL::Argument, nil] The argument named `argument_name` on `parent_type`, if it exists and is visible
      def get_argument: (untyped parent_type, untyped argument_name) -> untyped

      # @return [Array<GraphQL::BaseType>] The types which may be member of `type_defn`
      def possible_types: (untyped type_defn) -> untyped

      # @param type_defn [GraphQL::ObjectType, GraphQL::InterfaceType]
      # @return [Array<GraphQL::Field>] Fields on `type_defn`
      def fields: (untyped type_defn) -> untyped

      # @param argument_owner [GraphQL::Field, GraphQL::InputObjectType]
      # @return [Array<GraphQL::Argument>] Visible arguments on `argument_owner`
      def arguments: (untyped argument_owner) -> untyped

      # @return [Array<GraphQL::EnumType::EnumValue>] Visible members of `enum_defn`
      def enum_values: (untyped enum_defn) -> untyped

      def visible_enum_value?: (untyped enum_value, ?untyped? _ctx) -> untyped

      # @return [Array<GraphQL::InterfaceType>] Visible interfaces implemented by `obj_type`
      def interfaces: (untyped obj_type) -> untyped

      def directives: () -> untyped

      def root_type_for_operation: (untyped op_name) -> untyped

      # @param owner [Class, Module] If provided, confirm that field has the given owner.
      def visible_field?: (untyped field_defn, ?untyped? _ctx, ?untyped owner) -> untyped

      def visible_argument?: (untyped arg_defn, ?untyped? _ctx) -> untyped

      def visible_type?: (untyped type_defn, ?untyped? _ctx) -> untyped

      def visible_type_membership?: (untyped type_membership, ?untyped? _ctx) -> untyped

      private

      def visible_and_reachable_type?: (untyped type_defn) -> untyped

      def union_memberships: (untyped obj_type) -> untyped

      # We need this to tell whether a field was inherited by an interface
      # even when that interface is hidden from `#interfaces`
      def unfiltered_interfaces: (untyped type_defn) -> untyped

      # If this field was inherited from an interface, and the field on that interface is _hidden_,
      # then treat this inherited field as hidden.
      # (If it _wasn't_ inherited, then don't hide it for this reason.)
      def field_on_visible_interface?: (untyped field_defn, untyped type_defn) -> untyped

      def root_type?: (untyped type_defn) -> untyped

      def referenced?: (untyped type_defn) -> untyped

      NO_REFERENCES: ::Array[untyped]

      def orphan_type?: (untyped type_defn) -> untyped

      def visible_abstract_type?: (untyped type_defn) -> untyped

      def visible_possible_types?: (untyped type_defn) -> untyped

      def visible?: (untyped member) -> untyped

      def read_through: () { (untyped) -> untyped } -> untyped

      def reachable_type_set: () -> untyped
    end
  end
end

module GraphQL
  class Schema
    # Represents a non null type in the schema.
    # Wraps a {Schema::Member} when it is required.
    # @see {Schema::Member::TypeSystemHelpers#to_non_null_type}
    class NonNull < GraphQL::Schema::Wrapper
      include Schema::Member::ValidatesInput

      # @return [GraphQL::TypeKinds::NON_NULL]
      def kind: () -> untyped

      # @return [true]
      def non_null?: () -> true

      # @return [Boolean] True if this type wraps a list type
      def list?: () -> untyped

      def to_type_signature: () -> ::String

      def inspect: () -> ::String

      def validate_input: (untyped value, untyped ctx) -> untyped

      # This is for introspection, where it's expected the name will be `null`
      def graphql_name: () -> nil

      def coerce_input: (untyped value, untyped ctx) -> untyped

      def coerce_result: (untyped value, untyped ctx) -> untyped

      # This is for implementing introspection
      def description: () -> nil
    end
  end
end

module GraphQL
  class Schema
    class IntrospectionSystem
      attr_reader types: untyped

      attr_reader possible_types: untyped

      def initialize: (untyped schema) -> void

      def entry_points: () -> untyped

      def entry_point: (name: untyped name) -> untyped

      def dynamic_fields: () -> untyped

      def dynamic_field: (name: untyped name) -> untyped

      # The introspection system is prepared with a bunch of LateBoundTypes.
      # Replace those with the objects that they refer to, since LateBoundTypes
      # aren't handled at runtime.
      #
      # @api private
      # @return void
      def resolve_late_bindings: () -> nil

      private

      def resolve_late_binding: (untyped late_bound_type) -> untyped

      def load_constant: (untyped class_name) -> untyped

      def get_fields_from_class: (class_sym: untyped class_sym) -> untyped

      # This is probably not 100% robust -- but it has to be good enough to avoid modifying the built-in introspection types
      def dup_type_class: (untyped type_class) -> untyped

      class PerFieldProxyResolve
        def initialize: (object_class: untyped object_class, inner_resolve: untyped inner_resolve) -> void

        def call: (untyped obj, untyped args, untyped ctx) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    module BuildFromDefinition
      # @see {Schema.from_definition}
      def self.from_definition: (untyped definition_string, ?parser: untyped parser, **untyped kwargs) -> untyped

      def self.from_definition_path: (untyped definition_path, ?parser: untyped parser, **untyped kwargs) -> untyped

      def self.from_document: (untyped document, default_resolve: untyped default_resolve, ?using: ::Hash[untyped, untyped] using, ?relay: bool relay) -> untyped

      # @api private
      module Builder
        extend ::GraphQL::Schema::BuildFromDefinition::Builder

        def build: (untyped document, default_resolve: untyped default_resolve, relay: untyped relay, ?using: ::Hash[untyped, untyped] using) -> untyped

        NullResolveType: untyped

        def build_definition_from_node: (untyped definition, untyped type_resolver, untyped default_resolve) -> untyped

        # Modify `types`, replacing any late-bound references to built-in types
        # with their actual definitions.
        #
        # (Schema definitions are allowed to reference those built-ins without redefining them.)
        # @return void
        def replace_late_bound_types_with_built_in: (untyped types) -> untyped

        def build_directives: (untyped definition, untyped ast_node, untyped type_resolver) -> untyped

        def prepare_directives: (untyped ast_node, untyped type_resolver) -> untyped

        def args_to_kwargs: (untyped arg_owner, untyped node) -> untyped

        def build_enum_type: (untyped enum_type_definition, untyped type_resolver) -> untyped

        def build_deprecation_reason: (untyped directives) -> (nil | untyped)

        def build_scalar_type: (untyped scalar_type_definition, untyped type_resolver, default_resolve: untyped default_resolve) -> untyped

        def build_scalar_type_coerce_method: (untyped scalar_class, untyped method_name, untyped default_definition_resolve) -> untyped

        def build_union_type: (untyped union_type_definition, untyped type_resolver) -> untyped

        def build_object_type: (untyped object_type_definition, untyped type_resolver) -> untyped

        def build_input_object_type: (untyped input_object_type_definition, untyped type_resolver) -> untyped

        def build_default_value: (untyped default_value) -> untyped

        NO_DEFAULT_VALUE: ::Hash[untyped, untyped]

        def build_arguments: (untyped type_class, untyped arguments, untyped type_resolver) -> untyped

        def build_directive: (untyped directive_definition, untyped type_resolver) -> untyped

        def build_interface_type: (untyped interface_type_definition, untyped type_resolver) -> untyped

        def build_fields: (untyped owner, untyped field_definitions, untyped type_resolver, default_resolve: untyped default_resolve) -> untyped

        def build_resolve_type: (untyped lookup_hash, untyped directives, untyped missing_type_handler) -> untyped

        def resolve_type_name: (untyped `type`) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    # @api private
    module NullMask
      def self.call: (untyped member, untyped ctx) -> false
    end
  end
end

module GraphQL
  class Schema
    # A class-based container for field configuration and resolution logic. It supports:
    #
    # - Arguments, via `.argument(...)` helper, which will be applied to the field.
    # - Return type, via `.type(..., null: ...)`, which will be applied to the field.
    # - Description, via `.description(...)`, which will be applied to the field
    # - Resolution, via `#resolve(**args)` method, which will be called to resolve the field.
    # - `#object` and `#context` accessors for use during `#resolve`.
    #
    # Resolvers can be attached with the `resolver:` option in a `field(...)` call.
    #
    # A resolver's configuration may be overridden with other keywords in the `field(...)` call.
    #
    # @see {GraphQL::Schema::Mutation} for a concrete subclass of `Resolver`.
    # @see {GraphQL::Function} `Resolver` is a replacement for `GraphQL::Function`
    class Resolver
      include Schema::Member::GraphQLTypeNames

      # Really we only need description from here, but:
      extend Schema::Member::BaseDSLMethods

      extend GraphQL::Schema::Member::HasArguments

      extend GraphQL::Schema::Member::HasValidators

      include Schema::Member::HasPath

      extend Schema::Member::HasPath

      # @param object [Object] The application object that this field is being resolved on
      # @param context [GraphQL::Query::Context]
      # @param field [GraphQL::Schema::Field]
      def initialize: (object: untyped object, context: untyped context, field: untyped field) -> void

      # @return [Object] The application object this field is being resolved on
      attr_reader object: untyped

      # @return [GraphQL::Query::Context]
      attr_reader context: untyped

      # @return [GraphQL::Dataloader]
      def dataloader: () -> untyped

      # @return [GraphQL::Schema::Field]
      attr_reader field: untyped

      def arguments: () -> untyped

      # This method is _actually_ called by the runtime,
      # it does some preparation and then eventually calls
      # the user-defined `#resolve` method.
      # @api private
      def resolve_with_support: (**untyped args) -> untyped

      # Do the work. Everything happens here.
      # @return [Object] An object corresponding to the return type
      def resolve: (**untyped args) -> untyped

      # Called before arguments are prepared.
      # Implement this hook to make checks before doing any work.
      #
      # If it returns a lazy object (like a promise), it will be synced by GraphQL
      # (but the resulting value won't be used).
      #
      # @param args [Hash] The input arguments, if there are any
      # @raise [GraphQL::ExecutionError] To add an error to the response
      # @raise [GraphQL::UnauthorizedError] To signal an authorization failure
      # @return [Boolean, early_return_data] If `false`, execution will stop (and `early_return_data` will be returned instead, if present.)
      def ready?: (**untyped args) -> true

      # Called after arguments are loaded, but before resolving.
      #
      # Override it to check everything before calling the mutation.
      # @param inputs [Hash] The input arguments
      # @raise [GraphQL::ExecutionError] To add an error to the response
      # @raise [GraphQL::UnauthorizedError] To signal an authorization failure
      # @return [Boolean, early_return_data] If `false`, execution will stop (and `early_return_data` will be returned instead, if present.)
      def authorized?: (**untyped inputs) -> untyped

      # Called when an object loaded by `loads:` fails the `.authorized?` check for its resolved GraphQL object type.
      #
      # By default, the error is re-raised and passed along to {{Schema.unauthorized_object}}.
      #
      # Any value returned here will be used _instead of_ of the loaded object.
      # @param err [GraphQL::UnauthorizedError]
      def unauthorized_object: (untyped err) -> untyped

      private

      def authorize_arguments: (untyped args, untyped inputs) -> untyped

      def load_arguments: (untyped args) -> untyped

      def get_argument: (untyped name, ?untyped context) -> untyped

      def self.field_arguments: (?untyped context) -> untyped

      def self.get_field_argument: (untyped name, ?untyped context) -> untyped

      def self.all_field_argument_definitions: () -> untyped

      # Default `:resolve` set below.
      # @return [Symbol] The method to call on instances of this object to resolve the field
      def self.resolve_method: (?untyped? new_method) -> untyped

      # Additional info injected into {#resolve}
      # @see {GraphQL::Schema::Field#extras}
      def self.extras: (?untyped? new_extras) -> untyped

      # If `true` (default), then the return type for this resolver will be nullable.
      # If `false`, then the return type is non-null.
      #
      # @see #type which sets the return type of this field and accepts a `null:` option
      # @param allow_null [Boolean] Whether or not the response can be null
      def self.null: (?untyped? allow_null) -> untyped

      def self.resolver_method: (?untyped? new_method_name) -> untyped

      # Call this method to get the return type of the field,
      # or use it as a configuration method to assign a return type
      # instead of generating one.
      # TODO unify with {#null}
      # @param new_type [Class, Array<Class>, nil] If a type definition class is provided, it will be used as the return type of the field
      # @param null [true, false] Whether or not the field may return `nil`
      # @return [Class] The type which this field returns.
      def self.type: (?untyped? new_type, ?null: untyped? null) -> untyped

      # Specifies the complexity of the field. Defaults to `1`
      # @return [Integer, Proc]
      def self.complexity: (?untyped? new_complexity) -> untyped

      def self.broadcastable: (untyped new_broadcastable) -> untyped

      # @return [Boolean, nil]
      def self.broadcastable?: () -> untyped

      # Get or set the `max_page_size:` which will be configured for fields using this resolver
      # (`nil` means "unlimited max page size".)
      # @param max_page_size [Integer, nil] Set a new value
      # @return [Integer, nil] The `max_page_size` assigned to fields that use this resolver
      def self.max_page_size: (?::Symbol new_max_page_size) -> untyped

      # @return [Boolean] `true` if this resolver or a superclass has an assigned `max_page_size`
      def self.has_max_page_size?: () -> untyped

      # A non-normalized type configuration, without `null` applied
      def self.type_expr: () -> untyped

      # Add an argument to this field's signature, but
      # also add some preparation hook methods which will be used for this argument
      # @see {GraphQL::Schema::Argument#initialize} for the signature
      def self.argument: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

      # Registers new extension
      # @param extension [Class] Extension class
      # @param options [Hash] Optional extension options
      def self.extension: (untyped extension, **untyped options) -> untyped

      # @api private
      def self.extensions: () -> untyped

      def self.own_extensions: () -> untyped
    end
  end
end

module GraphQL
  class Schema
    # You can use the result of {GraphQL::Introspection::INTROSPECTION_QUERY}
    # to make a schema. This schema is missing some important details like
    # `resolve` functions, but it does include the full type system,
    # so you can use it to validate queries.
    #
    # @see GraphQL::Schema.from_introspection for a public API
    module Loader
      extend ::GraphQL::Schema::Loader

      # Create schema with the result of an introspection query.
      # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
      # @return [Class] the schema described by `input`
      def load: (untyped introspection_result) -> untyped

      NullScalarCoerce: untyped

      private

      def self.resolve_type: (untyped types, untyped `type`) -> untyped

      def self.extract_default_value: (untyped default_value_str, untyped input_value_ast) -> untyped

      def self.define_type: (untyped `type`, untyped type_resolver) -> untyped

      def self.define_directive: (untyped directive, untyped type_resolver) -> untyped

      public

      def self.build_fields: (untyped type_defn, untyped fields, untyped type_resolver) -> untyped

      def self.build_arguments: (untyped arg_owner, untyped args, untyped type_resolver) -> untyped
    end
  end
end

# backport from ruby v2.5 to v2.2 that has no `padding` things
# @api private
module Base64Bp
  # extend Base64

  def self?.urlsafe_encode64: (untyped bin, padding: untyped padding) -> untyped

  def self?.urlsafe_decode64: (untyped str) -> untyped
end

module GraphQL
  class Schema
    # Subclasses of this can influence how {GraphQL::Execution::Interpreter} runs queries.
    #
    # - {.include?}: if it returns `false`, the field or fragment will be skipped altogether, as if it were absent
    # - {.resolve}: Wraps field resolution (so it should call `yield` to continue)
    class Directive < GraphQL::Schema::Member
      extend GraphQL::Schema::Member::HasArguments

      def self.path: () -> ::String

      # Return a name based on the class name,
      # but downcase the first letter.
      def self.default_graphql_name: () -> untyped

      def self.locations: (*untyped new_locations) -> untyped

      def self.default_directive: (?untyped? new_default_directive) -> untyped

      def self.default_directive?: () -> untyped

      # If false, this part of the query won't be evaluated
      def self.include?: (untyped _object, untyped arguments, untyped context) -> untyped

      # Determines whether {Execution::Lookahead} considers the field to be selected
      def self.static_include?: (untyped _arguments, untyped _context) -> true

      # Continuing is passed as a block; `yield` to continue
      def self.resolve: (untyped object, untyped arguments, untyped context) { () -> untyped } -> untyped

      # Continuing is passed as a block, yield to continue.
      def self.resolve_each: (untyped object, untyped arguments, untyped context) { () -> untyped } -> untyped

      def self.on_field?: () -> untyped

      def self.on_fragment?: () -> untyped

      def self.on_operation?: () -> untyped

      def self.repeatable?: () -> untyped

      def self.repeatable: (untyped new_value) -> untyped

      # @return [GraphQL::Schema::Field, GraphQL::Schema::Argument, Class, Module]
      attr_reader owner: untyped

      # @return [GraphQL::Interpreter::Arguments]
      attr_reader arguments: untyped

      def initialize: (untyped owner, **untyped arguments) -> void

      def graphql_name: () -> untyped

      LOCATIONS: ::Array[untyped]

      DEFAULT_DEPRECATION_REASON: "No longer supported"

      LOCATION_DESCRIPTIONS: { QUERY: "Location adjacent to a query operation.", MUTATION: "Location adjacent to a mutation operation.", SUBSCRIPTION: "Location adjacent to a subscription operation.", FIELD: "Location adjacent to a field.", FRAGMENT_DEFINITION: "Location adjacent to a fragment definition.", FRAGMENT_SPREAD: "Location adjacent to a fragment spread.", INLINE_FRAGMENT: "Location adjacent to an inline fragment.", SCHEMA: "Location adjacent to a schema definition.", SCALAR: "Location adjacent to a scalar definition.", OBJECT: "Location adjacent to an object type definition.", FIELD_DEFINITION: "Location adjacent to a field definition.", ARGUMENT_DEFINITION: "Location adjacent to an argument definition.", INTERFACE: "Location adjacent to an interface definition.", UNION: "Location adjacent to a union definition.", ENUM: "Location adjacent to an enum definition.", ENUM_VALUE: "Location adjacent to an enum value definition.", INPUT_OBJECT: "Location adjacent to an input object type definition.", INPUT_FIELD_DEFINITION: "Location adjacent to an input object field definition.", VARIABLE_DEFINITION: "Location adjacent to a variable definition." }

      private

      def assert_valid_owner: () -> untyped

      def assert_has_location: (untyped location) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasAstNode
        # If this schema was parsed from a `.graphql` file (or other SDL),
        # this is the AST node that defined this part of the schema.
        def ast_node: (?untyped? new_ast_node) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasDeprecationReason
        # @return [String, nil] Explains why this member was deprecated (if present, this will be marked deprecated in introspection)
        def deprecation_reason: () -> untyped

        # Set the deprecation reason for this member, or remove it by assigning `nil`
        # @param text [String, nil]
        def deprecation_reason=: (untyped text) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module TypeSystemHelpers
        # @return [Schema::NonNull] Make a non-null-type representation of this type
        def to_non_null_type: () -> untyped

        # @return [Schema::List] Make a list-type representation of this type
        def to_list_type: () -> untyped

        # @return [Boolean] true if this is a non-nullable type. A nullable list of non-nullables is considered nullable.
        def non_null?: () -> false

        # @return [Boolean] true if this is a list type. A non-nullable list is considered a list.
        def list?: () -> false

        def to_type_signature: () -> untyped

        # @return [GraphQL::TypeKinds::TypeKind]
        def kind: () -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      # DSL methods shared by lots of things in the GraphQL Schema.
      # @api private
      # @see Classes that extend this, eg {GraphQL::Schema::Object}
      module BaseDSLMethods
        include GraphQL::Schema::FindInheritedValue

        # Call this with a new name to override the default name for this schema member; OR
        # call it without an argument to get the name of this schema member
        #
        # The default name is implemented in default_graphql_name
        # @param new_name [String]
        # @return [String]
        def graphql_name: (?untyped? new_name) -> untyped

        def overridden_graphql_name: () -> untyped

        # Just a convenience method to point out that people should use graphql_name instead
        def name: (?untyped? new_name) -> untyped

        # Call this method to provide a new description; OR
        # call it without an argument to get the description
        # @param new_description [String]
        # @return [String]
        def description: (?untyped? new_description) -> untyped

        # This pushes some configurations _down_ the inheritance tree,
        # in order to prevent repetitive lookups at runtime.
        module ConfigurationExtension
          def inherited: (untyped child_class) -> untyped
        end

        # @return [Boolean] If true, this object is part of the introspection system
        def introspection: (?untyped? new_introspection) -> untyped

        def introspection?: () -> untyped

        # The mutation this type was derived from, if it was derived from a mutation
        # @return [Class]
        def mutation: (?untyped? mutation_class) -> untyped

        # alias unwrap itself

        # Creates the default name for a schema member.
        # The default name is the Ruby constant name,
        # without any namespaces and with any `-Type` suffix removed
        def default_graphql_name: () -> untyped

        def visible?: (untyped context) -> true

        def accessible?: (untyped context) -> true

        def authorized?: (untyped object, untyped context) -> true
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasPath
        # @return [String] A description of this member's place in the GraphQL schema
        def path: () -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasArguments
        def self.included: (untyped cls) -> untyped

        def self.extended: (untyped cls) -> untyped

        # @see {GraphQL::Schema::Argument#initialize} for parameters
        # @return [GraphQL::Schema::Argument] An instance of {argument_class}, created from `*args`
        def argument: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

        # Register this argument with the class.
        # @param arg_defn [GraphQL::Schema::Argument]
        # @return [GraphQL::Schema::Argument]
        def add_argument: (untyped arg_defn) -> untyped

        def remove_argument: (untyped arg_defn) -> nil

        # @return [Hash<String => GraphQL::Schema::Argument] Arguments defined on this thing, keyed by name. Includes inherited definitions
        def arguments: (?untyped context) -> untyped

        def all_argument_definitions: () -> untyped

        # @return [GraphQL::Schema::Argument, nil] Argument defined on this thing, fetched by name.
        def get_argument: (untyped argument_name, ?untyped context) -> untyped

        # @param new_arg_class [Class] A class to use for building argument definitions
        def argument_class: (?untyped? new_arg_class) -> untyped

        # @api private
        # If given a block, it will eventually yield the loaded args to the block.
        #
        # If no block is given, it will immediately dataload (but might return a Lazy).
        #
        # @param values [Hash<String, Object>]
        # @param context [GraphQL::Query::Context]
        # @yield [Interpreter::Arguments, Execution::Lazy<Interpeter::Arguments>]
        # @return [Interpreter::Arguments, Execution::Lazy<Interpeter::Arguments>]
        def coerce_arguments: (untyped parent_object, untyped values, untyped context) { () -> untyped } -> untyped

        # Usually, this is validated statically by RequiredArgumentsArePresent,
        # but not for directives.
        # TODO apply static validations on schema definitions?
        def validate_directive_argument: (untyped arg_defn, untyped value) -> untyped

        def arguments_statically_coercible?: () -> untyped

        module ArgumentClassAccessor
          def argument_class: (?untyped? new_arg_class) -> untyped
        end

        module ArgumentObjectLoader
          # Look up the corresponding object for a provided ID.
          # By default, it uses Relay-style {Schema.object_from_id},
          # override this to find objects another way.
          #
          # @param type [Class, Module] A GraphQL type definition
          # @param id [String] A client-provided to look up
          # @param context [GraphQL::Query::Context] the current context
          def object_from_id: (untyped `type`, untyped id, untyped context) -> untyped

          def load_application_object: (untyped argument, untyped id, untyped context) -> (nil | untyped)

          def load_and_authorize_application_object: (untyped argument, untyped id, untyped context) -> untyped

          def authorize_application_object: (untyped argument, untyped id, untyped context, untyped loaded_application_object) -> untyped

          def load_application_object_failed: (untyped err) -> untyped
        end

        NO_ARGUMENTS: ::Hash[untyped, untyped]

        def own_arguments: () -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      # These constants are interpreted as GraphQL types when defining fields or arguments
      #
      # @example
      #   field :is_draft, Boolean, null: false
      #   field :id, ID, null: false
      #   field :score, Int, null: false
      #
      # @api private
      module GraphQLTypeNames
        Boolean: "Boolean"

        ID: "ID"

        Int: "Int"
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasDirectives
        # Create an instance of `dir_class` for `self`, using `options`.
        #
        # It removes a previously-attached instance of `dir_class`, if there is one.
        #
        # @return [void]
        def directive: (untyped dir_class, **untyped options) -> nil

        # Remove an attached instance of `dir_class`, if there is one
        # @param dir_class [Class<GraphQL::Schema::Directive>]
        # @return [viod]
        def remove_directive: (untyped dir_class) -> nil

        NO_DIRECTIVES: ::Array[untyped]

        def directives: () -> untyped

        def own_directives: () -> untyped

        private

        # Modify `target` by adding items from `dirs` such that:
        # - Any name conflict is overriden by the incoming member of `dirs`
        # - Any other member of `dirs` is appended
        # @param target [Array<GraphQL::Schema::Directive>]
        # @param dirs [Array<GraphQL::Schema::Directive>]
        # @return [void]
        def merge_directives: (untyped target, untyped dirs) -> nil
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      # Shared code for Objects, Interfaces, Mutations, Subscriptions
      module HasFields
        # Add a field to this object or interface with the given definition
        # @see {GraphQL::Schema::Field#initialize} for method signature
        # @return [GraphQL::Schema::Field]
        def field: (*untyped args, **untyped kwargs) ?{ () -> untyped } -> untyped

        # @return [Hash<String => GraphQL::Schema::Field>] Fields on this object, keyed by name, including inherited fields
        def fields: (?untyped context) -> untyped

        def get_field: (untyped field_name, ?untyped context) -> (untyped | nil)

        # A list of Ruby keywords.
        #
        # @api private
        RUBY_KEYWORDS: ::Array[:class | :module | :def | :undef | :begin | :rescue | :ensure | :end | :if | :unless | :then | :elsif | :else | :case | :when | :while | :until | :for | :break | :next | :redo | :retry | :in | :do | :return | :yield | :super | :self | :nil | :true | :false | :and | :or | :not | :alias | :defined? | :BEGIN | :END | :__LINE__ | :__FILE__]

        # A list of GraphQL-Ruby keywords.
        #
        # @api private
        GRAPHQL_RUBY_KEYWORDS: ::Array[:context | :object | :raw_value]

        # A list of field names that we should advise users to pick a different
        # resolve method name.
        #
        # @api private
        CONFLICT_FIELD_NAMES: untyped

        # Register this field with the class, overriding a previous one if needed.
        # @param field_defn [GraphQL::Schema::Field]
        # @return [void]
        def add_field: (untyped field_defn, ?method_conflict_warning: untyped method_conflict_warning) -> nil

        # @return [Class] The class to initialize when adding fields to this kind of schema member
        def field_class: (?untyped? new_field_class) -> untyped

        def global_id_field: (untyped field_name, **untyped kwargs) -> untyped

        # @return [Hash<String => GraphQL::Schema::Field, Array<GraphQL::Schema::Field>>] Fields defined on this class _specifically_, not parent classes
        def own_fields: () -> untyped

        def all_field_definitions: () -> untyped

        private

        # If `type` is an interface, and `self` has a type membership for `type`, then make sure it's visible.
        def visible_interface_implementation?: (untyped `type`, untyped context, untyped warden) -> untyped

        # @param [GraphQL::Schema::Field]
        # @return [String] A warning to give when this field definition might conflict with a built-in method
        def conflict_field_name_warning: (untyped field_defn) -> ::String
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module Scoped
        # This is called when a field has `scope: true`.
        # The field's return type class receives this call.
        #
        # By default, it's a no-op. Override it to scope your objects.
        #
        # @param items [Object] Some list-like object (eg, Array, ActiveRecord::Relation)
        # @param context [GraphQL::Query::Context]
        # @return [Object] Another list-like object, scoped to the current context
        def scope_items: (untyped items, untyped context) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      # @api private
      module BuildType
        LIST_TYPE_ERROR: "Use an array of [T] or [T, null: true] for list types; other arrays are not supported"

        # @param type_expr [String, Class, GraphQL::BaseType]
        # @return [GraphQL::BaseType]
        def self?.parse_type: (untyped type_expr, null: untyped null) -> untyped

        def self?.to_type_name: (untyped something) -> untyped

        def self?.camelize: (untyped string) -> untyped

        # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
        def self?.constantize: (untyped string) -> untyped

        def self?.underscore: (untyped string) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasValidators
        include Schema::FindInheritedValue::EmptyObjects

        # Build {GraphQL::Schema::Validator}s based on the given configuration
        # and use them for this schema member
        # @param validation_config [Hash{Symbol => Hash}]
        # @return [void]
        def validates: (untyped validation_config) -> nil

        # @return [Array<GraphQL::Schema::Validator>]
        def validators: () -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module RelayShortcuts
        def edge_type_class: (?untyped? new_edge_type_class) -> untyped

        def connection_type_class: (?untyped? new_connection_type_class) -> untyped

        def edge_type: () -> untyped

        def connection_type: () -> untyped

        def configured_connection_type_class: () -> untyped

        def configured_edge_type_class: () -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module HasInterfaces
        def implements: (*untyped new_interfaces, **untyped options) -> untyped

        def own_interface_type_memberships: () -> untyped

        def interface_type_memberships: () -> untyped

        # param context [Query::Context] If omitted, skip filtering.
        def interfaces: (?untyped context) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      # Set up a type-specific error to make debugging & bug tracker integration better
      module HasUnresolvedTypeError
        private

        def add_unresolved_type_error: (untyped child_class) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Member
      module ValidatesInput
        def valid_input?: (untyped val, untyped ctx) -> untyped

        def validate_input: (untyped val, untyped ctx) -> untyped

        def valid_isolated_input?: (untyped v) -> untyped

        def coerce_isolated_input: (untyped v) -> untyped

        def coerce_isolated_result: (untyped v) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    # Extend this class to make field-level customizations to resolve behavior.
    #
    # When a extension is added to a field with `extension(MyExtension)`, a `MyExtension` instance
    # is created, and its hooks are applied whenever that field is called.
    #
    # The instance is frozen so that instance variables aren't modified during query execution,
    # which could cause all kinds of issues due to race conditions.
    class FieldExtension
      # @return [GraphQL::Schema::Field]
      attr_reader field: untyped

      # @return [Object]
      attr_reader options: untyped

      # @return [Array<Symbol>, nil] `default_argument`s added, if any were added (otherwise, `nil`)
      attr_reader added_default_arguments: untyped

      # Called when the extension is mounted with `extension(name, options)`.
      # The instance will be frozen to avoid improper use of state during execution.
      # @param field [GraphQL::Schema::Field] The field where this extension was mounted
      # @param options [Object] The second argument to `extension`, or `{}` if nothing was passed.
      def initialize: (field: untyped field, options: untyped options) -> void

      # @return [Array(Array, Hash), nil] A list of default argument configs, or `nil` if there aren't any
      def self.default_argument_configurations: () -> untyped

      # @see Argument#initialize
      # @see HasArguments#argument
      def self.default_argument: (*untyped argument_args, **untyped argument_kwargs) -> untyped

      # If configured, these `extras` will be added to the field if they aren't already present,
      # but removed by from `arguments` before the field's `resolve` is called.
      # (The extras _will_ be present for other extensions, though.)
      #
      # @param new_extras [Array<Symbol>] If provided, assign extras used by this extension
      # @return [Array<Symbol>] any extras assigned to this extension
      def self.extras: (?untyped? new_extras) -> untyped

      NO_EXTRAS: ::Array[untyped]

      # Called when this extension is attached to a field.
      # The field definition may be extended during this method.
      # @return [void]
      def apply: () -> nil

      # Called after the field's definition block has been executed.
      # (Any arguments from the block are present on `field`)
      # @return [void]
      def after_define: () -> nil

      # @api private
      def after_define_apply: () -> untyped

      # @api private
      attr_reader added_extras: untyped

      # Called before resolving {#field}. It should either:
      #
      # - `yield` values to continue execution; OR
      # - return something else to shortcut field execution.
      #
      # Whatever this method returns will be used for execution.
      #
      # @param object [Object] The object the field is being resolved on
      # @param arguments [Hash] Ruby keyword arguments for resolving this field
      # @param context [Query::Context] the context for this query
      # @yieldparam object [Object] The object to continue resolving the field on
      # @yieldparam arguments [Hash] The keyword arguments to continue resolving with
      # @yieldparam memo [Object] Any extension-specific value which will be passed to {#after_resolve} later
      # @return [Object] The return value for this field.
      def resolve: (object: untyped object, arguments: untyped arguments, context: untyped context) { (untyped, untyped, untyped) -> untyped } -> untyped

      # Called after {#field} was resolved, and after any lazy values (like `Promise`s) were synced,
      # but before the value was added to the GraphQL response.
      #
      # Whatever this hook returns will be used as the return value.
      #
      # @param object [Object] The object the field is being resolved on
      # @param arguments [Hash] Ruby keyword arguments for resolving this field
      # @param context [Query::Context] the context for this query
      # @param value [Object] Whatever the field previously returned
      # @param memo [Object] The third value yielded by {#resolve}, or `nil` if there wasn't one
      # @return [Object] The return value for this field.
      def after_resolve: (object: untyped object, arguments: untyped arguments, context: untyped context, value: untyped value, memo: untyped memo) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Field
      class ConnectionExtension < GraphQL::Schema::FieldExtension
        def apply: () -> untyped

        # Remove pagination args before passing it to a user method
        def resolve: (object: untyped object, arguments: untyped arguments, context: untyped context) { (untyped, untyped, untyped) -> untyped } -> untyped

        def after_resolve: (value: untyped value, object: untyped object, arguments: untyped arguments, context: untyped context, memo: untyped memo) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Field
      class ScopeExtension < GraphQL::Schema::FieldExtension
        def after_resolve: (object: untyped object, arguments: untyped arguments, context: untyped context, value: untyped value, memo: untyped memo) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    # A stand-in for a type which will be resolved in a given schema, by name.
    # TODO: support argument types too, make this a public API somehow
    # @api Private
    class LateBoundType
      attr_reader name: untyped

      alias graphql_name name

      def initialize: (untyped local_name) -> void

      def unwrap: () -> untyped

      def to_non_null_type: () -> untyped

      def to_list_type: () -> untyped

      def inspect: () -> ::String

      alias to_s inspect
    end
  end
end

module GraphQL
  class Schema
    # This plugin will stop resolving new fields after `max_seconds` have elapsed.
    # After the time has passed, any remaining fields will be `nil`, with errors added
    # to the `errors` key. Any already-resolved fields will be in the `data` key, so
    # you'll get a partial response.
    #
    # You can subclass `GraphQL::Schema::Timeout` and override `max_seconds` and/or `handle_timeout`
    # to provide custom logic when a timeout error occurs.
    #
    # Note that this will stop a query _in between_ field resolutions, but
    # it doesn't interrupt long-running `resolve` functions. Be sure to use
    # timeout options for external connections. For more info, see
    # www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/
    #
    # @example Stop resolving fields after 2 seconds
    #   class MySchema < GraphQL::Schema
    #     use GraphQL::Schema::Timeout, max_seconds: 2
    #   end
    #
    # @example Notifying Bugsnag and logging a timeout
    #   class MyTimeout < GraphQL::Schema::Timeout
    #     def handle_timeout(error, query)
    #        Rails.logger.warn("GraphQL Timeout: #{error.message}: #{query.query_string}")
    #        Bugsnag.notify(error, {query_string: query.query_string})
    #     end
    #   end
    #
    #   class MySchema < GraphQL::Schema
    #     use MyTimeout, max_seconds: 2
    #   end
    #
    class Timeout
      def self.use: (untyped schema, **untyped options) -> untyped

      # @param max_seconds [Numeric] how many seconds the query should be allowed to resolve new fields
      def initialize: (max_seconds: untyped max_seconds) -> void

      def trace: (untyped key, untyped data) { () -> untyped } -> untyped

      # Called at the start of each query.
      # The default implementation returns the `max_seconds:` value from installing this plugin.
      #
      # @param query [GraphQL::Query] The query that's about to run
      # @return [Integer, false] The number of seconds after which to interrupt query execution and call {#handle_error}, or `false` to bypass the timeout.
      def max_seconds: (untyped query) -> untyped

      # Invoked when a query times out.
      # @param error [GraphQL::Schema::Timeout::TimeoutError]
      # @param query [GraphQL::Error]
      def handle_timeout: (untyped error, untyped query) -> nil

      # This error is raised when a query exceeds `max_seconds`.
      # Since it's a child of {GraphQL::ExecutionError},
      # its message will be added to the response's `errors` key.
      #
      # To raise an error that will stop query resolution, use a custom block
      # to take this error and raise a new one which _doesn't_ descend from {GraphQL::ExecutionError},
      # such as `RuntimeError`.
      class TimeoutError < GraphQL::ExecutionError
        def initialize: (untyped parent_type, untyped field) -> void
      end
    end
  end
end

module GraphQL
  class Schema
    # The base class for things that make up the schema,
    # eg objects, enums, scalars.
    #
    # @api private
    class Member
      include GraphQLTypeNames

      extend BaseDSLMethods

      extend BaseDSLMethods::ConfigurationExtension

      extend TypeSystemHelpers

      extend Scoped

      extend RelayShortcuts

      extend HasPath

      extend HasAstNode

      extend HasDirectives
    end
  end
end

module GraphQL
  class Schema
    # Mutations that extend this base class get some conventions added for free:
    #
    # - An argument called `clientMutationId` is _always_ added, but it's not passed
    #   to the resolve method. The value is re-inserted to the response. (It's for
    #   client libraries to manage optimistic updates.)
    # - The returned object type always has a field called `clientMutationId` to support that.
    # - The mutation accepts one argument called `input`, `argument`s defined in the mutation
    #   class are added to that input object, which is generated by the mutation.
    #
    # These conventions were first specified by Relay Classic, but they come in handy:
    #
    # - `clientMutationId` supports optimistic updates and cache rollbacks on the client
    # - using a single `input:` argument makes it easy to post whole JSON objects to the mutation
    #   using one GraphQL variable (`$input`) instead of making a separate variable for each argument.
    #
    # @see {GraphQL::Schema::Mutation} for an example, it's basically the same.
    #
    class RelayClassicMutation < GraphQL::Schema::Mutation
      # Override {GraphQL::Schema::Resolver#resolve_with_support} to
      # delete `client_mutation_id` from the kwargs.
      def resolve_with_support: (**untyped inputs) -> untyped

      def self.dummy: () -> untyped

      def self.field_arguments: (?untyped context) -> untyped

      def self.get_field_argument: (untyped name, ?untyped context) -> untyped

      def self.own_field_arguments: () -> untyped

      def self.all_field_argument_definitions: () -> untyped

      # Also apply this argument to the input type:
      def self.argument: (*untyped args, ?own_argument: bool own_argument, **untyped kwargs) { () -> untyped } -> untyped

      # The base class for generated input object types
      # @param new_class [Class] The base class to use for generating input object definitions
      # @return [Class] The base class for this mutation's generated input object (default is {GraphQL::Schema::InputObject})
      def self.input_object_class: (?untyped? new_class) -> untyped

      # @param new_input_type [Class, nil] If provided, it configures this mutation to accept `new_input_type` instead of generating an input type
      # @return [Class] The generated {Schema::InputObject} class for this mutation's `input`
      def self.input_type: (?untyped? new_input_type) -> untyped

      private

      # Generate the input type for the `input:` argument
      # To customize how input objects are generated, override this method
      # @return [Class] a subclass of {.input_object_class}
      def self.generate_input_type: () -> untyped

      def authorize_arguments: (untyped args, untyped values) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Directive < GraphQL::Schema::Member
      # This is _similar_ to {Directive::Feature}, except it's prescribed by the server, not the client.
      #
      # In this case, the server hides types and fields _entirely_, unless the current context has certain `:flags` present.
      class Flagged < GraphQL::Schema::Directive
        def initialize: (untyped target, **untyped options) -> void

        module VisibleByFlag
          def self.included: (untyped schema_class) -> untyped

          def visible?: (untyped context) -> untyped
        end
      end
    end
  end
end

module GraphQL
  class Schema
    class Directive < GraphQL::Schema::Member
      # An example directive to show how you might interact with the runtime.
      #
      # This directive takes the return value of the tagged part of the query,
      # and if the named transform is whitelisted and applies to the return value,
      # it's applied by calling a method with that name.
      #
      # @example Installing the directive
      #   class MySchema < GraphQL::Schema
      #     directive(GraphQL::Schema::Directive::Transform)
      #   end
      #
      # @example Transforming strings
      #   viewer {
      #     username @transform(by: "upcase")
      #   }
      class Transform < Schema::Directive
        TRANSFORMS: ::Array["upcase" | "downcase"]

        # Implement the Directive API
        def self.resolve: (untyped object, untyped arguments, untyped context) { () -> untyped } -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Directive < GraphQL::Schema::Member
      class Include < GraphQL::Schema::Directive
        def self.static_include?: (untyped args, untyped ctx) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Directive < GraphQL::Schema::Member
      # An example directive to show how you might interact with the runtime.
      #
      # This directive might be used along with a server-side feature flag system like Flipper.
      #
      # With that system, you could use this directive to exclude parts of a query
      # if the current viewer doesn't have certain flags enabled.
      # (So, this flag would be for internal clients, like your iOS app, not third-party API clients.)
      #
      # To use it, you have to implement `.enabled?`, for example:
      #
      # @example Implementing the Feature directive
      #   # app/graphql/directives/feature.rb
      #   class Directives::Feature < GraphQL::Schema::Directive::Feature
      #     def self.enabled?(flag_name, _obj, context)
      #       # Translate some GraphQL data for Ruby:
      #       flag_key = flag_name.underscore
      #       current_user = context[:viewer]
      #       # Check the feature flag however your app does it:
      #       MyFeatureFlags.enabled?(current_user, flag_key)
      #     end
      #   end
      #
      # @example Flagging a part of the query
      #   viewer {
      #     # This field only runs if `.enabled?("recommendationEngine", obj, context)`
      #     # returns true. Otherwise, it's treated as if it didn't exist.
      #     recommendations @feature(flag: "recommendationEngine") {
      #       name
      #       rating
      #     }
      #   }
      class Feature < Schema::Directive
        # Implement the Directive API
        def self.include?: (untyped object, untyped arguments, untyped context) -> untyped

        # Override this method in your app's subclass of this directive.
        #
        # @param flag_name [String] The client-provided string of a feature to check
        # @param object [GraphQL::Schema::Objct] The currently-evaluated GraphQL object instance
        # @param context [GraphQL::Query::Context]
        # @return [Boolean] If truthy, execution will continue
        def self.enabled?: (untyped flag_name, untyped object, untyped context) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Directive < GraphQL::Schema::Member
      class Deprecated < GraphQL::Schema::Directive
      end
    end
  end
end

module GraphQL
  class Schema
    class Directive < GraphQL::Schema::Member
      class Skip < Schema::Directive
        def self.static_include?: (untyped args, untyped ctx) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    class Addition
      attr_reader directives: untyped

      attr_reader possible_types: untyped

      attr_reader types: untyped

      attr_reader union_memberships: untyped

      attr_reader references: untyped

      attr_reader arguments_with_default_values: untyped

      def initialize: (schema: untyped schema, own_types: untyped own_types, new_types: untyped new_types) -> void

      private

      def references_to: (untyped thing, from: untyped from) -> untyped

      def get_type: (untyped name) -> untyped

      # Lookup using `own_types` here because it's ok to override
      # inherited types by name
      def get_local_type: (untyped name) -> untyped

      def add_directives_from: (untyped owner) -> untyped

      def add_type_and_traverse: (untyped new_types) -> nil

      def update_type_owner: (untyped owner, untyped `type`) -> untyped

      def add_type: (untyped `type`, owner: untyped owner, late_types: untyped late_types, path: untyped path) -> (nil | untyped)
    end
  end
end

module GraphQL
  class Schema
    # This base class accepts configuration for a mutation root field,
    # then it can be hooked up to your mutation root object type.
    #
    # If you want to customize how this class generates types, in your base class,
    # override the various `generate_*` methods.
    #
    # @see {GraphQL::Schema::RelayClassicMutation} for an extension of this class with some conventions built-in.
    #
    # @example Creating a comment
    #  # Define the mutation:
    #  class Mutations::CreateComment < GraphQL::Schema::Mutation
    #    argument :body, String, required: true
    #    argument :post_id, ID, required: true
    #
    #    field :comment, Types::Comment, null: true
    #    field :errors, [String], null: false
    #
    #    def resolve(body:, post_id:)
    #      post = Post.find(post_id)
    #      comment = post.comments.build(body: body, author: context[:current_user])
    #      if comment.save
    #        # Successful creation, return the created object with no errors
    #        {
    #          comment: comment,
    #          errors: [],
    #        }
    #      else
    #        # Failed save, return the errors to the client
    #        {
    #          comment: nil,
    #          errors: comment.errors.full_messages
    #        }
    #      end
    #    end
    #  end
    #
    #  # Hook it up to your mutation:
    #  class Types::Mutation < GraphQL::Schema::Object
    #    field :create_comment, mutation: Mutations::CreateComment
    #  end
    #
    #  # Call it from GraphQL:
    #  result = MySchema.execute <<-GRAPHQL
    #  mutation {
    #    createComment(postId: "1", body: "Nice Post!") {
    #      errors
    #      comment {
    #        body
    #        author {
    #          login
    #        }
    #      }
    #    }
    #  }
    #  GRAPHQL
    #
    class Mutation < GraphQL::Schema::Resolver
      extend GraphQL::Schema::Member::HasFields

      extend GraphQL::Schema::Resolver::HasPayloadType

      def self.visible?: (untyped context) -> true

      private

      def self.conflict_field_name_warning: (untyped field_defn) -> ::String

      # Override this to attach self as `mutation`
      def self.generate_payload_type: () -> untyped
    end
  end
end

module GraphQL
  class Schema
    module Interface
      include GraphQL::Schema::Member::GraphQLTypeNames

      module DefinitionMethods
        include GraphQL::Schema::Member::BaseDSLMethods

        # ConfigurationExtension's responsibilities are in `def included` below
        include GraphQL::Schema::Member::TypeSystemHelpers

        include GraphQL::Schema::Member::HasFields

        include GraphQL::Schema::Member::HasPath

        include GraphQL::Schema::Member::RelayShortcuts

        include GraphQL::Schema::Member::Scoped

        include GraphQL::Schema::Member::HasAstNode

        include GraphQL::Schema::Member::HasUnresolvedTypeError

        include GraphQL::Schema::Member::HasDirectives

        include GraphQL::Schema::Member::HasInterfaces

        # Methods defined in this block will be:
        # - Added as class methods to this interface
        # - Added as class methods to all child interfaces
        def definition_methods: () { () -> untyped } -> untyped

        # @see {Schema::Warden} hides interfaces without visible implementations
        def visible?: (untyped context) -> true

        # The interface is accessible if any of its possible types are accessible
        def accessible?: (untyped context) -> (true | false)

        def type_membership_class: (?untyped? membership_class) -> untyped

        # Here's the tricky part. Make sure behavior keeps making its way down the inheritance chain.
        def included: (untyped child_class) -> untyped

        def orphan_types: (*untyped types) -> untyped

        def kind: () -> untyped
      end

      extend DefinitionMethods

      def unwrap: () -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Scalar < GraphQL::Schema::Member
      extend GraphQL::Schema::Member::ValidatesInput

      def self.coerce_input: (untyped val, untyped ctx) -> untyped

      def self.coerce_result: (untyped val, untyped ctx) -> untyped

      def self.kind: () -> untyped

      def self.specified_by_url: (?untyped? new_url) -> untyped

      def self.default_scalar: (?untyped? is_default) -> untyped

      def self.default_scalar?: () -> untyped

      def self.validate_non_null_input: (untyped value, untyped ctx) -> untyped
    end
  end
end

module GraphQL
  class Schema
    # This class joins an object type to an abstract type (interface or union) of which
    # it is a member.
    class TypeMembership
      # @return [Class<GraphQL::Schema::Object>]
      attr_accessor object_type: untyped

      # @return [Class<GraphQL::Schema::Union>, Module<GraphQL::Schema::Interface>]
      attr_reader abstract_type: untyped

      # Called when an object is hooked up to an abstract type, such as {Schema::Union.possible_types}
      # or {Schema::Object.implements} (for interfaces).
      #
      # @param abstract_type [Class<GraphQL::Schema::Union>, Module<GraphQL::Schema::Interface>]
      # @param object_type [Class<GraphQL::Schema::Object>]
      # @param options [Hash] Any options passed to `.possible_types` or `.implements`
      def initialize: (untyped abstract_type, untyped object_type, **untyped options) -> void

      # @return [Boolean] if false, {#object_type} will be treated as _not_ a member of {#abstract_type}
      def visible?: (untyped ctx) -> untyped

      def graphql_name: () -> ::String

      def path: () -> untyped

      def inspect: () -> ::String

      alias type_class itself
    end
  end
end

module GraphQL
  class Schema
    # @api private
    module TypeExpression
      # Fetch a type from a type map by its AST specification.
      # Return `nil` if not found.
      # @param type_owner [#get_type] A thing for looking up types by name
      # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
      # @return [Class, GraphQL::Schema::NonNull, GraphQL::Schema:List]
      def self.build_type: (untyped type_owner, untyped ast_node) -> untyped

      private

      def self.wrap_type: (untyped `type`, untyped wrapper_method) -> untyped
    end
  end
end

module GraphQL
  class Schema
    # Represents a list type in the schema.
    # Wraps a {Schema::Member} as a list type.
    # @see {Schema::Member::TypeSystemHelpers#to_list_type}
    class List < GraphQL::Schema::Wrapper
      include Schema::Member::ValidatesInput

      # @return [GraphQL::TypeKinds::LIST]
      def kind: () -> untyped

      # @return [true]
      def list?: () -> true

      def to_type_signature: () -> ::String

      # This is for introspection, where it's expected the name will be `null`
      def graphql_name: () -> nil

      # Also for implementing introspection
      def description: () -> nil

      def coerce_result: (untyped value, untyped ctx) -> untyped

      def coerce_input: (untyped value, untyped ctx) -> untyped

      def validate_non_null_input: (untyped value, untyped ctx) -> untyped

      private

      def ensure_array: (untyped value) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class InvalidTypeError < GraphQL::Error
    end
  end
end

module GraphQL
  class Schema
    class Object < GraphQL::Schema::Member
      extend GraphQL::Schema::Member::HasFields

      extend GraphQL::Schema::Member::HasInterfaces

      # @return [Object] the application object this type is wrapping
      attr_reader object: untyped

      # @return [GraphQL::Query::Context] the context instance for this query
      attr_reader context: untyped

      # @return [GraphQL::Dataloader]
      def dataloader: () -> untyped

      # Call this in a field method to return a value that should be returned to the client
      # without any further handling by GraphQL.
      def raw_value: (untyped obj) -> untyped

      # Make a new instance of this type _if_ the auth check passes,
      # otherwise, raise an error.
      #
      # Probably only the framework should call this method.
      #
      # This might return a {GraphQL::Execution::Lazy} if the user-provided `.authorized?`
      # hook returns some lazy value (like a Promise).
      #
      # The reason that the auth check is in this wrapper method instead of {.new} is because
      # of how it might return a Promise. It would be weird if `.new` returned a promise;
      # It would be a headache to try to maintain Promise-y state inside a {Schema::Object}
      # instance. So, hopefully this wrapper method will do the job.
      #
      # @param object [Object] The thing wrapped by this object
      # @param context [GraphQL::Query::Context]
      # @return [GraphQL::Schema::Object, GraphQL::Execution::Lazy]
      # @raise [GraphQL::UnauthorizedError] if the user-provided hook returns `false`
      def self.authorized_new: (untyped object, untyped context) -> untyped

      def initialize: (untyped object, untyped context) -> void

      # Set up a type-specific invalid null error to use when this object's non-null fields wrongly return `nil`.
      # It should help with debugging and bug tracker integrations.
      def self.const_missing: (untyped name) -> untyped

      def self.kind: () -> untyped
    end
  end
end

module GraphQL
  class Schema
    BUILT_IN_TYPES: ::Hash[::String, untyped]
  end
end

module GraphQL
  class Schema
    class InputObject < GraphQL::Schema::Member
      # extend Forwardable

      extend GraphQL::Schema::Member::HasArguments

      extend GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader

      extend GraphQL::Schema::Member::ValidatesInput

      extend GraphQL::Schema::Member::HasValidators

      include GraphQL::Dig

      # @return [GraphQL::Query::Context] The context for this query
      attr_reader context: untyped

      # @return [GraphQL::Execution::Interpereter::Arguments] The underlying arguments instance
      attr_reader arguments: untyped

      def initialize: (untyped arguments, ruby_kwargs: untyped ruby_kwargs, context: untyped context, defaults_used: untyped defaults_used) -> void

      def to_h: () -> untyped

      def to_hash: () -> untyped

      def prepare: () -> untyped

      def self.authorized?: (untyped obj, untyped value, untyped ctx) -> (false | true)

      def unwrap_value: (untyped value) -> untyped

      # Lookup a key on this object, it accepts new-style underscored symbols
      # Or old-style camelized identifiers.
      # @param key [Symbol, String]
      def []: (untyped key) -> untyped

      def key?: (untyped key) -> untyped

      # A copy of the Ruby-style hash
      def to_kwargs: () -> untyped

      def self.argument: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

      def self.kind: () -> untyped

      # @api private
      INVALID_OBJECT_MESSAGE: "Expected %{object} to be a key-value object responding to `to_h` or `to_unsafe_h`."

      def self.validate_non_null_input: (untyped input, untyped ctx) -> untyped

      def self.coerce_input: (untyped value, untyped ctx) -> (nil | untyped)

      # It's funny to think of a _result_ of an input object.
      # This is used for rendering the default value in introspection responses.
      def self.coerce_result: (untyped value, untyped ctx) -> untyped

      private

      def overwrite_argument: (untyped key, untyped value) -> untyped
    end
  end
end

module GraphQL
  class Schema
    # This class can be extended to create fields on your subscription root.
    #
    # It provides hooks for the different parts of the subscription lifecycle:
    #
    # - `#authorized?`: called before initial subscription and subsequent updates
    # - `#subscribe`: called for the initial subscription
    # - `#update`: called for subsequent update
    #
    # Also, `#unsubscribe` terminates the subscription.
    class Subscription < GraphQL::Schema::Resolver
      extend GraphQL::Schema::Resolver::HasPayloadType

      extend GraphQL::Schema::Member::HasFields

      NO_UPDATE: :no_update

      def initialize: (object: untyped object, context: untyped context, field: untyped field) -> void

      def resolve_with_support: (**untyped args) -> untyped

      # Implement the {Resolve} API
      def resolve: (**untyped args) -> untyped

      # Wrap the user-defined `#subscribe` hook
      def resolve_subscribe: (**untyped args) -> untyped

      # The default implementation returns nothing on subscribe.
      # Override it to return an object or
      # `:no_response` to (explicitly) return nothing.
      def subscribe: (?::Hash[untyped, untyped] args) -> :no_response

      # Wrap the user-provided `#update` hook
      def resolve_update: (**untyped args) -> untyped

      # The default implementation returns the root object.
      # Override it to return {NO_UPDATE} if you want to
      # skip updates sometimes. Or override it to return a different object.
      def update: (?::Hash[untyped, untyped] args) -> untyped

      # If an argument is flagged with `loads:` and no object is found for it,
      # remove this subscription (assuming that the object was deleted in the meantime,
      # or that it became inaccessible).
      def load_application_object_failed: (untyped err) -> untyped

      # Call this to halt execution and remove this subscription from the system
      def unsubscribe: () -> untyped

      READING_SCOPE: untyped

      # Call this method to provide a new subscription_scope; OR
      # call it without an argument to get the subscription_scope
      # @param new_scope [Symbol]
      # @param optional [Boolean] If true, then don't require `scope:` to be provided to updates to this subscription.
      # @return [Symbol]
      def self.subscription_scope: (?untyped new_scope, ?optional: bool optional) -> untyped

      def self.subscription_scope_optional?: () -> untyped

      # This is called during initial subscription to get a "name" for this subscription.
      # Later, when `.trigger` is called, this will be called again to build another "name".
      # Any subscribers with matching topic will begin the update flow.
      #
      # The default implementation creates a string using the field name, subscription scope, and argument keys and values.
      # In that implementation, only `.trigger` calls with _exact matches_ result in updates to subscribers.
      #
      # To implement a filtered stream-type subscription flow, override this method to return a string with field name and subscription scope.
      # Then, implement {#update} to compare its arguments to the current `object` and return {NO_UPDATE} when an
      # update should be filtered out.
      #
      # @see {#update} for how to skip updates when an event comes with a matching topic.
      # @param arguments [Hash<String => Object>] The arguments for this topic, in GraphQL-style (camelized strings)
      # @param field [GraphQL::Schema::Field]
      # @param scope [Object, nil] A value corresponding to `.trigger(... scope:)` (for updates) or the `subscription_scope` found in `context` (for initial subscriptions).
      # @return [String] An identifier corresponding to a stream of updates
      def self.topic_for: (arguments: untyped arguments, field: untyped field, scope: untyped scope) -> untyped
    end
  end
end

module GraphQL
  class Schema
    module UniqueWithinType
      attr_accessor self.default_id_separator: untyped

      # @param type_name [String]
      # @param object_value [Any]
      # @return [String] a unique, opaque ID generated as a function of the two inputs
      def self?.encode: (untyped type_name, untyped object_value, ?separator: untyped separator) -> untyped

      # @param node_id [String] A unique ID generated by {.encode}
      # @return [Array<(String, String)>] The type name & value passed to {.encode}
      def self?.decode: (untyped node_id, ?separator: untyped separator) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Argument
      include GraphQL::Schema::Member::HasPath

      include GraphQL::Schema::Member::HasAstNode

      include GraphQL::Schema::Member::HasDirectives

      include GraphQL::Schema::Member::HasDeprecationReason

      include GraphQL::Schema::Member::HasValidators

      include GraphQL::Schema::FindInheritedValue::EmptyObjects

      NO_DEFAULT: :__no_default__

      # @return [String] the GraphQL name for this argument, camelized unless `camelize: false` is provided
      attr_reader name: untyped

      alias graphql_name name

      # @return [GraphQL::Schema::Field, Class] The field or input object this argument belongs to
      attr_reader owner: untyped

      # @return [Symbol] A method to call to transform this value before sending it to field resolution method
      attr_reader prepare: untyped

      # @return [Symbol] This argument's name in Ruby keyword arguments
      attr_reader keyword: untyped

      # @return [Class, Module, nil] If this argument should load an application object, this is the type of object to load
      attr_reader loads: untyped

      # @return [Boolean] true if a resolver defined this argument
      def from_resolver?: () -> untyped

      # @param arg_name [Symbol]
      # @param type_expr
      # @param desc [String]
      # @param required [Boolean, :nullable] if true, this argument is non-null; if false, this argument is nullable. If `:nullable`, then the argument must be provided, though it may be `null`.
      # @param description [String]
      # @param default_value [Object]
      # @param as [Symbol] Override the keyword name when passed to a method
      # @param prepare [Symbol] A method to call to transform this argument's valuebefore sending it to field resolution
      # @param camelize [Boolean] if true, the name will be camelized when building the schema
      # @param from_resolver [Boolean] if true, a Resolver class defined this argument
      # @param directives [Hash{Class => Hash}]
      # @param deprecation_reason [String]
      # @param validates [Hash, nil] Options for building validators, if any should be applied
      # @param replace_null_with_default [Boolean] if `true`, incoming values of `null` will be replaced with the configured `default_value`
      def initialize: (?untyped? arg_name, ?untyped? type_expr, ?untyped? desc, owner: untyped owner, ?required: bool required, ?type: untyped? `type`, ?name: untyped? name, ?loads: untyped? loads, ?description: untyped? description, ?ast_node: untyped? ast_node, ?default_value: untyped default_value, ?as: untyped? as, ?from_resolver: bool from_resolver, ?camelize: bool camelize, ?prepare: untyped? prepare, ?validates: untyped? validates, ?directives: untyped? directives, ?deprecation_reason: untyped? deprecation_reason, ?replace_null_with_default: bool replace_null_with_default) { () -> untyped } -> void

      def inspect: () -> ::String

      # @return [Object] the value used when the client doesn't provide a value for this argument
      attr_reader default_value: untyped

      # @return [Boolean] True if this argument has a default value
      def default_value?: () -> untyped

      def replace_null_with_default?: () -> untyped

      attr_writer description: untyped

      # @return [String] Documentation for this argument
      def description: (?untyped? text) -> untyped

      # @return [String] Deprecation reason for this argument
      def deprecation_reason: (?untyped? text) -> untyped

      def deprecation_reason=: (untyped new_reason) -> untyped

      def visible?: (untyped context) -> true

      def accessible?: (untyped context) -> true

      def authorized?: (untyped obj, untyped value, untyped ctx) -> untyped

      def authorized_as_type?: (untyped obj, untyped value, untyped ctx, as_type: untyped as_type) -> (true | false | untyped)

      def type=: (untyped new_type) -> untyped

      def type: () -> untyped

      def statically_coercible?: () -> untyped

      # Apply the {prepare} configuration to `value`, using methods from `obj`.
      # Used by the runtime.
      # @api private
      def prepare_value: (untyped obj, untyped value, ?context: untyped? context) -> untyped

      # @api private
      def coerce_into_values: (untyped parent_object, untyped values, untyped context, untyped argument_values) -> (nil | untyped)

      def load_and_authorize_value: (untyped load_method_owner, untyped coerced_value, untyped context) -> (nil | untyped)

      # @api private
      def validate_default_value: () -> untyped

      class InvalidDefaultValueError < GraphQL::Error
        def initialize: (untyped argument) -> void
      end

      private

      def validate_input_type: (untyped input_type) -> untyped

      def validate_deprecated_or_optional: (null: untyped null, deprecation_reason: untyped deprecation_reason) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Field
      include GraphQL::Schema::Member::HasArguments

      include GraphQL::Schema::Member::HasAstNode

      include GraphQL::Schema::Member::HasPath

      include GraphQL::Schema::Member::HasValidators

      extend GraphQL::Schema::FindInheritedValue

      include GraphQL::Schema::FindInheritedValue::EmptyObjects

      include GraphQL::Schema::Member::HasDirectives

      include GraphQL::Schema::Member::HasDeprecationReason

      class FieldImplementationFailed < GraphQL::Error
      end

      # @return [String] the GraphQL name for this field, camelized unless `camelize: false` is provided
      attr_reader name: untyped

      alias graphql_name name

      attr_writer description: untyped

      # @return [Symbol] Method or hash key on the underlying object to look up
      attr_reader method_sym: untyped

      # @return [String] Method or hash key on the underlying object to look up
      attr_reader method_str: untyped

      attr_reader hash_key: untyped

      attr_reader dig_keys: untyped

      # @return [Symbol] The method on the type to look up
      def resolver_method: () -> untyped

      # @return [Class] The thing this field was defined on (type, mutation, resolver)
      attr_accessor owner: untyped

      # @return [Class] The GraphQL type this field belongs to. (For fields defined on mutations, it's the payload type)
      def owner_type: () -> untyped

      # @return [Symbol] the original name of the field, passed in by the user
      attr_reader original_name: untyped

      # @return [Class, nil] The {Schema::Resolver} this field was derived from, if there is one
      def resolver: () -> untyped

      # @return [Boolean] Is this field a predefined introspection field?
      def introspection?: () -> untyped

      def inspect: () -> ::String

      alias mutation resolver

      # @return [Boolean] Apply tracing to this field? (Default: skip scalars, this is the override value)
      attr_reader trace: untyped

      # @return [String, nil]
      def subscription_scope: () -> untyped

      attr_writer subscription_scope: untyped

      # Create a field instance from a list of arguments, keyword arguments, and a block.
      #
      # This method implements prioritization between the `resolver` or `mutation` defaults
      # and the local overrides via other keywords.
      #
      # It also normalizes positional arguments into keywords for {Schema::Field#initialize}.
      # @param resolver [Class] A {GraphQL::Schema::Resolver} class to use for field configuration
      # @param mutation [Class] A {GraphQL::Schema::Mutation} class to use for field configuration
      # @param subscription [Class] A {GraphQL::Schema::Subscription} class to use for field configuration
      # @return [GraphQL::Schema:Field] an instance of `self
      # @see {.initialize} for other options
      def self.from_options: (?untyped? name, ?untyped? `type`, ?untyped? desc, ?resolver: untyped? resolver, ?mutation: untyped? mutation, ?subscription: untyped? subscription, **untyped kwargs) { () -> untyped } -> untyped

      # Can be set with `connection: true|false` or inferred from a type name ending in `*Connection`
      # @return [Boolean] if true, this field will be wrapped with Relay connection behavior
      def connection?: () -> untyped

      # @return [Boolean] if true, the return type's `.scope_items` method will be applied to this field's return value
      def scoped?: () -> untyped

      # This extension is applied to fields when {#connection?} is true.
      #
      # You can override it in your base field definition.
      # @return [Class] A {FieldExtension} subclass for implementing pagination behavior.
      # @example Configuring a custom extension
      #   class Types::BaseField < GraphQL::Schema::Field
      #     connection_extension(MyCustomExtension)
      #   end
      def self.connection_extension: (?untyped? new_extension_class) -> untyped

      # @return Boolean
      attr_reader relay_node_field: untyped

      # @return [Boolean] Should we warn if this field's name conflicts with a built-in method?
      def method_conflict_warning?: () -> untyped

      # @param name [Symbol] The underscore-cased version of this field name (will be camelized for the GraphQL API)
      # @param type [Class, GraphQL::BaseType, Array] The return type of this field
      # @param owner [Class] The type that this field belongs to
      # @param null [Boolean] (defaults to `true`) `true` if this field may return `null`, `false` if it is never `null`
      # @param description [String] Field description
      # @param deprecation_reason [String] If present, the field is marked "deprecated" with this message
      # @param method [Symbol] The method to call on the underlying object to resolve this field (defaults to `name`)
      # @param hash_key [String, Symbol] The hash key to lookup on the underlying object (if its a Hash) to resolve this field (defaults to `name` or `name.to_s`)
      # @param dig [Array<String, Symbol>] The nested hash keys to lookup on the underlying hash to resolve this field using dig
      # @param resolver_method [Symbol] The method on the type to call to resolve this field (defaults to `name`)
      # @param connection [Boolean] `true` if this field should get automagic connection behavior; default is to infer by `*Connection` in the return type name
      # @param connection_extension [Class] The extension to add, to implement connections. If `nil`, no extension is added.
      # @param max_page_size [Integer, nil] For connections, the maximum number of items to return from this field, or `nil` to allow unlimited results.
      # @param introspection [Boolean] If true, this field will be marked as `#introspection?` and the name may begin with `__`
      # @param resolver_class [Class] (Private) A {Schema::Resolver} which this field was derived from. Use `resolver:` to create a field with a resolver.
      # @param arguments [{String=>GraphQL::Schema::Argument, Hash}] Arguments for this field (may be added in the block, also)
      # @param camelize [Boolean] If true, the field name will be camelized when building the schema
      # @param complexity [Numeric] When provided, set the complexity for this field
      # @param scope [Boolean] If true, the return type's `.scope_items` method will be called on the return value
      # @param subscription_scope [Symbol, String] A key in `context` which will be used to scope subscription payloads
      # @param extensions [Array<Class, Hash<Class => Object>>] Named extensions to apply to this field (see also {#extension})
      # @param directives [Hash{Class => Hash}] Directives to apply to this field
      # @param trace [Boolean] If true, a {GraphQL::Tracing} tracer will measure this scalar field
      # @param broadcastable [Boolean] Whether or not this field can be distributed in subscription broadcasts
      # @param ast_node [Language::Nodes::FieldDefinition, nil] If this schema was parsed from definition, this AST node defined the field
      # @param method_conflict_warning [Boolean] If false, skip the warning if this field's method conflicts with a built-in method
      # @param validates [Array<Hash>] Configurations for validating this field
      def initialize: (?type: untyped? `type`, ?name: untyped? name, ?owner: untyped? owner, ?null: untyped? null, ?description: ::Symbol description, ?deprecation_reason: untyped? deprecation_reason, ?method: untyped? method, ?hash_key: untyped? hash_key, ?dig: untyped? dig, ?resolver_method: untyped? resolver_method, ?connection: untyped? connection, ?max_page_size: ::Symbol max_page_size, ?scope: untyped? scope, ?introspection: bool introspection, ?camelize: bool camelize, ?trace: untyped? trace, ?complexity: untyped? complexity, ?ast_node: untyped? ast_node, ?extras: untyped extras, ?extensions: untyped extensions, ?connection_extension: untyped connection_extension, ?resolver_class: untyped? resolver_class, ?subscription_scope: untyped? subscription_scope, ?relay_node_field: bool relay_node_field, ?relay_nodes_field: bool relay_nodes_field, ?method_conflict_warning: bool method_conflict_warning, ?broadcastable: untyped? broadcastable, ?arguments: untyped arguments, ?directives: untyped directives, ?validates: untyped validates) { (untyped) -> untyped } -> void

      # If true, subscription updates with this field can be shared between viewers
      # @return [Boolean, nil]
      # @see GraphQL::Subscriptions::BroadcastAnalyzer
      def broadcastable?: () -> untyped

      # @param text [String]
      # @return [String]
      def description: (?untyped? text) -> untyped

      # Read extension instances from this field,
      # or add new classes/options to be initialized on this field.
      # Extensions are executed in the order they are added.
      #
      # @example adding an extension
      #   extensions([MyExtensionClass])
      #
      # @example adding multiple extensions
      #   extensions([MyExtensionClass, AnotherExtensionClass])
      #
      # @example adding an extension with options
      #   extensions([MyExtensionClass, { AnotherExtensionClass => { filter: true } }])
      #
      # @param extensions [Array<Class, Hash<Class => Hash>>] Add extensions to this field. For hash elements, only the first key/value is used.
      # @return [Array<GraphQL::Schema::FieldExtension>] extensions to apply to this field
      def extensions: (?untyped? new_extensions) -> untyped

      # Add `extension` to this field, initialized with `options` if provided.
      #
      # @example adding an extension
      #   extension(MyExtensionClass)
      #
      # @example adding an extension with options
      #   extension(MyExtensionClass, filter: true)
      #
      # @param extension_class [Class] subclass of {Schema::FieldExtension}
      # @param options [Hash] if provided, given as `options:` when initializing `extension`.
      # @return [void]
      def extension: (untyped extension_class, ?untyped? options) -> nil

      # Read extras (as symbols) from this field,
      # or add new extras to be opted into by this field's resolver.
      #
      # @param new_extras [Array<Symbol>] Add extras to this field
      # @return [Array<Symbol>]
      def extras: (?untyped? new_extras) -> untyped

      def calculate_complexity: (query: untyped query, nodes: untyped nodes, child_complexity: untyped child_complexity) -> untyped

      def complexity: (?untyped? new_complexity) -> untyped

      # @return [Boolean] True if this field's {#max_page_size} should override the schema default.
      def has_max_page_size?: () -> untyped

      # @return [Integer, nil] Applied to connections if {#has_max_page_size?}
      def max_page_size: () -> untyped

      class MissingReturnTypeError < GraphQL::Error
      end

      attr_writer type: untyped

      def type: () -> untyped

      def visible?: (untyped context) -> untyped

      def accessible?: (untyped context) -> untyped

      def authorized?: (untyped object, untyped args, untyped context) -> untyped

      # This method is called by the interpreter for each field.
      # You can extend it in your base field classes.
      # @param object [GraphQL::Schema::Object] An instance of some type class, wrapping an application object
      # @param args [Hash] A symbol-keyed hash of Ruby keyword arguments. (Empty if no args)
      # @param ctx [GraphQL::Query::Context]
      def resolve: (untyped object, untyped args, untyped query_ctx) -> untyped

      # @param ctx [GraphQL::Query::Context]
      def fetch_extra: (untyped extra_name, untyped ctx) -> untyped

      private

      def assert_satisfactory_implementation: (untyped receiver, untyped method_name, untyped ruby_kwargs) -> untyped

      # Wrap execution with hooks.
      # Written iteratively to avoid big stack traces.
      # @return [Object] Whatever the
      def with_extensions: (untyped obj, untyped args, untyped ctx) { (untyped, untyped) -> untyped } -> untyped

      def run_extensions_before_resolve: (untyped obj, untyped args, untyped ctx, untyped extended, ?idx: ::Integer idx) { (untyped, untyped) -> untyped } -> untyped
    end
  end
end

module GraphQL
  class Schema
    # Find schema members using string paths
    #
    # @example Finding object types
    #   MySchema.find("SomeObjectType")
    #
    # @example Finding fields
    #   MySchema.find("SomeObjectType.myField")
    #
    # @example Finding arguments
    #   MySchema.find("SomeObjectType.myField.anArgument")
    #
    # @example Finding directives
    #   MySchema.find("@include")
    #
    class Finder
      class MemberNotFoundError < ArgumentError
      end

      def initialize: (untyped schema) -> void

      def find: (untyped path) -> untyped

      private

      attr_reader schema: untyped

      def find_in_directive: (untyped directive, path: untyped path) -> untyped

      def find_in_type: (untyped `type`, path: untyped path) -> untyped

      def find_in_fields_type: (untyped `type`, kind: untyped kind, path: untyped path) -> untyped

      def find_in_field: (untyped field, path: untyped path) -> untyped

      def find_in_input_object: (untyped input_object, path: untyped path) -> untyped

      def find_in_enum_type: (untyped enum_type, path: untyped path) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Validator
      # The thing being validated
      # @return [GraphQL::Schema::Argument, GraphQL::Schema::Field, GraphQL::Schema::Resolver, Class<GraphQL::Schema::InputObject>]
      attr_reader validated: untyped

      # @param validated [GraphQL::Schema::Argument, GraphQL::Schema::Field, GraphQL::Schema::Resolver, Class<GraphQL::Schema::InputObject>] The argument or argument owner this validator is attached to
      # @param allow_blank [Boolean] if `true`, then objects that respond to `.blank?` and return true for `.blank?` will skip this validation
      # @param allow_null [Boolean] if `true`, then incoming `null`s will skip this validation
      def initialize: (validated: untyped validated, ?allow_blank: bool allow_blank, ?allow_null: bool allow_null) -> void

      # @param object [Object] The application object that this argument's field is being resolved for
      # @param context [GraphQL::Query::Context]
      # @param value [Object] The client-provided value for this argument (after parsing and coercing by the input type)
      # @return [nil, Array<String>, String] Error message or messages to add
      def validate: (untyped object, untyped context, untyped value) -> untyped

      # This is like `String#%`, but it supports the case that only some of `string`'s
      # values are present in `substitutions`
      def partial_format: (untyped string, untyped substitutions) -> untyped

      # @return [Boolean] `true` if `value` is `nil` and this validator has `allow_null: true` or if value is `.blank?` and this validator has `allow_blank: true`
      def permitted_empty_value?: (untyped value) -> untyped

      # @param schema_member [GraphQL::Schema::Field, GraphQL::Schema::Argument, Class<GraphQL::Schema::InputObject>]
      # @param validates_hash [Hash{Symbol => Hash}, Hash{Class => Hash} nil] A configuration passed as `validates:`
      # @return [Array<Validator>]
      def self.from_config: (untyped schema_member, untyped validates_hash) -> untyped

      # Add `validator_class` to be initialized when `validates:` is given `name`.
      # (It's initialized with whatever options are given by the key `name`).
      # @param name [Symbol]
      # @param validator_class [Class]
      # @return [void]
      def self.install: (untyped name, untyped validator_class) -> nil

      # Remove whatever validator class is {.install}ed at `name`, if there is one
      # @param name [Symbol]
      # @return [void]
      def self.uninstall: (untyped name) -> nil

      attr_accessor self.all_validators: untyped

      include Schema::FindInheritedValue::EmptyObjects

      class ValidationFailedError < GraphQL::ExecutionError
        attr_reader errors: untyped

        def initialize: (errors: untyped errors) -> void
      end

      # @param validators [Array<Validator>]
      # @param object [Object]
      # @param context [Query::Context]
      # @param value [Object]
      # @return [void]
      # @raises [ValidationFailedError]
      def self.validate!: (untyped validators, untyped object, untyped context, untyped value, ?as: untyped? as) -> nil
    end
  end
end

module GraphQL
  class Schema
    module FindInheritedValue
      module EmptyObjects
        EMPTY_HASH: ::Hash[untyped, untyped]

        EMPTY_ARRAY: ::Array[untyped]
      end

      def self.extended: (untyped child_cls) -> untyped

      def self.included: (untyped child_cls) -> untyped

      private

      def find_inherited_value: (untyped method_name, ?untyped? default_value) -> untyped
    end
  end
end

module GraphQL
  class Schema
    class Wrapper
      include GraphQL::Schema::Member::TypeSystemHelpers

      # @return [Class, Module] The inner type of this wrapping type, the type of which one or more objects may be present.
      attr_reader of_type: untyped

      def initialize: (untyped of_type) -> void

      def unwrap: () -> untyped

      def ==: (untyped other) -> untyped
    end
  end
end

module GraphQL
  class Schema
    # A possible value for an {Enum}.
    #
    # You can extend this class to customize enum values in your schema.
    #
    # @example custom enum value class
    #   # define a custom class:
    #   class CustomEnumValue < GraphQL::Schema::EnumValue
    #     def initialize(*args)
    #       # arguments to `value(...)` in Enum classes are passed here
    #       super
    #     end
    #   end
    #
    #   class BaseEnum < GraphQL::Schema::Enum
    #     # use it for these enums:
    #     enum_value_class CustomEnumValue
    #   end
    class EnumValue < GraphQL::Schema::Member
      include GraphQL::Schema::Member::HasPath

      include GraphQL::Schema::Member::HasAstNode

      include GraphQL::Schema::Member::HasDirectives

      include GraphQL::Schema::Member::HasDeprecationReason

      attr_reader graphql_name: untyped

      # @return [Class] The enum type that owns this value
      attr_reader owner: untyped

      def initialize: (untyped graphql_name, ?untyped? desc, owner: untyped owner, ?ast_node: untyped? ast_node, ?directives: untyped? directives, ?description: untyped? description, ?value: untyped? value, ?deprecation_reason: untyped? deprecation_reason) { () -> untyped } -> void

      def description: (?untyped? new_desc) -> untyped

      def value: (?untyped? new_val) -> untyped

      def inspect: () -> ::String

      def visible?: (untyped _ctx) -> true

      def accessible?: (untyped _ctx) -> true

      def authorized?: (untyped _ctx) -> true
    end
  end
end

module GraphQL
  class Schema
    class Resolver
      # Adds `field(...)` helper to resolvers so that they can
      # generate payload types.
      #
      # Or, an already-defined one can be attached with `payload_type(...)`.
      module HasPayloadType
        # Call this method to get the derived return type of the mutation,
        # or use it as a configuration method to assign a return type
        # instead of generating one.
        # @param new_payload_type [Class, nil] If a type definition class is provided, it will be used as the return type of the mutation field
        # @return [Class] The object type which this mutation returns.
        def payload_type: (?untyped? new_payload_type) -> untyped

        def type: (?untyped? new_type, ?null: untyped? null) -> untyped

        alias type_expr payload_type

        def field_class: (?untyped? new_class) -> untyped

        # An object class to use for deriving return types
        # @param new_class [Class, nil] Defaults to {GraphQL::Schema::Object}
        # @return [Class]
        def object_class: (?untyped? new_class) -> untyped

        NO_INTERFACES: ::Array[untyped]

        def field: (*untyped args, **untyped kwargs) { () -> untyped } -> untyped

        private

        # Build a subclass of {.object_class} based on `self`.
        # This value will be cached as `{.payload_type}`.
        # Override this hook to customize return type generation.
        def generate_payload_type: () -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    # @api private
    module Base64Encoder
      def self.encode: (untyped unencoded_text, ?nonce: bool nonce) -> untyped

      def self.decode: (untyped encoded_text, ?nonce: bool nonce) -> untyped
    end
  end
end

module GraphQL
  class Schema
    module BuildFromDefinition
      class ResolveMap
        class DefaultResolve
          def initialize: (untyped field_map, untyped field_name) -> void

          # Make some runtime checks about
          # how `obj` implements the `field_name`.
          #
          # Create a new resolve function according to that implementation, then:
          #   - update `field_map` with this implementation
          #   - call the implementation now (to satisfy this field execution)
          #
          # If `obj` doesn't implement `field_name`, raise an error.
          def call: (untyped obj, untyped args, untyped ctx) -> untyped
        end
      end
    end
  end
end

module GraphQL
  class Schema
    module BuildFromDefinition
      # Wrap a user-provided hash of resolution behavior for easy access at runtime.
      #
      # Coerce scalar values by:
      # - Checking for a function in the map like `{ Date: { coerce_input: ->(val, ctx) { ... }, coerce_result: ->(val, ctx) { ... } } }`
      # - Falling back to a passthrough
      #
      # Interface/union resolution can be provided as a `resolve_type:` key.
      #
      # @api private
      class ResolveMap
        module NullScalarCoerce
          def self.call: (untyped val, untyped _ctx) -> untyped
        end

        def initialize: (untyped user_resolve_hash) -> void

        def call: (untyped `type`, untyped field, untyped obj, untyped args, untyped ctx) -> untyped

        def coerce_input: (untyped `type`, untyped value, untyped ctx) -> untyped

        def coerce_result: (untyped `type`, untyped value, untyped ctx) -> untyped
      end
    end
  end
end

module GraphQL
  class AnalysisError < GraphQL::ExecutionError
  end
end

module GraphQL
  class Railtie < Rails::Railtie
  end
end

module GraphQL
  # This error is raised when `Types::ISO8601Date` is asked to return a value
  # that cannot be parsed to a Ruby Date.
  #
  # @see GraphQL::Types::ISO8601Date which raises this error
  class DateEncodingError < GraphQL::RuntimeTypeError
    # The value which couldn't be encoded
    attr_reader date_value: untyped

    def initialize: (untyped value) -> void
  end
end


module GraphQL
  module Execution
    class Interpreter
      # Wrapper for raw values
      class RawValue
        def initialize: (?untyped? obj) -> void

        def resolve: () -> untyped
      end
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      class ExecutionErrors
        def initialize: (untyped ctx, untyped ast_node, untyped path) -> void

        def add: (untyped err_or_msg) -> untyped
      end
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      # A container for metadata regarding arguments present in a GraphQL query.
      # @see Interpreter::Arguments#argument_values for a hash of these objects.
      class ArgumentValue
        def initialize: (definition: untyped definition, value: untyped value, default_used: untyped default_used) -> void

        # @return [Object] The Ruby-ready value for this Argument
        attr_reader value: untyped

        # @return [GraphQL::Schema::Argument] The definition instance for this argument
        attr_reader definition: untyped

        # @return [Boolean] `true` if the schema-defined `default_value:` was applied in this case. (No client-provided value was present.)
        def default_used?: () -> untyped
      end
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      # I think it would be even better if we could somehow make
      # `continue_field` not recursive. "Trampolining" it somehow.
      #
      # @api private
      class Runtime
        module GraphQLResult
          def initialize: (untyped result_name, untyped parent_result) -> void

          attr_accessor graphql_dead: untyped

          attr_reader graphql_parent: untyped

          attr_reader graphql_result_name: untyped

          # Although these are used by only one of the Result classes,
          # it's handy to have the methods implemented on both (even though they just return `nil`)
          # because it makes it easy to check if anything is assigned.
          # @return [nil, Array<String>]
          attr_accessor graphql_non_null_field_names: untyped

          # @return [nil, true]
          attr_accessor graphql_non_null_list_items: untyped

          # @return [Hash] Plain-Ruby result data (`@graphql_metadata` contains Result wrapper objects)
          attr_accessor graphql_result_data: untyped
        end

        class GraphQLResultHash
          def initialize: (untyped _result_name, untyped _parent_result) -> void

          include GraphQLResult

          attr_accessor graphql_merged_into: untyped

          def []=: (untyped key, untyped value) -> untyped

          def delete: (untyped key) -> untyped

          def each: () { (untyped, untyped) -> untyped } -> untyped

          def values: () -> untyped

          def key?: (untyped k) -> untyped

          def []: (untyped k) -> untyped
        end

        class GraphQLResultArray
          include GraphQLResult

          def initialize: (untyped _result_name, untyped _parent_result) -> void

          def graphql_skip_at: (untyped index) -> untyped

          def []=: (untyped idx, untyped value) -> untyped

          def values: () -> untyped
        end

        class GraphQLSelectionSet < Hash[untyped, untyped]
          attr_accessor graphql_directives: untyped
        end

        # @return [GraphQL::Query]
        attr_reader query: untyped

        # @return [Class<GraphQL::Schema>]
        attr_reader schema: untyped

        # @return [GraphQL::Query::Context]
        attr_reader context: untyped

        def initialize: (query: untyped query) -> void

        def final_result: () -> untyped

        def inspect: () -> ::String

        def tap_or_each: (untyped obj_or_array) { (untyped, untyped) -> untyped } -> untyped

        # This _begins_ the execution. Some deferred work
        # might be stored up in lazies.
        # @return [void]
        def run_eager: () -> nil

        # @return [void]
        def deep_merge_selection_result: (untyped from_result, untyped into_result) -> nil

        def gather_selections: (untyped owner_object, untyped owner_type, untyped selections, ?untyped? selections_to_run, ?untyped selections_by_name) -> untyped

        NO_ARGS: ::Hash[untyped, untyped]

        def evaluate_selections: (untyped path, untyped owner_object, untyped owner_type, untyped is_eager_selection, untyped gathered_selections, untyped selections_result, untyped target_result, untyped parent_object) -> untyped

        attr_reader progress_path: untyped

        def evaluate_selection: (untyped path, untyped result_name, untyped field_ast_nodes_or_ast_node, untyped owner_object, untyped owner_type, untyped is_eager_field, untyped selections_result, untyped parent_object) -> (nil | untyped)

        def evaluate_selection_with_args: (untyped arguments, untyped field_defn, untyped next_path, untyped ast_node, untyped field_ast_nodes, untyped owner_type, untyped object, untyped is_eager_field, untyped result_name, untyped selection_result, untyped parent_object) -> untyped

        def dead_result?: (untyped selection_result) -> untyped

        def set_result: (untyped selection_result, untyped result_name, untyped value) { () -> untyped } -> untyped

        # Mark this node and any already-registered children as dead,
        # so that it accepts no more writes.
        def set_graphql_dead: (untyped selection_result) -> untyped

        HALT: untyped

        def continue_value: (untyped path, untyped value, untyped parent_type, untyped field, untyped is_non_null, untyped ast_node, untyped result_name, untyped selection_result) -> untyped

        def continue_field: (untyped path, untyped value, untyped owner_type, untyped field, untyped current_type, untyped ast_node, untyped next_selections, untyped is_non_null, untyped owner_object, untyped arguments, untyped result_name, untyped selection_result) -> untyped

        def resolve_list_item: (untyped inner_value, untyped inner_type, untyped next_path, untyped ast_node, untyped field, untyped owner_object, untyped arguments, untyped this_idx, untyped response_list, untyped next_selections, untyped owner_type) -> untyped

        def call_method_on_directives: (untyped method_name, untyped object, untyped directives) { () -> untyped } -> untyped

        def run_directive: (untyped method_name, untyped object, untyped directives, untyped idx) { () -> untyped } -> untyped

        # Check {Schema::Directive.include?} for each directive that's present
        def directives_include?: (untyped node, untyped graphql_object, untyped parent_type) -> (false | true)

        def set_all_interpreter_context: (untyped object, untyped field, untyped arguments, untyped path) -> untyped

        # @param obj [Object] Some user-returned value that may want to be batched
        # @param path [Array<String>]
        # @param field [GraphQL::Schema::Field]
        # @param eager [Boolean] Set to `true` for mutation root fields only
        # @param trace [Boolean] If `false`, don't wrap this with field tracing
        # @return [GraphQL::Execution::Lazy, Object] If loading `object` will be deferred, it's a wrapper over it.
        def after_lazy: (untyped lazy_obj, owner: untyped owner, field: untyped field, path: untyped path, owner_object: untyped owner_object, arguments: untyped arguments, ast_node: untyped ast_node, result: untyped result, result_name: untyped result_name, ?eager: bool eager, ?trace: bool trace) { (untyped) -> untyped } -> untyped

        def arguments: (untyped graphql_object, untyped arg_owner, untyped ast_node) -> untyped

        # Set this pair in the Query context, but also in the interpeter namespace,
        # for compatibility.
        def set_interpreter_context: (untyped key, untyped value) -> untyped

        def delete_interpreter_context: (untyped key) -> untyped

        def resolve_type: (untyped `type`, untyped value, untyped path) -> untyped

        def authorized_new: (untyped `type`, untyped value, untyped context) -> untyped

        def lazy?: (untyped object) -> untyped
      end
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      # A wrapper for argument hashes in GraphQL queries.
      #
      # This object is immutable so that the runtime code can be sure that
      # modifications don't leak from one use to another
      #
      # @see GraphQL::Query#arguments_for to get access to these objects.
      class Arguments
        # extend Forwardable

        include GraphQL::Dig

        # The Ruby-style arguments hash, ready for a resolver.
        # This hash is the one used at runtime.
        #
        # @return [Hash<Symbol, Object>]
        attr_reader keyword_arguments: untyped

        # @param argument_values [nil, Hash{Symbol => ArgumentValue}]
        # @param keyword_arguments [nil, Hash{Symbol => Object}]
        def initialize: (argument_values: untyped argument_values, ?keyword_arguments: untyped? keyword_arguments) -> void

        # @return [Hash{Symbol => ArgumentValue}]
        attr_reader argument_values: untyped

        def empty?: () -> untyped

        def inspect: () -> ::String

        # Create a new arguments instance which includes these extras.
        #
        # This is called by the runtime to implement field `extras: [...]`
        #
        # @param extra_args [Hash<Symbol => Object>]
        # @return [Interpreter::Arguments]
        # @api private
        def merge_extras: (untyped extra_args) -> untyped

        NO_ARGS: ::Hash[untyped, untyped]

        EMPTY: untyped
      end
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      class ArgumentsCache
        def initialize: (untyped query) -> void

        def fetch: (untyped ast_node, untyped argument_owner, untyped parent_object) -> untyped

        # @yield [Interpreter::Arguments, Lazy<Interpreter::Arguments>] The finally-loaded arguments
        def dataload_for: (untyped ast_node, untyped argument_owner, untyped parent_object) { () -> untyped } -> nil

        private

        NO_ARGUMENTS: ::Hash[untyped, untyped]

        NO_VALUE_GIVEN: untyped

        def self.prepare_args_hash: (untyped query, untyped ast_arg_or_hash_or_value) -> untyped
      end
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      module Resolve
        # Continue field results in `results` until there's nothing else to continue.
        # @return [void]
        def self.resolve_all: (untyped results, untyped dataloader) -> nil

        # After getting `results` back from an interpreter evaluation,
        # continue it until you get a response-ready Ruby value.
        #
        # `results` is one level of _depth_ of a query or multiplex.
        #
        # Resolve all lazy values in that depth before moving on
        # to the next level.
        #
        # It's assumed that the lazies will
        # return {Lazy} instances if there's more work to be done,
        # or return {Hash}/{Array} if the query should be continued.
        #
        # @return [void]
        def self.resolve: (untyped results, untyped dataloader) -> nil
      end
    end
  end
end

module GraphQL
  module Execution
    class Errors
      # Register this handler, updating the
      # internal handler index to maintain least-to-most specific.
      #
      # @param error_class [Class<Exception>]
      # @param error_handlers [Hash]
      # @param error_handler [Proc]
      # @return [void]
      def self.register_rescue_from: (untyped error_class, untyped error_handlers, untyped error_handler) -> nil

      # @return [Proc, nil] The handler for `error_class`, if one was registered on this schema or inherited
      def self.find_handler_for: (untyped schema, untyped error_class) -> untyped
    end
  end
end

module GraphQL
  module Execution
    # This wraps a value which is available, but not yet calculated, like a promise or future.
    #
    # Calling `#value` will trigger calculation & return the "lazy" value.
    #
    # This is an itty-bitty promise-like object, with key differences:
    # - It has only two states, not-resolved and resolved
    # - It has no error-catching functionality
    # @api private
    class Lazy
      # Traverse `val`, lazily resolving any values along the way
      # @param val [Object] A data structure containing mixed plain values and `Lazy` instances
      # @return void
      def self.resolve: (untyped val) -> untyped

      attr_reader path: untyped

      attr_reader field: untyped

      # Create a {Lazy} which will get its inner value by calling the block
      # @param path [Array<String, Integer>]
      # @param field [GraphQL::Schema::Field]
      # @param get_value_func [Proc] a block to get the inner value (later)
      def initialize: (?path: untyped? path, ?field: untyped? field) { () -> untyped } -> void

      # @return [Object] The wrapped value, calling the lazy block if necessary
      def value: () -> untyped

      # @return [Lazy] A {Lazy} whose value depends on another {Lazy}, plus any transformations in `block`
      def then: () { (untyped) -> untyped } -> untyped

      # @param lazies [Array<Object>] Maybe-lazy objects
      # @return [Lazy] A lazy which will sync all of `lazies`
      def self.all: (untyped lazies) -> untyped

      # This can be used for fields which _had no_ lazy results
      # @api private
      NullResult: untyped
    end
  end
end

module GraphQL
  module Execution
    # Lookahead creates a uniform interface to inspect the forthcoming selections.
    #
    # It assumes that the AST it's working with is valid. (So, it's safe to use
    # during execution, but if you're using it directly, be sure to validate first.)
    #
    # A field may get access to its lookahead by adding `extras: [:lookahead]`
    # to its configuration.
    #
    # @example looking ahead in a field
    #   field :articles, [Types::Article], null: false,
    #     extras: [:lookahead]
    #
    #   # For example, imagine a faster database call
    #   # may be issued when only some fields are requested.
    #   #
    #   # Imagine that _full_ fetch must be made to satisfy `fullContent`,
    #   # we can look ahead to see if we need that field. If we do,
    #   # we make the expensive database call instead of the cheap one.
    #   def articles(lookahead:)
    #     if lookahead.selects?(:full_content)
    #       fetch_full_articles(object)
    #     else
    #       fetch_preview_articles(object)
    #     end
    #   end
    class Lookahead
      # @param query [GraphQL::Query]
      # @param ast_nodes [Array<GraphQL::Language::Nodes::Field>, Array<GraphQL::Language::Nodes::OperationDefinition>]
      # @param field [GraphQL::Schema::Field] if `ast_nodes` are fields, this is the field definition matching those nodes
      # @param root_type [Class] if `ast_nodes` are operation definition, this is the root type for that operation
      def initialize: (query: untyped query, ast_nodes: untyped ast_nodes, ?field: untyped? field, ?root_type: untyped? root_type, ?owner_type: untyped? owner_type) -> void

      # @return [Array<GraphQL::Language::Nodes::Field>]
      attr_reader ast_nodes: untyped

      # @return [GraphQL::Schema::Field]
      attr_reader field: untyped

      # @return [GraphQL::Schema::Object, GraphQL::Schema::Union, GraphQL::Schema::Interface]
      attr_reader owner_type: untyped

      # @return [Hash<Symbol, Object>]
      def arguments: () -> untyped

      # True if this node has a selection on `field_name`.
      # If `field_name` is a String, it is treated as a GraphQL-style (camelized)
      # field name and used verbatim. If `field_name` is a Symbol, it is
      # treated as a Ruby-style (underscored) name and camelized before comparing.
      #
      # If `arguments:` is provided, each provided key/value will be matched
      # against the arguments in the next selection. This method will return false
      # if any of the given `arguments:` are not present and matching in the next selection.
      # (But, the next selection may contain _more_ than the given arguments.)
      # @param field_name [String, Symbol]
      # @param arguments [Hash] Arguments which must match in the selection
      # @return [Boolean]
      def selects?: (untyped field_name, ?arguments: untyped? arguments) -> untyped

      # @return [Boolean] True if this lookahead represents a field that was requested
      def selected?: () -> true

      # Like {#selects?}, but can be used for chaining.
      # It returns a null object (check with {#selected?})
      # @return [GraphQL::Execution::Lookahead]
      def selection: (untyped field_name, ?selected_type: untyped selected_type, ?arguments: untyped? arguments) -> untyped

      # Like {#selection}, but for all nodes.
      # It returns a list of Lookaheads for all Selections
      #
      # If `arguments:` is provided, each provided key/value will be matched
      # against the arguments in each selection. This method will filter the selections
      # if any of the given `arguments:` do not match the given selection.
      #
      # @example getting the name of a selection
      #   def articles(lookahead:)
      #     next_lookaheads = lookahead.selections # => [#<GraphQL::Execution::Lookahead ...>, ...]
      #     next_lookaheads.map(&:name) #=> [:full_content, :title]
      #   end
      #
      # @param arguments [Hash] Arguments which must match in the selection
      # @return [Array<GraphQL::Execution::Lookahead>]
      def selections: (?arguments: untyped? arguments) -> untyped

      # The method name of the field.
      # It returns the method_sym of the Lookahead's field.
      #
      # @example getting the name of a selection
      #   def articles(lookahead:)
      #     article.selection(:full_content).name # => :full_content
      #     # ...
      #   end
      #
      # @return [Symbol]
      def name: () -> untyped

      def inspect: () -> ::String

      # This is returned for {Lookahead#selection} when a non-existent field is passed
      class NullLookahead < Lookahead
        # No inputs required here.
        def initialize: () -> void

        def selected?: () -> false

        def selects?: () -> false

        def selection: () -> untyped

        def selections: () -> ::Array[untyped]

        def inspect: () -> "#<GraphQL::Execution::Lookahead::NullLookahead>"
      end

      # A singleton, so that misses don't come with overhead.
      NULL_LOOKAHEAD: untyped

      private

      # If it's a symbol, stringify and camelize it
      def normalize_name: (untyped name) -> untyped

      def normalize_keyword: (untyped keyword) -> untyped

      def skipped_by_directive?: (untyped ast_selection) -> (true | false)

      def find_selections: (untyped subselections_by_type, untyped selections_on_type, untyped selected_type, untyped ast_selections, untyped arguments) -> untyped

      # If a selection on `node` matches `field_name` (which is backed by `field_defn`)
      # and matches the `arguments:` constraints, then add that node to `matches`
      def find_selected_nodes: (untyped node, untyped field_name, untyped field_defn, arguments: untyped arguments, matches: untyped matches) -> (nil | untyped)

      def arguments_match?: (untyped arguments, untyped field_defn, untyped field_node) -> untyped
    end
  end
end

module GraphQL
  module Execution
    # Execute multiple queries under the same multiplex "umbrella".
    # They can share a batching context and reduce redundant database hits.
    #
    # The flow is:
    #
    # - Multiplex instrumentation setup
    # - Query instrumentation setup
    # - Analyze the multiplex + each query
    # - Begin each query
    # - Resolve lazy values, breadth-first across all queries
    # - Finish each query (eg, get errors)
    # - Query instrumentation teardown
    # - Multiplex instrumentation teardown
    #
    # If one query raises an application error, all queries will be in undefined states.
    #
    # Validation errors and {GraphQL::ExecutionError}s are handled in isolation:
    # one of these errors in one query will not affect the other queries.
    #
    # @see {Schema#multiplex} for public API
    # @api private
    class Multiplex
      # Used internally to signal that the query shouldn't be executed
      # @api private
      NO_OPERATION: ::Hash[untyped, untyped]

      include Tracing::Traceable

      attr_reader context: untyped

      attr_reader queries: untyped

      attr_reader schema: untyped

      attr_reader max_complexity: untyped

      attr_reader dataloader: untyped

      def initialize: (schema: untyped schema, queries: untyped queries, context: untyped context, max_complexity: untyped max_complexity) -> void

      # @param schema [GraphQL::Schema]
      # @param queries [Array<GraphQL::Query, Hash>]
      # @param context [Hash]
      # @param max_complexity [Integer, nil]
      # @return [Array<Hash>] One result per query
      def self.run_all: (untyped schema, untyped query_options, ?context: ::Hash[untyped, untyped] context, ?max_complexity: untyped max_complexity) -> untyped

      # @param query [GraphQL::Query]
      def self.begin_query: (untyped results, untyped idx, untyped query, untyped multiplex) -> nil

      private

      # @param data_result [Hash] The result for the "data" key, if any
      # @param query [GraphQL::Query] The query which was run
      # @return [Hash] final result of this query, including all values and errors
      def self.finish_query: (untyped data_result, untyped query, untyped multiplex) -> untyped
    end
  end
end

module GraphQL
  module Execution
    class Interpreter
      def self.begin_multiplex: (untyped multiplex) -> untyped

      def self.begin_query: (untyped query, untyped multiplex) -> untyped

      def self.finish_multiplex: (untyped _results, untyped multiplex) -> untyped

      def self.finish_query: (untyped query, untyped _multiplex) -> ::Hash[::String, untyped]

      # Run the eager part of `query`
      # @return {Interpreter::Runtime}
      def evaluate: (untyped query) -> untyped

      # Run the lazy part of `query` or `multiplex`.
      # @return [void]
      def sync_lazies: (?query: untyped? query, ?multiplex: untyped? multiplex) -> nil

      class ListResultFailedError < GraphQL::Error
        def initialize: (value: untyped value, path: untyped path, field: untyped field) -> void
      end
    end
  end
end

module GraphQL
  module Execution
    class Lazy
      # {GraphQL::Schema} uses this to match returned values to lazy resolution methods.
      # Methods may be registered for classes, they apply to its subclasses also.
      # The result of this lookup is cached for future resolutions.
      # Instances of this class are thread-safe.
      # @api private
      # @see {Schema#lazy?} looks up values from this map
      class LazyMethodMap
        def initialize: (?use_concurrent: untyped use_concurrent) -> void

        def initialize_copy: (untyped other) -> untyped

        # @param lazy_class [Class] A class which represents a lazy value (subclasses may also be used)
        # @param lazy_value_method [Symbol] The method to call on this class to get its value
        def set: (untyped lazy_class, untyped lazy_value_method) -> untyped

        # @param value [Object] an object which may have a `lazy_value_method` registered for its class or superclasses
        # @return [Symbol, nil] The `lazy_value_method` for this object, or nil
        def get: (untyped value) -> untyped

        def each: () { (untyped, untyped) -> untyped } -> untyped

        attr_reader storage: untyped

        private

        def find_superclass_method: (untyped value_class) -> (untyped | nil)

        # Mock the Concurrent::Map API
        class ConcurrentishMap
          # extend Forwardable

          def initialize: () -> void

          def []=: (untyped key, untyped value) -> untyped

          def compute_if_absent: (untyped key) { () -> untyped } -> untyped

          def initialize_copy: (untyped other) -> untyped

          def copy_storage: () -> untyped
        end
      end
    end
  end
end

module GraphQL
  module Execution
    class Lazy
      # Helpers for dealing with data structures containing {Lazy} instances
      # @api private
      module Resolve
        # This object can be passed like an array, but it doesn't allocate an
        # array until it's used.
        #
        # There's one crucial difference: you have to _capture_ the result
        # of `#<<`. (This _works_ with arrays but isn't required, since it has a side-effect.)
        # @api private
        module NullAccumulator
          def self.<<: (untyped item) -> ::Array[untyped]

          def self.empty?: () -> true
        end

        def self.resolve: (untyped value) -> untyped

        def self.resolve_in_place: (untyped value) -> untyped

        # If `value` is a collection,
        # add any {Lazy} instances in the collection
        # to `acc`
        # @return [void]
        def self.each_lazy: (untyped acc, untyped value) -> untyped

        # Traverse `val`, triggering resolution for each {Lazy}.
        # These {Lazy}s are expected to mutate their owner data structures
        # during resolution! (They're created with the `.then` calls in `resolve_in_place`).
        # @return [void]
        def self.deep_sync: (untyped val) -> untyped
      end
    end
  end
end

module GraphQL
  module Execution
    # Boolean checks for how an AST node's directives should
    # influence its execution
    # @api private
    module DirectiveChecks
      SKIP: "skip"

      INCLUDE: "include"

      # @return [Boolean] Should this node be included in the query?
      def self?.include?: (untyped directive_ast_nodes, untyped query) -> (false | true)
    end
  end
end

module GraphQL
  module Execution
    module Instrumentation
      # This function implements the instrumentation policy:
      #
      # - Instrumenters are a stack; the first `before_query` will have the last `after_query`
      # - If a `before_` hook returned without an error, its corresponding `after_` hook will run.
      # - If the `before_` hook did _not_ run, the `after_` hook will not be called.
      #
      # When errors are raised from `after_` hooks:
      #   - Subsequent `after_` hooks _are_ called
      #   - The first raised error is captured; later errors are ignored
      #   - If an error was capture, it's re-raised after all hooks are finished
      #
      # Partial runs of instrumentation are possible:
      # - If a `before_multiplex` hook raises an error, no `before_query` hooks will run
      # - If a `before_query` hook raises an error, subsequent `before_query` hooks will not run (on any query)
      def self.apply_instrumenters: (untyped multiplex) { () -> untyped } -> untyped

      private

      # Call the before_ hooks of each query,
      # Then yield if no errors.
      # `call_hooks` takes care of appropriate cleanup.
      def self.each_query_call_hooks: (untyped instrumenters, untyped queries, ?::Integer i) { () -> untyped } -> untyped

      # Call each before hook, and if they all succeed, yield.
      # If they don't all succeed, call after_ for each one that succeeded.
      def self.call_hooks: (untyped instrumenters, untyped object, untyped before_hook_name, untyped after_hook_name) { () -> untyped } -> untyped

      def self.call_after_hooks: (untyped instrumenters, untyped object, untyped after_hook_name, untyped ex) -> untyped
    end
  end
end

module GraphQL
  class StringEncodingError < GraphQL::RuntimeTypeError
    attr_reader string: untyped

    attr_reader field: untyped

    attr_reader path: untyped

    def initialize: (untyped str, context: untyped context) -> void
  end
end

module GraphQL
  module Rubocop
    module GraphQL
      # Identify (and auto-correct) any field configuration which duplicates
      # the default `null: true` property.
      #
      # `null: true` is default because nullable fields can always be converted
      # to non-null fields (`null: false`) without a breaking change. (The opposite change, from `null: false`
      # to `null: true`, change.)
      #
      # @example
      #   # Both of these define `name: String` in GraphQL:
      #
      #   # bad
      #   field :name, String, null: true
      #
      #   # good
      #   field :name, String
      #
      # class DefaultNullTrue < BaseCop
      #   MSG: "`null: true` is the default and can be removed."

      #   def on_send: (untyped node) -> untyped
      # end
    end
  end
end

module GraphQL
  module Rubocop
    module GraphQL
      # Identify (and auto-correct) any argument configuration which duplicates
      # the default `required: true` property.
      #
      # `required: true` is default because required arguments can always be converted
      # to optional arguments (`required: false`) without a breaking change. (The opposite change, from `required: false`
      # to `required: true`, change.)
      #
      # @example
      #   # Both of these define `id: ID!` in GraphQL:
      #
      #   # bad
      #   argument :id, ID, required: true
      #
      #   # good
      #   argument :id, ID
      #
      # class DefaultRequiredTrue < BaseCop
      #   MSG: "`required: true` is the default and can be removed."

      #   def on_send: (untyped node) -> untyped
      # end
    end
  end
end

module GraphQL
  module Rubocop
    module GraphQL
      # class BaseCop < RuboCop::Cop::Base
      #   extend RuboCop::Cop::AutoCorrector

      #   # Return the source of `send_node`, but without the keyword argument represented by `pair_node`
      #   def source_without_keyword_argument: (untyped send_node, untyped pair_node) -> untyped
      # end
    end
  end
end

module GraphQL
  module Deprecation
    def self.warn: (untyped message) -> untyped
  end
end

module GraphQL
  class Subscriptions
    # Raised when either:
    # - the triggered `event_name` doesn't match a field in the schema; or
    # - one or more arguments don't match the field arguments
    class InvalidTriggerError < GraphQL::Error
    end

    # Raised when either:
    # - An initial subscription didn't have a value for `context[subscription_scope]`
    # - Or, an update didn't pass `.trigger(..., scope:)`
    # When raised, the initial subscription or update fails completely.
    class SubscriptionScopeMissingError < GraphQL::Error
    end

    # @see {Subscriptions#initialize} for options, concrete implementations may add options.
    def self.use: (untyped defn, ?::Hash[untyped, untyped] options) -> nil

    # @param schema [Class] the GraphQL schema this manager belongs to
    def initialize: (schema: untyped schema, ?broadcast: bool broadcast, ?default_broadcastable: bool default_broadcastable, **untyped rest) -> void

    # @return [Boolean] Used when fields don't have `broadcastable:` explicitly set
    attr_reader default_broadcastable: untyped

    # Fetch subscriptions matching this field + arguments pair
    # And pass them off to the queue.
    # @param event_name [String]
    # @param args [Hash<String, Symbol => Object]
    # @param object [Object]
    # @param scope [Symbol, String]
    # @param context [Hash]
    # @return [void]
    def trigger: (untyped event_name, untyped args, untyped object, ?scope: untyped? scope, ?context: ::Hash[untyped, untyped] context) -> untyped

    # `event` was triggered on `object`, and `subscription_id` was subscribed,
    # so it should be updated.
    #
    # Load `subscription_id`'s GraphQL data, re-evaluate the query and return the result.
    #
    # @param subscription_id [String]
    # @param event [GraphQL::Subscriptions::Event] The event which was triggered
    # @param object [Object] The value for the subscription field
    # @return [GraphQL::Query::Result]
    def execute_update: (untyped subscription_id, untyped event, untyped object) -> (nil | untyped)

    # Run the update query for this subscription and deliver it
    # @see {#execute_update}
    # @see {#deliver}
    # @return [void]
    def execute: (untyped subscription_id, untyped event, untyped object) -> untyped

    # Event `event` occurred on `object`,
    # Update all subscribers.
    # @param event [Subscriptions::Event]
    # @param object [Object]
    # @return [void]
    def execute_all: (untyped event, untyped object) -> untyped

    # The system wants to send an update to this subscription.
    # Read its data and return it.
    # @param subscription_id [String]
    # @return [Hash] Containing required keys
    def read_subscription: (untyped subscription_id) -> untyped

    # A subscription query was re-evaluated, returning `result`.
    # The result should be send to `subscription_id`.
    # @param subscription_id [String]
    # @param result [Hash]
    # @return [void]
    def deliver: (untyped subscription_id, untyped result) -> untyped

    # `query` was executed and found subscriptions to `events`.
    # Update the database to reflect this new state.
    # @param query [GraphQL::Query]
    # @param events [Array<GraphQL::Subscriptions::Event>]
    # @return [void]
    def write_subscription: (untyped query, untyped events) -> untyped

    # A subscription was terminated server-side.
    # Clean up the database.
    # @param subscription_id [String]
    # @return void.
    def delete_subscription: (untyped subscription_id) -> untyped

    # @return [String] A new unique identifier for a subscription
    def build_id: () -> untyped

    # Convert a user-provided event name or argument
    # to the equivalent in GraphQL.
    #
    # By default, it converts the identifier to camelcase.
    # Override this in a subclass to change the transformation.
    #
    # @param event_or_arg_name [String, Symbol]
    # @return [String]
    def normalize_name: (untyped event_or_arg_name) -> untyped

    # @return [Boolean] if true, then a query like this one would be broadcasted
    def broadcastable?: (untyped query_str, **untyped query_options) -> untyped

    private

    # Recursively normalize `args` as belonging to `arg_owner`:
    # - convert symbols to strings,
    # - if needed, camelize the string (using {#normalize_name})
    # @param arg_owner [GraphQL::Field, GraphQL::BaseType]
    # @param args [Hash, Array, Any] some GraphQL input value to coerce as `arg_owner`
    # @return [Any] normalized arguments value
    def normalize_arguments: (untyped event_name, untyped arg_owner, untyped args, untyped context) -> untyped
  end
end

module GraphQL
  # If a field's resolve function returns a {ExecutionError},
  # the error will be inserted into the response's `"errors"` key
  # and the field will resolve to `nil`.
  class ExecutionError < GraphQL::Error
    # @return [GraphQL::Language::Nodes::Field] the field where the error occurred
    attr_accessor ast_node: untyped

    # @return [String] an array describing the JSON-path into the execution
    # response which corresponds to this error.
    attr_accessor path: untyped

    # @return [Hash] Optional data for error objects
    # @deprecated Use `extensions` instead of `options`. The GraphQL spec
    # recommends that any custom entries in an error be under the
    # `extensions` key.
    attr_accessor options: untyped

    # @return [Hash] Optional custom data for error objects which will be added
    # under the `extensions` key.
    attr_accessor extensions: untyped

    def initialize: (untyped message, ?ast_node: untyped? ast_node, ?options: untyped? options, ?extensions: untyped? extensions) -> void

    # @return [Hash] An entry for the response's "errors" key
    def to_h: () -> untyped
  end
end

module GraphQL
  VERSION: "2.0.6"
end


module GraphQL
  # When an `authorized?` hook returns false, this error is used to communicate the failure.
  # It's passed to {Schema.unauthorized_object}.
  #
  # Alternatively, custom code in `authorized?` may raise this error. It will be routed the same way.
  class UnauthorizedError < GraphQL::Error
    # @return [Object] the application object that failed the authorization check
    attr_reader object: untyped

    # @return [Class] the GraphQL object type whose `.authorized?` method was called (and returned false)
    attr_reader type: untyped

    # @return [GraphQL::Query::Context] the context for the current query
    attr_accessor context: untyped

    def initialize: (?untyped? message, ?object: untyped? object, ?type: untyped? `type`, ?context: untyped? context) -> void
  end
end

module GraphQL
  module Execution
    # @api private
    class Skip < GraphQL::Error
    end

    # Just a singleton for implementing {Query::Context#skip}
    # @api private
    SKIP: untyped
  end
end

module GraphQL
  class UnauthorizedFieldError < GraphQL::UnauthorizedError
    # @return [Field] the field that failed the authorization check
    attr_accessor field: untyped

    def initialize: (?untyped? message, ?object: untyped? object, ?type: untyped? `type`, ?context: untyped? context, ?field: untyped? field) -> void
  end
end

module GraphQL
  class InvalidNameError < GraphQL::ExecutionError
    attr_reader name: untyped

    attr_reader valid_regex: untyped

    def initialize: (untyped name, untyped valid_regex) -> void
  end
end

module GraphQL
  module Relay
    # This provides some isolation from `GraphQL::Relay` internals.
    #
    # Given a list of items and a new item, it will provide a connection and an edge.
    #
    # The connection doesn't receive outside arguments, so the list of items
    # should be ordered and paginated before providing it here.
    #
    # @example Adding a comment to list of comments
    #   post = Post.find(args[:post_id])
    #   comments = post.comments
    #   new_comment = comments.build(body: args[:body])
    #   new_comment.save!
    #
    #   range_add = GraphQL::Relay::RangeAdd.new(
    #     parent: post,
    #     collection: comments,
    #     item: new_comment,
    #     context: context,
    #   )
    #
    #   response = {
    #     post: post,
    #     comments_connection: range_add.connection,
    #     new_comment_edge: range_add.edge,
    #   }
    class RangeAdd
      attr_reader edge: untyped

      attr_reader connection: untyped

      attr_reader parent: untyped

      # @param collection [Object] The list of items to wrap in a connection
      # @param item [Object] The newly-added item (will be wrapped in `edge_class`)
      # @param context [GraphQL::Query::Context] The surrounding `ctx`, will be passed to the connection
      # @param parent [Object] The owner of `collection`, will be passed to the connection if provided
      # @param edge_class [Class] The class to wrap `item` with (defaults to the connection's edge class)
      def initialize: (collection: untyped collection, item: untyped item, context: untyped context, ?parent: untyped? parent, ?edge_class: untyped? edge_class) -> void
    end
  end
end

module GraphQL
  # A combination of query string and {Schema} instance which can be reduced to a {#result}.
  class Query
    include Tracing::Traceable

    # extend Forwardable

    class OperationNameMissingError < GraphQL::ExecutionError
      def initialize: (untyped name) -> void
    end

    attr_reader schema: untyped

    attr_reader context: untyped

    attr_reader provided_variables: untyped

    # The value for root types
    attr_accessor root_value: untyped

    # @return [nil, String] The operation name provided by client or the one inferred from the document. Used to determine which operation to run.
    attr_accessor operation_name: untyped

    # @return [Boolean] if false, static validation is skipped (execution behavior for invalid queries is undefined)
    attr_accessor validate: untyped

    attr_writer query_string: untyped

    # @return [GraphQL::Language::Nodes::Document]
    def document: () -> untyped

    def inspect: () -> "query ..."

    # @return [String, nil] The name of the operation to run (may be inferred)
    def selected_operation_name: () -> (nil | untyped)

    # @return [String, nil] the triggered event, if this query is a subscription update
    attr_reader subscription_topic: untyped

    attr_reader tracers: untyped

    # Prepare query `query_string` on `schema`
    # @param schema [GraphQL::Schema]
    # @param query_string [String]
    # @param context [#[]] an arbitrary hash of values which you can access in {GraphQL::Field#resolve}
    # @param variables [Hash] values for `$variables` in the query
    # @param operation_name [String] if the query string contains many operations, this is the one which should be executed
    # @param root_value [Object] the object used to resolve fields on the root type
    # @param max_depth [Numeric] the maximum number of nested selections allowed for this query (falls back to schema-level value)
    # @param max_complexity [Numeric] the maximum field complexity for this query (falls back to schema-level value)
    # @param except [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns truthy
    # @param only [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns false
    def initialize: (untyped schema, ?untyped? query_string, ?query: untyped? query, ?document: untyped? document, ?context: untyped? context, ?variables: untyped? variables, ?validate: bool validate, ?subscription_topic: untyped? subscription_topic, ?operation_name: untyped? operation_name, ?root_value: untyped? root_value, ?max_depth: untyped max_depth, ?max_complexity: untyped max_complexity, ?except: untyped? except, ?only: untyped? only, ?warden: untyped? warden) -> void

    # If a document was provided to `GraphQL::Schema#execute` instead of the raw query string, we will need to get it from the document
    def query_string: () -> untyped

    def interpreter?: () -> true

    attr_accessor multiplex: untyped

    def subscription_update?: () -> untyped

    # A lookahead for the root selections of this query
    # @return [GraphQL::Execution::Lookahead]
    def lookahead: () -> untyped

    # @api private
    def result_values=: (untyped result_hash) -> untyped

    # @api private
    attr_reader result_values: untyped

    def fragments: () -> untyped

    def operations: () -> untyped

    # Get the result for this query, executing it once
    # @return [Hash] A GraphQL response, with `"data"` and/or `"errors"` keys
    def result: () -> untyped

    def executed?: () -> untyped

    def static_errors: () -> untyped

    # This is the operation to run for this query.
    # If more than one operation is present, it must be named at runtime.
    # @return [GraphQL::Language::Nodes::OperationDefinition, nil]
    def selected_operation: () -> untyped

    # Determine the values for variables of this query, using default values
    # if a value isn't provided at runtime.
    #
    # If some variable is invalid, errors are added to {#validation_errors}.
    #
    # @return [GraphQL::Query::Variables] Variables to apply to this query
    def variables: () -> untyped

    # Node-level cache for calculating arguments. Used during execution and query analysis.
    # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
    # @param definition [GraphQL::Schema::Field]
    # @param parent_object [GraphQL::Schema::Object]
    # @return Hash{Symbol => Object}
    def arguments_for: (untyped ast_node, untyped definition, ?parent_object: untyped? parent_object) -> untyped

    def arguments_cache: () -> untyped

    # A version of the given query string, with:
    # - Variables inlined to the query
    # - Strings replaced with `<REDACTED>`
    # @return [String, nil] Returns nil if the query is invalid.
    def sanitized_query_string: (?inline_variables: bool inline_variables) -> untyped

    # This contains a few components:
    #
    # - The selected operation name (or `anonymous`)
    # - The fingerprint of the query string
    # - The number of given variables (for readability)
    # - The fingerprint of the given variables
    #
    # This fingerprint can be used to track runs of the same operation-variables combination over time.
    #
    # @see operation_fingerprint
    # @see variables_fingerprint
    # @return [String] An opaque hash identifying this operation-variables combination
    def fingerprint: () -> untyped

    # @return [String] An opaque hash for identifying this query's given query string and selected operation
    def operation_fingerprint: () -> untyped

    # @return [String] An opaque hash for identifying this query's given a variable values (not including defaults)
    def variables_fingerprint: () -> untyped

    def validation_pipeline: () -> untyped

    attr_accessor analysis_errors: untyped

    def valid?: () -> untyped

    def warden: () -> untyped

    # @param abstract_type [GraphQL::UnionType, GraphQL::InterfaceType]
    # @param value [Object] Any runtime value
    # @return [GraphQL::ObjectType, nil] The runtime type of `value` from {Schema#resolve_type}
    # @see {#possible_types} to apply filtering from `only` / `except`
    def resolve_type: (untyped abstract_type, ?::Symbol value) -> untyped

    def mutation?: () -> untyped

    def query?: () -> untyped

    # @return [void]
    def merge_filters: (?only: untyped? only, ?except: untyped? except) -> nil

    def subscription?: () -> untyped

    # @api private
    def handle_or_reraise: (untyped err) -> untyped

    private

    def find_operation: (untyped operations, untyped operation_name) -> untyped

    def prepare_ast: () -> untyped

    # Since the query string is processed at the last possible moment,
    # any internal values which depend on it should be accessed within this wrapper.
    def with_prepared_ast: () { () -> untyped } -> untyped
  end
end

module GraphQL
  class Query
    class InputValidationResult
      attr_accessor problems: untyped

      def self.from_problem: (untyped explanation, ?untyped? path, ?extensions: untyped? extensions, ?message: untyped? message) -> untyped

      def initialize: (?valid: bool valid, ?problems: untyped? problems) -> void

      def valid?: () -> untyped

      def add_problem: (untyped explanation, ?untyped? path, ?extensions: untyped? extensions, ?message: untyped? message) -> untyped

      def merge_result!: (untyped path, untyped inner_result) -> (nil | untyped)

      VALID: untyped
    end
  end
end

module GraphQL
  class Query
    # A result from {Schema#execute}.
    # It provides the requested data and
    # access to the {Query} and {Query::Context}.
    class Result
      # extend Forwardable

      def initialize: (query: untyped query, values: untyped values) -> void

      # @return [GraphQL::Query] The query that was executed
      attr_reader query: untyped

      # @return [Hash] The resulting hash of "data" and/or "errors"
      attr_reader to_h: untyped

      # Delegate any hash-like method to the underlying hash.
      def method_missing: (untyped method_name, *untyped args) { () -> untyped } -> untyped

      def respond_to_missing?: (untyped method_name, ?bool include_private) -> untyped

      def inspect: () -> ::String

      # A result is equal to another object when:
      #
      # - The other object is a Hash whose value matches `result.to_h`
      # - The other object is a Result whose value matches `result.to_h`
      #
      # (The query is ignored for comparing result equality.)
      #
      # @return [Boolean]
      def ==: (untyped other) -> untyped
    end
  end
end

module GraphQL
  class Query
    # Expose some query-specific info to field resolve functions.
    # It delegates `[]` to the hash that's passed to `GraphQL::Query#initialize`.
    class Context
      module SharedMethods
        # Return this value to tell the runtime
        # to exclude this field from the response altogether
        def skip: () -> untyped

        # Add error at query-level.
        # @param error [GraphQL::ExecutionError] an execution error
        # @return [void]
        def add_error: (untyped error) -> nil

        # @example Print the GraphQL backtrace during field resolution
        #   puts ctx.backtrace
        #
        # @return [GraphQL::Backtrace] The backtrace for this point in query execution
        def backtrace: () -> untyped

        def execution_errors: () -> untyped
      end

      class ExecutionErrors
        def initialize: (untyped ctx) -> void

        def add: (untyped err_or_msg) -> untyped

        alias >> add

        alias push add
      end

      include SharedMethods

      # extend Forwardable

      # @return [Array<GraphQL::ExecutionError>] errors returned during execution
      attr_reader errors: untyped

      # @return [GraphQL::Query] The query whose context this is
      attr_reader query: untyped

      # @return [GraphQL::Schema]
      attr_reader schema: untyped

      # @return [Array<String, Integer>] The current position in the result
      attr_reader path: untyped

      # Make a new context which delegates key lookup to `values`
      # @param query [GraphQL::Query] the query who owns this context
      # @param values [Hash] A hash of arbitrary values which will be accessible at query-time
      def initialize: (query: untyped query, values: untyped values, object: untyped object, ?schema: untyped schema) -> void

      class ScopedContext
        def initialize: (untyped query_context) -> void

        def merged_context: () -> untyped

        def merge!: (untyped hash) -> untyped

        def current_path: () -> untyped

        def key?: (untyped key) -> (true | false)

        def []: (untyped key) -> (untyped | nil)

        def dig: (untyped key, *untyped other_keys) -> (untyped | nil)

        private

        # Start at the current location,
        # but look up the tree for previously-assigned scoped values
        def each_present_path_ctx: () { (untyped) -> untyped } -> untyped
      end

      # @return [Hash] A hash that will be added verbatim to the result hash, as `"extensions" => { ... }`
      def response_extensions: () -> untyped

      def dataloader: () -> untyped

      # @api private
      attr_writer interpreter: untyped

      # @api private
      attr_writer value: untyped

      # @api private
      attr_reader scoped_context: untyped

      def []=: (untyped key, untyped value) -> untyped

      # Lookup `key` from the hash passed to {Schema#execute} as `context:`
      def []: (untyped key) -> untyped

      def delete: (untyped key) -> untyped

      UNSPECIFIED_FETCH_DEFAULT: untyped

      def fetch: (untyped key, ?untyped default) { (untyped, untyped) -> untyped } -> untyped

      def dig: (untyped key, *untyped other_keys) -> untyped

      def to_h: () -> untyped

      alias to_hash to_h

      def key?: (untyped key) -> untyped

      # @return [GraphQL::Schema::Warden]
      def warden: () -> untyped

      # @api private
      attr_writer warden: untyped

      # Get an isolated hash for `ns`. Doesn't affect user-provided storage.
      # @param ns [Object] a usage-specific namespace identifier
      # @return [Hash] namespaced storage
      def namespace: (untyped ns) -> untyped

      # @return [Boolean] true if this namespace was accessed before
      def namespace?: (untyped ns) -> untyped

      def inspect: () -> "#<Query::Context ...>"

      def scoped_merge!: (untyped hash) -> untyped

      def scoped_set!: (untyped key, untyped value) -> nil
    end
  end
end

module GraphQL
  class Query
    # This object can be `ctx` in places where there is no query
    class NullContext
      class NullWarden < GraphQL::Schema::Warden
        def visible_field?: (untyped field, untyped ctx) -> true

        def visible_argument?: (untyped arg, untyped ctx) -> true

        def visible_type?: (untyped `type`, untyped ctx) -> true

        def visible_enum_value?: (untyped ev, untyped ctx) -> true

        def visible_type_membership?: (untyped tm, untyped ctx) -> true
      end

      class NullQuery
      end

      class NullSchema < GraphQL::Schema
      end

      attr_reader schema: untyped

      attr_reader query: untyped

      attr_reader warden: untyped

      attr_reader dataloader: untyped

      def initialize: () -> void

      def []: (untyped key) -> nil

      def interpreter?: () -> true

      # extend Forwardable

      def self.[]: (untyped key) -> nil

      def self.instance: () -> untyped
    end
  end
end

module GraphQL
  class Query
    # @api private
    # @see Query#query_fingerprint
    # @see Query#variables_fingerprint
    # @see Query#fingerprint
    module Fingerprint
      # Make an obfuscated hash of the given string (either a query string or variables JSON)
      # @param string [String]
      # @return [String] A normalized, opaque hash
      def self.generate: (untyped input_str) -> untyped
    end
  end
end

module GraphQL
  class Query
    # Read-only access to query variables, applying default values if needed.
    class Variables
      # extend Forwardable

      # @return [Array<GraphQL::Query::VariableValidationError>]  Any errors encountered when parsing the provided variables and literal values
      attr_reader errors: untyped

      attr_reader context: untyped

      def initialize: (untyped ctx, untyped ast_variables, untyped provided_variables) -> void

      private

      def deep_stringify: (untyped val) -> untyped
    end
  end
end

module GraphQL
  class Query
    # Contain the validation pipeline and expose the results.
    #
    # 0. Checks in {Query#initialize}:
    #   - Rescue a ParseError, halt if there is one
    #   - Check for selected operation, halt if not found
    # 1. Validate the AST, halt if errors
    # 2. Validate the variables, halt if errors
    # 3. Run query analyzers, halt if errors
    #
    # {#valid?} is false if any of the above checks halted the pipeline.
    #
    # @api private
    class ValidationPipeline
      attr_reader max_depth: untyped

      attr_reader max_complexity: untyped

      def initialize: (query: untyped query, parse_error: untyped parse_error, operation_name_error: untyped operation_name_error, max_depth: untyped max_depth, max_complexity: untyped max_complexity) -> void

      # @return [Boolean] does this query have errors that should prevent it from running?
      def valid?: () -> untyped

      # @return [Array<GraphQL::StaticValidation::Error, GraphQL::Query::VariableValidationError>] Static validation errors for the query string
      def validation_errors: () -> untyped

      def analyzers: () -> untyped

      private

      # If the pipeline wasn't run yet, run it.
      # If it was already run, do nothing.
      def ensure_has_validated: () -> untyped

      # If there are max_* values, add them,
      # otherwise reuse the schema's list of analyzers.
      def build_analyzers: (untyped schema, untyped max_depth, untyped max_complexity) -> untyped
    end
  end
end

module GraphQL
  class Query
    class VariableValidationError < GraphQL::ExecutionError
      attr_accessor value: untyped

      attr_accessor validation_result: untyped

      def initialize: (untyped variable_ast, untyped `type`, untyped value, untyped validation_result) -> void

      def to_h: () -> untyped

      private

      def problem_fields: () -> untyped
    end
  end
end

module GraphQL
  class Dataloader
    class Source
      # Called by {Dataloader} to prepare the {Source}'s internal state
      # @api private
      def setup: (untyped dataloader) -> untyped

      attr_reader dataloader: untyped

      # @return [Dataloader::Request] a pending request for a value from `key`. Call `.load` on that object to wait for the result.
      def request: (untyped key) -> untyped

      # @return [Dataloader::Request] a pending request for a values from `keys`. Call `.load` on that object to wait for the results.
      def request_all: (untyped keys) -> untyped

      # @param key [Object] A loading key which will be passed to {#fetch} if it isn't already in the internal cache.
      # @return [Object] The result from {#fetch} for `key`. If `key` hasn't been loaded yet, the Fiber will yield until it's loaded.
      def load: (untyped key) -> untyped

      # @param keys [Array<Object>] Loading keys which will be passed to `#fetch` (or read from the internal cache).
      # @return [Object] The result from {#fetch} for `keys`. If `keys` haven't been loaded yet, the Fiber will yield until they're loaded.
      def load_all: (untyped keys) -> untyped

      # Subclasses must implement this method to return a value for each of `keys`
      # @param keys [Array<Object>] keys passed to {#load}, {#load_all}, {#request}, or {#request_all}
      # @return [Array<Object>] A loaded value for each of `keys`. The array must match one-for-one to the list of `keys`.
      def fetch: (untyped keys) -> untyped

      # Wait for a batch, if there's anything to batch.
      # Then run the batch and update the cache.
      # @return [void]
      def sync: () -> nil

      # @return [Boolean] True if this source has any pending requests for data.
      def pending?: () -> untyped

      # Called by {GraphQL::Dataloader} to resolve and pending requests to this source.
      # @api private
      # @return [void]
      def run_pending_keys: () -> untyped

      # These arguments are given to `dataloader.with(source_class, ...)`. The object
      # returned from this method is used to de-duplicate batch loads under the hood
      # by using it as a Hash key.
      #
      # By default, the arguments are all put in an Array. To customize how this source's
      # batches are merged, override this method to return something else.
      #
      # For example, if you pass `ActiveRecord::Relation`s to `.with(...)`, you could override
      # this method to call `.to_sql` on them, thus merging `.load(...)` calls when they apply
      # to equivalent relations.
      #
      # @param batch_args [Array<Object>]
      # @param batch_kwargs [Hash]
      # @return [Object]
      def self.batch_key_for: (*untyped batch_args, **untyped batch_kwargs) -> untyped

      attr_reader pending_keys: untyped

      private

      # Reads and returns the result for the key from the internal cache, or raises an error if the result was an error
      # @param key [Object] key passed to {#load} or {#load_all}
      # @return [Object] The result from {#fetch} for `key`.
      # @api private
      def result_for: (untyped key) -> untyped
    end
  end
end

module GraphQL
  class Dataloader
    # @see Source#request_all which returns an instance of this.
    class RequestAll < Request
      def initialize: (untyped source, untyped keys) -> void

      # Call this method to cause the current Fiber to wait for the results of this request.
      #
      # @return [Array<Object>] One object for each of `keys`
      def load: () -> untyped
    end
  end
end

module GraphQL
  class Dataloader
    # The default implementation of dataloading -- all no-ops.
    #
    # The Dataloader interface isn't public, but it enables
    # simple internal code while adding the option to add Dataloader.
    class NullDataloader < Dataloader
      # These are all no-ops because code was
      # executed sychronously.
      def run: () -> nil

      def run_isolated: () { () -> untyped } -> untyped

      def yield: () -> untyped

      def append_job: () { () -> untyped } -> nil
    end
  end
end

module GraphQL
  class Dataloader
    # @see Source#request which returns an instance of this
    class Request
      def initialize: (untyped source, untyped key) -> void

      # Call this method to cause the current Fiber to wait for the results of this request.
      #
      # @return [Object] the object loaded for `key`
      def load: () -> untyped
    end
  end
end

module GraphQL
  # Library entry point for performance metric reporting.
  #
  # @example Sending custom events
  #   query.trace("my_custom_event", { ... }) do
  #     # do stuff ...
  #   end
  #
  # @example Adding a tracer to a schema
  #  class MySchema < GraphQL::Schema
  #    tracer MyTracer # <= responds to .trace(key, data, &block)
  #  end
  #
  # @example Adding a tracer to a single query
  #   MySchema.execute(query_str, context: { backtrace: true })
  #
  # Events:
  #
  # Key | Metadata
  # ----|---------
  # lex | `{ query_string: String }`
  # parse | `{ query_string: String }`
  # validate | `{ query: GraphQL::Query, validate: Boolean }`
  # analyze_multiplex |  `{ multiplex: GraphQL::Execution::Multiplex }`
  # analyze_query | `{ query: GraphQL::Query }`
  # execute_multiplex | `{ multiplex: GraphQL::Execution::Multiplex }`
  # execute_query | `{ query: GraphQL::Query }`
  # execute_query_lazy | `{ query: GraphQL::Query?, multiplex: GraphQL::Execution::Multiplex? }`
  # execute_field | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
  # execute_field_lazy | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
  # authorized | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  # authorized_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  # resolve_type | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  # resolve_type_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  #
  # Note that `execute_field` and `execute_field_lazy` receive different data in different settings:
  #
  # - When using {GraphQL::Execution::Interpreter}, they receive `{field:, path:, query:}`
  # - Otherwise, they receive `{context: ...}`
  #
  module Tracing
    # Objects may include traceable to gain a `.trace(...)` method.
    # The object must have a `@tracers` ivar of type `Array<<#trace(k, d, &b)>>`.
    # @api private
    module Traceable
      # @param key [String] The name of the event in GraphQL internals
      # @param metadata [Hash] Event-related metadata (can be anything)
      # @return [Object] Must return the value of the block
      def trace: (untyped key, untyped metadata) { () -> untyped } -> untyped

      private

      # If there's a tracer at `idx`, call it and then increment `idx`.
      # Otherwise, yield.
      #
      # @param idx [Integer] Which tracer to call
      # @param key [String] The current event name
      # @param metadata [Object] The current event object
      # @return Whatever the block returns
      def call_tracers: (untyped idx, untyped key, untyped metadata) { () -> untyped } -> untyped
    end

    module NullTracer
      def self?.trace: (untyped k, untyped v) { () -> untyped } -> untyped
    end
  end
end

module Graphql
  module Generators
    # @example Generate a `GraphQL::Batch` loader by name.
    #     rails g graphql:loader RecordLoader
    class LoaderGenerator < Rails::Generators::NamedBase
      include Core

      def create_loader_file: () -> untyped
    end
  end
end

module Graphql
  module Generators
    # TODO: What other options should be supported?
    #
    # @example Generate a `GraphQL::Schema::RelayClassicMutation` by name
    #     rails g graphql:mutation CreatePostMutation
    class MutationGenerator < Rails::Generators::NamedBase
      include Core

      def create_mutation_file: () -> untyped
    end
  end
end

module Graphql
  module Generators
    # TODO: What other options should be supported?
    #
    # @example Generate a `GraphQL::Schema::RelayClassicMutation` by name
    #     rails g graphql:mutation CreatePostMutation
    class MutationCreateGenerator < OrmMutationsBase
      private

      def operation_type: () -> "create"
    end
  end
end

module Graphql
  module Generators
    module Install
      class MutationRootGenerator < Rails::Generators::Base
        include Core

        def generate: () -> untyped
      end
    end
  end
end

module Graphql
  module Generators
    # TODO: What other options should be supported?
    #
    # @example Generate a `GraphQL::Schema::RelayClassicMutation` by name
    #     rails g graphql:mutation CreatePostMutation
    class MutationUpdateGenerator < OrmMutationsBase
      private

      def operation_type: () -> "update"
    end
  end
end

module Graphql
  module Generators
    # TODO: What other options should be supported?
    #
    # @example Generate a `GraphQL::Schema::RelayClassicMutation` by name
    #     rails g graphql:mutation CreatePostMutation
    class OrmMutationsBase < Rails::Generators::NamedBase
      include Core

      include Rails::Generators::ResourceHelpers

      def create_mutation_file: () -> untyped
    end
  end
end

module Graphql
  module Generators
    module Relay
      def install_relay: () -> untyped
    end
  end
end

module Graphql
  module Generators
    class RelayGenerator < Rails::Generators::Base
      include Core

      include Relay

      def install_relay: () -> untyped
    end
  end
end

module Graphql
  module Generators
    module Core
      def self.included: (untyped base) -> untyped

      def insert_root_type: (untyped `type`, untyped name) -> untyped

      def schema_file_path: () -> ::String

      def create_dir: (untyped dir) -> untyped

      def module_namespacing_when_supported: () { () -> untyped } -> untyped

      private

      def schema_name: () -> untyped

      def parent_name: () -> untyped
    end
  end
end

module Graphql
  module Generators
    # TODO: What other options should be supported?
    #
    # @example Generate a `GraphQL::Schema::RelayClassicMutation` by name
    #     rails g graphql:mutation CreatePostMutation
    class MutationDeleteGenerator < OrmMutationsBase
      private

      def operation_type: () -> "delete"
    end
  end
end

module Graphql
  module Generators
    # Generate a union type by name
    # with the specified member types.
    #
    # ```
    # rails g graphql:union SearchResultType ImageType AudioType
    # ```
    class UnionGenerator < TypeGeneratorBase
      private

      def graphql_type: () -> "union"

      def normalized_possible_types: () -> untyped
    end
  end
end

module Graphql
  module Generators
    # Generate an object type by name,
    # with the specified fields.
    #
    # ```
    # rails g graphql:object PostType name:String!
    # ```
    #
    # Add the Node interface with `--node`.
    class ObjectGenerator < TypeGeneratorBase
      include FieldExtractor

      def self.normalize_type_expression: (untyped type_expression, mode: untyped mode, ?null: bool null) -> untyped

      private

      def graphql_type: () -> "object"
    end
  end
end

module Graphql
  module Generators
    class TypeGeneratorBase < Rails::Generators::NamedBase
      include Core

      attr_accessor graphql_type: untyped

      def create_type_file: () -> untyped

      # Take a type expression in any combination of GraphQL or Ruby styles
      # and return it in a specified output style
      # TODO: nullability / list with `mode: :graphql` doesn't work
      # @param type_expresson [String]
      # @param mode [Symbol]
      # @param null [Boolean]
      # @return [(String, Boolean)] The type expression, followed by `null:` value
      def self.normalize_type_expression: (untyped type_expression, mode: untyped mode, ?null: bool null) -> untyped

      private

      # @return [String] The user-provided type name, normalized to Ruby code
      def type_ruby_name: () -> untyped

      # @return [String] The user-provided type name, as a GraphQL name
      def type_graphql_name: () -> untyped

      # @return [String] The user-provided type name, as a file name (without extension)
      def type_file_name: () -> untyped

      # @return [Array<NormalizedField>] User-provided fields, in `(name, Ruby type name)` pairs
      def normalized_fields: () -> untyped

      def ruby_class_name: () -> untyped

      def subdirectory: () -> untyped

      class NormalizedField
        def initialize: (untyped name, untyped type_expr, untyped null) -> void

        def to_object_field: () -> ::String

        def to_input_argument: () -> ::String
      end
    end
  end
end

module Graphql
  module Generators
    # Generate an input type by name,
    # with the specified fields.
    #
    # ```
    # rails g graphql:object PostType name:string!
    # ```
    class InputGenerator < TypeGeneratorBase
      include FieldExtractor

      def self.normalize_type_expression: (untyped type_expression, mode: untyped mode, ?null: bool null) -> untyped

      private

      def graphql_type: () -> "input"

      def type_ruby_name: () -> untyped

      def type_file_name: () -> untyped
    end
  end
end

module Graphql
  module Generators
    module FieldExtractor
      def fields: () -> untyped

      def generate_column_string: (untyped column) -> ::String

      def column_type_string: (untyped column) -> untyped

      def klass: () -> untyped
    end
  end
end

module Graphql
  module Generators
    # Add GraphQL to a Rails app with `rails g graphql:install`.
    #
    # Setup a folder structure for GraphQL:
    #
    # ```
    # - app/
    #   - graphql/
    #     - resolvers/
    #     - types/
    #       - base_argument.rb
    #       - base_field.rb
    #       - base_enum.rb
    #       - base_input_object.rb
    #       - base_interface.rb
    #       - base_object.rb
    #       - base_scalar.rb
    #       - base_union.rb
    #       - query_type.rb
    #     - loaders/
    #     - mutations/
    #       - base_mutation.rb
    #     - {app_name}_schema.rb
    # ```
    #
    # (Add `.gitkeep`s by default, support `--skip-keeps`)
    #
    # Add a controller for serving GraphQL queries:
    #
    # ```
    # app/controllers/graphql_controller.rb
    # ```
    #
    # Add a route for that controller:
    #
    # ```ruby
    # # config/routes.rb
    # post "/graphql", to: "graphql#execute"
    # ```
    #
    # Accept a `--batch` option which adds `GraphQL::Batch` setup.
    #
    # Use `--skip-graphiql` to skip `graphiql-rails` installation.
    #
    # TODO: also add base classes
    class InstallGenerator < Rails::Generators::Base
      include Core

      include Relay

      def create_folder_structure: () -> untyped

      private

      def gemfile_modified?: () -> untyped

      def gem: (*untyped args) -> untyped
    end
  end
end

module Graphql
  module Generators
    # Generate an interface type by name,
    # with the specified fields.
    #
    # ```
    # rails g graphql:interface NamedEntityType name:String!
    # ```
    class InterfaceGenerator < TypeGeneratorBase
      private

      def graphql_type: () -> "interface"

      def fields: () -> untyped
    end
  end
end

module Graphql
  module Generators
    # Generate a scalar type by given name.
    #
    # ```
    # rails g graphql:scalar Date
    # ```
    class ScalarGenerator < TypeGeneratorBase
      private

      def graphql_type: () -> "scalar"
    end
  end
end

module Graphql
  module Generators
    # Generate an enum type by name, with the given values.
    # To add a `value:` option, add another value after a `:`.
    #
    # ```
    # rails g graphql:enum ProgrammingLanguage RUBY PYTHON PERL PERL6:"PERL"
    # ```
    class EnumGenerator < TypeGeneratorBase
      private

      def graphql_type: () -> "enum"

      def prepared_values: () -> untyped
    end
  end
end

module GraphQL
  # forwards-compat for argument handling
  module Ruby2Keywords
    def ruby2_keywords: () -> nil
  end

  class Error < StandardError
  end

  # This error is raised when GraphQL-Ruby encounters a situation
  # that it *thought* would never happen. Please report this bug!
  class InvariantError < Error
    def initialize: (untyped message) -> void
  end

  class RequiredImplementationMissingError < Error
  end

  def self.default_parser: () -> untyped

  attr_writer self.default_parser: untyped

  # Turn a query string or schema definition into an AST
  # @param graphql_string [String] a GraphQL query string or schema definition
  # @return [GraphQL::Language::Nodes::Document]
  def self.parse: (untyped graphql_string, ?tracer: untyped tracer) -> untyped

  # Read the contents of `filename` and parse them as GraphQL
  # @param filename [String] Path to a `.graphql` file containing IDL or query
  # @return [GraphQL::Language::Nodes::Document]
  def self.parse_file: (untyped filename) -> untyped

  def self.parse_with_racc: (untyped string, ?filename: untyped? filename, ?tracer: untyped tracer) -> untyped

  # @return [Array<GraphQL::Language::Token>]
  def self.scan: (untyped graphql_string) -> untyped

  def self.scan_with_ragel: (untyped graphql_string) -> untyped
end
