module GraphQL
  # forwards-compat for argument handling
  module Ruby2Keywords
    def ruby2_keywords: () -> nil
  end

  class Error < StandardError
  end

  # This error is raised when GraphQL-Ruby encounters a situation
  # that it *thought* would never happen. Please report this bug!
  class InvariantError < Error
    def initialize: (untyped message) -> void
  end

  class RequiredImplementationMissingError < Error
  end

  def self.default_parser: () -> untyped

  attr_writer self.default_parser: untyped

  # Turn a query string or schema definition into an AST
  # @param graphql_string [String] a GraphQL query string or schema definition
  # @return [GraphQL::Language::Nodes::Document]
  def self.parse: (untyped graphql_string, ?tracer: untyped tracer) -> untyped

  # Read the contents of `filename` and parse them as GraphQL
  # @param filename [String] Path to a `.graphql` file containing IDL or query
  # @return [GraphQL::Language::Nodes::Document]
  def self.parse_file: (untyped filename) -> untyped

  def self.parse_with_racc: (untyped string, ?filename: untyped? filename, ?tracer: untyped tracer) -> untyped

  # @return [Array<GraphQL::Language::Token>]
  def self.scan: (untyped graphql_string) -> untyped

  def self.scan_with_ragel: (untyped graphql_string) -> untyped
end

module GraphQL
  # If a field's resolve function returns a {ExecutionError},
  # the error will be inserted into the response's `"errors"` key
  # and the field will resolve to `nil`.
  class ExecutionError < GraphQL::Error
    # @return [GraphQL::Language::Nodes::Field] the field where the error occurred
    attr_accessor ast_node: untyped

    # @return [String] an array describing the JSON-path into the execution
    # response which corresponds to this error.
    attr_accessor path: untyped

    # @return [Hash] Optional data for error objects
    # @deprecated Use `extensions` instead of `options`. The GraphQL spec
    # recommends that any custom entries in an error be under the
    # `extensions` key.
    attr_accessor options: untyped

    # @return [Hash] Optional custom data for error objects which will be added
    # under the `extensions` key.
    attr_accessor extensions: untyped

    def initialize: (untyped message, ?ast_node: untyped? ast_node, ?options: untyped? options, ?extensions: untyped? extensions) -> void

    # @return [Hash] An entry for the response's "errors" key
    def to_h: () -> untyped
  end
end

module GraphQL
  class RuntimeTypeError < GraphQL::Error
  end
end

module GraphQL
  # Error raised when the value provided for a field
  # can't be resolved to one of the possible types for the field.
  class UnresolvedTypeError < GraphQL::RuntimeTypeError
    # @return [Object] The runtime value which couldn't be successfully resolved with `resolve_type`
    attr_reader value: untyped

    # @return [GraphQL::Field] The field whose value couldn't be resolved (`field.type` is type which couldn't be resolved)
    attr_reader field: untyped

    # @return [GraphQL::BaseType] The owner of `field`
    attr_reader parent_type: untyped

    # @return [Object] The return of {Schema#resolve_type} for `value`
    attr_reader resolved_type: untyped

    # @return [Array<GraphQL::BaseType>] The allowed options for resolving `value` to `field.type`
    attr_reader possible_types: untyped

    def initialize: (untyped value, untyped field, untyped parent_type, untyped resolved_type, untyped possible_types) -> void
  end
end

module GraphQL
  # Raised automatically when a field's resolve function returns `nil`
  # for a non-null field.
  class InvalidNullError < GraphQL::RuntimeTypeError
    # @return [GraphQL::BaseType] The owner of {#field}
    attr_reader parent_type: untyped

    # @return [GraphQL::Field] The field which failed to return a value
    attr_reader field: untyped

    # @return [nil, GraphQL::ExecutionError] The invalid value for this field
    attr_reader value: untyped

    def initialize: (untyped parent_type, untyped field, untyped value) -> void

    # @return [Hash] An entry for the response's "errors" key
    def to_h: () -> ::Hash[::String, untyped]

    # @deprecated always false
    def parent_error?: () -> false

    attr_accessor self.parent_class: untyped

    def self.subclass_for: (untyped parent_class) -> untyped

    def self.inspect: () -> untyped
  end
end

module GraphQL
  class AnalysisError < GraphQL::ExecutionError
  end
end

module GraphQL
  class CoercionError < GraphQL::Error
    # @return [Hash] Optional custom data for error objects which will be added
    # under the `extensions` key.
    attr_accessor extensions: untyped

    def initialize: (untyped message, ?extensions: untyped? extensions) -> void
  end
end

module GraphQL
  class InvalidNameError < GraphQL::ExecutionError
    attr_reader name: untyped

    attr_reader valid_regex: untyped

    def initialize: (untyped name, untyped valid_regex) -> void
  end
end

module GraphQL
  # This error is raised when `Types::Int` is given an input value outside of 32-bit integer range.
  #
  # For really big integer values, consider `GraphQL::Types::BigInt`
  #
  # @see GraphQL::Types::Int which raises this error
  class IntegerDecodingError < GraphQL::RuntimeTypeError
    # The value which couldn't be decoded
    attr_reader integer_value: untyped

    def initialize: (untyped value) -> void
  end
end

module GraphQL
  # This error is raised when `Types::Int` is asked to return a value outside of 32-bit integer range.
  #
  # For values outside that range, consider:
  #
  # - `ID` for database primary keys or other identifiers
  # - `GraphQL::Types::BigInt` for really big integer values
  #
  # @see GraphQL::Types::Int which raises this error
  class IntegerEncodingError < GraphQL::RuntimeTypeError
    # The value which couldn't be encoded
    attr_reader integer_value: untyped

    # @return [GraphQL::Schema::Field] The field that returned a too-big integer
    attr_reader field: untyped

    # @return [Array<String, Integer>] Where the field appeared in the GraphQL response
    attr_reader path: untyped

    def initialize: (untyped value, context: untyped context) -> void
  end
end

module GraphQL
  class StringEncodingError < GraphQL::RuntimeTypeError
    attr_reader string: untyped

    attr_reader field: untyped

    attr_reader path: untyped

    def initialize: (untyped str, context: untyped context) -> void
  end
end

module GraphQL
  # This error is raised when `Types::ISO8601Date` is asked to return a value
  # that cannot be parsed to a Ruby Date.
  #
  # @see GraphQL::Types::ISO8601Date which raises this error
  class DateEncodingError < GraphQL::RuntimeTypeError
    # The value which couldn't be encoded
    attr_reader date_value: untyped

    def initialize: (untyped value) -> void
  end
end

module GraphQL
  # Type kinds are the basic categories which a type may belong to (`Object`, `Scalar`, `Union`...)
  module TypeKinds
    # These objects are singletons, eg `GraphQL::TypeKinds::UNION`, `GraphQL::TypeKinds::SCALAR`.
    class TypeKind
      attr_reader name: untyped

      attr_reader description: untyped

      def initialize: (untyped name, ?abstract: bool abstract, ?fields: bool fields, ?wraps: bool wraps, ?input: bool input, ?description: untyped? description) -> void

      # Does this TypeKind have multiple possible implementors?
      # @deprecated Use `abstract?` instead of `resolves?`.
      def resolves?: () -> untyped

      # Is this TypeKind abstract?
      def abstract?: () -> untyped

      # Does this TypeKind have queryable fields?
      def fields?: () -> untyped

      # Does this TypeKind modify another type?
      def wraps?: () -> untyped

      # Is this TypeKind a valid query input?
      def input?: () -> untyped

      def to_s: () -> untyped

      # Is this TypeKind composed of many values?
      def composite?: () -> untyped

      def scalar?: () -> untyped

      def object?: () -> untyped

      def interface?: () -> untyped

      def union?: () -> untyped

      def enum?: () -> untyped

      def input_object?: () -> untyped

      def list?: () -> untyped

      def non_null?: () -> untyped
    end

    TYPE_KINDS: ::Array[untyped]
  end
end

module GraphQL
  class NameValidator
    VALID_NAME_REGEX: ::Regexp

    def self.validate!: (untyped name) -> untyped
  end
end

module GraphQL
  module Language
    # @api private
    def self.serialize: (untyped value) -> untyped
  end
end

module GraphQL
  class Railtie < Rails::Railtie
  end
end

module GraphQL
  # Library entry point for performance metric reporting.
  #
  # @example Sending custom events
  #   query.trace("my_custom_event", { ... }) do
  #     # do stuff ...
  #   end
  #
  # @example Adding a tracer to a schema
  #  class MySchema < GraphQL::Schema
  #    tracer MyTracer # <= responds to .trace(key, data, &block)
  #  end
  #
  # @example Adding a tracer to a single query
  #   MySchema.execute(query_str, context: { backtrace: true })
  #
  # Events:
  #
  # Key | Metadata
  # ----|---------
  # lex | `{ query_string: String }`
  # parse | `{ query_string: String }`
  # validate | `{ query: GraphQL::Query, validate: Boolean }`
  # analyze_multiplex |  `{ multiplex: GraphQL::Execution::Multiplex }`
  # analyze_query | `{ query: GraphQL::Query }`
  # execute_multiplex | `{ multiplex: GraphQL::Execution::Multiplex }`
  # execute_query | `{ query: GraphQL::Query }`
  # execute_query_lazy | `{ query: GraphQL::Query?, multiplex: GraphQL::Execution::Multiplex? }`
  # execute_field | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
  # execute_field_lazy | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
  # authorized | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  # authorized_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  # resolve_type | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  # resolve_type_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
  #
  # Note that `execute_field` and `execute_field_lazy` receive different data in different settings:
  #
  # - When using {GraphQL::Execution::Interpreter}, they receive `{field:, path:, query:}`
  # - Otherwise, they receive `{context: ...}`
  #
  module Tracing
    # Objects may include traceable to gain a `.trace(...)` method.
    # The object must have a `@tracers` ivar of type `Array<<#trace(k, d, &b)>>`.
    # @api private
    module Traceable
      # @param key [String] The name of the event in GraphQL internals
      # @param metadata [Hash] Event-related metadata (can be anything)
      # @return [Object] Must return the value of the block
      def trace: (untyped key, untyped metadata) { () -> untyped } -> untyped

      private

      # If there's a tracer at `idx`, call it and then increment `idx`.
      # Otherwise, yield.
      #
      # @param idx [Integer] Which tracer to call
      # @param key [String] The current event name
      # @param metadata [Object] The current event object
      # @return Whatever the block returns
      def call_tracers: (untyped idx, untyped key, untyped metadata) { () -> untyped } -> untyped
    end

    module NullTracer
      def self?.trace: (untyped k, untyped v) { () -> untyped } -> untyped
    end
  end
end

module GraphQL
  module Dig
    # implemented using the old activesupport #dig instead of the ruby built-in
    # so we can use some of the magic in Schema::InputObject and Interpreter::Arguments
    # to handle stringified/symbolized keys.
    #
    # @param args [Array<[String, Symbol>] Retrieves the value object corresponding to the each key objects repeatedly
    # @return [Object]
    def dig: (untyped own_key, *untyped rest_keys) -> untyped
  end
end

module GraphQL
  module Execution
    # @api private
    class Skip < GraphQL::Error
    end

    # Just a singleton for implementing {Query::Context#skip}
    # @api private
    SKIP: untyped
  end
end

module GraphQL
  # A GraphQL schema which may be queried with {GraphQL::Query}.
  #
  # The {Schema} contains:
  #
  #  - types for exposing your application
  #  - query analyzers for assessing incoming queries (including max depth & max complexity restrictions)
  #  - execution strategies for running incoming queries
  #
  # Schemas start with root types, {Schema#query}, {Schema#mutation} and {Schema#subscription}.
  # The schema will traverse the tree of fields & types, using those as starting points.
  # Any undiscoverable types may be provided with the `types` configuration.
  #
  # Schemas can restrict large incoming queries with `max_depth` and `max_complexity` configurations.
  # (These configurations can be overridden by specific calls to {Schema#execute})
  #
  # Schemas can specify how queries should be executed against them.
  # `query_execution_strategy`, `mutation_execution_strategy` and `subscription_execution_strategy`
  # each apply to corresponding root types.
  #  #
  # @example defining a schema
  #   class MySchema < GraphQL::Schema
  #     query QueryType
  #     # If types are only connected by way of interfaces, they must be added here
  #     orphan_types ImageType, AudioType
  #   end
  #
  class Schema
    extend GraphQL::Schema::Member::HasAstNode

    extend GraphQL::Schema::FindInheritedValue

    class DuplicateTypeNamesError < GraphQL::Error
      def initialize: (type_name: untyped type_name, first_definition: untyped first_definition, second_definition: untyped second_definition, path: untyped path) -> void
    end

    class DuplicateNamesError < GraphQL::Error
    end

    class UnresolvedLateBoundTypeError < GraphQL::Error
      attr_reader type: untyped

      def initialize: (type: untyped `type`) -> void
    end

    # Error that is raised when [#Schema#from_definition] is passed an invalid schema definition string.
    class InvalidDocumentError < Error
    end

    # Create schema with the result of an introspection query.
    # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
    # @return [Class<GraphQL::Schema>] the schema described by `input`
    def self.from_introspection: (untyped introspection_result) -> untyped

    # Create schema from an IDL schema or file containing an IDL definition.
    # @param definition_or_path [String] A schema definition string, or a path to a file containing the definition
    # @param default_resolve [<#call(type, field, obj, args, ctx)>] A callable for handling field resolution
    # @param parser [Object] An object for handling definition string parsing (must respond to `parse`)
    # @param using [Hash] Plugins to attach to the created schema with `use(key, value)`
    # @return [Class] the schema described by `document`
    def self.from_definition: (untyped definition_or_path, ?default_resolve: untyped? default_resolve, ?parser: untyped parser, ?using: ::Hash[untyped, untyped] using) -> untyped

    def self.deprecated_graphql_definition: () -> untyped

    # @return [GraphQL::Subscriptions]
    attr_accessor self.subscriptions: untyped

    # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
    # @see {#as_json}
    # @return [String]
    def self.to_json: (**untyped args) -> untyped

    # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [Hash] GraphQL result
    def self.as_json: (?only: untyped? only, ?except: untyped? except, ?context: ::Hash[untyped, untyped] context) -> untyped

    # Return the GraphQL IDL for the schema
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [String]
    def self.to_definition: (?only: untyped? only, ?except: untyped? except, ?context: ::Hash[untyped, untyped] context) -> untyped

    # Return the GraphQL::Language::Document IDL AST for the schema
    # @return [GraphQL::Language::Document]
    def self.to_document: () -> untyped

    # @return [String, nil]
    def self.description: (?untyped? new_description) -> untyped

    def self.find: (untyped path) -> untyped

    def self.default_filter: () -> untyped

    def self.default_mask: (?untyped? new_mask) -> untyped

    def self.static_validator: () -> untyped

    def self.use: (untyped plugin, **untyped kwargs) -> untyped

    def self.plugins: () -> untyped

    # Build a map of `{ name => type }` and return it
    # @return [Hash<String => Class>] A dictionary of type classes by their GraphQL name
    # @see get_type Which is more efficient for finding _one type_ by name, because it doesn't merge hashes.
    def self.types: (?untyped context) -> untyped

    # @param type_name [String]
    # @return [Module, nil] A type, or nil if there's no type called `type_name`
    def self.get_type: (untyped type_name, ?untyped context) -> untyped

    # @api private
    attr_writer self.connections: untyped

    # @return [GraphQL::Pagination::Connections] if installed
    def self.connections: () -> untyped

    def self.new_connections?: () -> untyped

    def self.query: (?untyped? new_query_object) -> untyped

    def self.mutation: (?untyped? new_mutation_object) -> untyped

    def self.subscription: (?untyped? new_subscription_object) -> untyped

    # @see [GraphQL::Schema::Warden] Restricted access to root types
    # @return [GraphQL::ObjectType, nil]
    def self.root_type_for_operation: (untyped operation) -> untyped

    def self.root_types: () -> untyped

    # @param type [Module] The type definition whose possible types you want to see
    # @return [Hash<String, Module>] All possible types, if no `type` is given.
    # @return [Array<Module>] Possible types for `type`, if it's given.
    def self.possible_types: (?untyped? `type`, ?untyped context) -> untyped

    def self.union_memberships: (?untyped? `type`) -> untyped

    # @api private
    # @see GraphQL::Dataloader
    def self.dataloader_class: () -> untyped

    attr_writer self.dataloader_class: untyped

    def self.references_to: (?untyped? to_type, ?from: untyped? from) -> untyped

    def self.type_from_ast: (untyped ast_node, ?context: untyped? context) -> untyped

    def self.get_field: (untyped type_or_name, untyped field_name, ?untyped context) -> untyped

    def self.get_fields: (untyped `type`, ?untyped context) -> untyped

    def self.introspection: (?untyped? new_introspection_namespace) -> untyped

    def self.introspection_system: () -> untyped

    def self.cursor_encoder: (?untyped? new_encoder) -> untyped

    def self.default_max_page_size: (?untyped? new_default_max_page_size) -> untyped

    def self.query_execution_strategy: (?untyped? new_query_execution_strategy) -> untyped

    def self.mutation_execution_strategy: (?untyped? new_mutation_execution_strategy) -> untyped

    def self.subscription_execution_strategy: (?untyped? new_subscription_execution_strategy) -> untyped

    attr_writer self.validate_timeout: untyped

    def self.validate_timeout: (?untyped? new_validate_timeout) -> untyped

    # Validate a query string according to this schema.
    # @param string_or_document [String, GraphQL::Language::Nodes::Document]
    # @return [Array<GraphQL::StaticValidation::Error >]
    def self.validate: (untyped string_or_document, ?rules: untyped? rules, ?context: untyped? context) -> untyped

    attr_writer self.validate_max_errors: untyped

    def self.validate_max_errors: (?untyped? new_validate_max_errors) -> untyped

    attr_writer self.max_complexity: untyped

    def self.max_complexity: (?untyped? max_complexity) -> untyped

    attr_writer self.analysis_engine: untyped

    def self.analysis_engine: () -> untyped

    def self.using_ast_analysis?: () -> true

    def self.interpreter?: () -> true

    attr_writer self.interpreter: untyped

    def self.error_bubbling: (?untyped? new_error_bubbling) -> untyped

    attr_writer self.error_bubbling: untyped

    attr_writer self.max_depth: untyped

    def self.max_depth: (?untyped? new_max_depth) -> untyped

    def self.disable_introspection_entry_points: () -> untyped

    def self.disable_schema_introspection_entry_point: () -> untyped

    def self.disable_type_introspection_entry_point: () -> untyped

    def self.disable_introspection_entry_points?: () -> untyped

    def self.disable_schema_introspection_entry_point?: () -> untyped

    def self.disable_type_introspection_entry_point?: () -> untyped

    def self.orphan_types: (*untyped new_orphan_types) -> untyped

    def self.default_execution_strategy: () -> untyped

    def self.default_analysis_engine: () -> untyped

    def self.context_class: (?untyped? new_context_class) -> untyped

    def self.rescue_from: (*untyped err_classes) { () -> untyped } -> untyped

    NEW_HANDLER_HASH: untyped

    def self.error_handlers: () -> untyped

    # @api private
    def self.handle_or_reraise: (untyped context, untyped err) -> untyped

    # rubocop:disable Lint/DuplicateMethods
    module ResolveTypeWithType
      def resolve_type: (untyped `type`, untyped obj, untyped ctx) -> untyped
    end

    def self.resolve_type: (untyped `type`, untyped obj, untyped ctx) -> untyped

    def self.inherited: (untyped child_class) -> untyped

    def self.object_from_id: (untyped node_id, untyped ctx) -> untyped

    def self.id_from_object: (untyped object, untyped `type`, untyped ctx) -> untyped

    def self.visible?: (untyped member, untyped ctx) -> untyped

    def self.accessible?: (untyped member, untyped ctx) -> untyped

    # This hook is called when a client tries to access one or more
    # fields that fail the `accessible?` check.
    #
    # By default, an error is added to the response. Override this hook to
    # track metrics or return a different error to the client.
    #
    # @param error [InaccessibleFieldsError] The analysis error for this check
    # @return [AnalysisError, nil] Return an error to skip the query
    def self.inaccessible_fields: (untyped error) -> untyped

    # This hook is called when an object fails an `authorized?` check.
    # You might report to your bug tracker here, so you can correct
    # the field resolvers not to return unauthorized objects.
    #
    # By default, this hook just replaces the unauthorized object with `nil`.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized object (accessible as `unauthorized_error.object`). If an
    # error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedError]
    # @return [Object] The returned object will be put in the GraphQL response
    def self.unauthorized_object: (untyped unauthorized_error) -> nil

    # This hook is called when a field fails an `authorized?` check.
    #
    # By default, this hook implements the same behavior as unauthorized_object.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized field . If an error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedFieldError]
    # @return [Field] The returned field will be put in the GraphQL response
    def self.unauthorized_field: (untyped unauthorized_error) -> untyped

    def self.type_error: (untyped type_error, untyped ctx) -> untyped

    # A function to call when {#execute} receives an invalid query string
    #
    # The default is to add the error to `context.errors`
    # @param err [GraphQL::ParseError] The error encountered during parsing
    # @param ctx [GraphQL::Query::Context] The context for the query where the error occurred
    # @return void
    def self.parse_error: (untyped parse_err, untyped ctx) -> untyped

    def self.lazy_resolve: (untyped lazy_class, untyped value_method) -> untyped

    def self.instrument: (untyped instrument_step, untyped instrumenter, ?::Hash[untyped, untyped] options) -> untyped

    # Add several directives at once
    # @param new_directives [Class]
    def self.directives: (*untyped new_directives) -> untyped

    # Attach a single directive to this schema
    # @param new_directive [Class]
    # @return void
    def self.directive: (untyped new_directive) -> untyped

    def self.default_directives: () -> untyped

    def self.tracer: (untyped new_tracer) -> untyped

    def self.tracers: () -> untyped

    def self.query_analyzer: (untyped new_analyzer) -> untyped

    def self.query_analyzers: () -> untyped

    def self.multiplex_analyzer: (untyped new_analyzer) -> untyped

    def self.multiplex_analyzers: () -> untyped

    def self.sanitized_printer: (?untyped? new_sanitized_printer) -> untyped

    # Execute a query on itself.
    # @see {Query#initialize} for arguments.
    # @return [Hash] query result, ready to be serialized as JSON
    def self.execute: (?untyped? query_str, **untyped kwargs) -> untyped

    # Execute several queries on itself, concurrently.
    #
    # @example Run several queries at once
    #   context = { ... }
    #   queries = [
    #     { query: params[:query_1], variables: params[:variables_1], context: context },
    #     { query: params[:query_2], variables: params[:variables_2], context: context },
    #   ]
    #   results = MySchema.multiplex(queries)
    #   render json: {
    #     result_1: results[0],
    #     result_2: results[1],
    #   }
    #
    # @see {Query#initialize} for query keyword arguments
    # @see {Execution::Multiplex#run_all} for multiplex keyword arguments
    # @param queries [Array<Hash>] Keyword arguments for each query
    # @param context [Hash] Multiplex-level context
    # @return [Array<Hash>] One result for each query in the input
    def self.multiplex: (untyped queries, **untyped kwargs) -> untyped

    def self.instrumenters: () -> untyped

    # @api private
    def self.add_subscription_extension_if_necessary: () -> untyped

    def self.query_stack_error: (untyped query, untyped err) -> untyped

    # Call the given block at the right time, either:
    # - Right away, if `value` is not registered with `lazy_resolve`
    # - After resolving `value`, if it's registered with `lazy_resolve` (eg, `Promise`)
    # @api private
    def self.after_lazy: (untyped value) { (untyped) -> untyped } -> untyped

    # Override this method to handle lazy objects in a custom way.
    # @param value [Object] an instance of a class registered with {.lazy_resolve}
    # @return [Object] A GraphQL-ready (non-lazy) object
    # @api private
    def self.sync_lazy: (untyped value) -> untyped

    # @return [Symbol, nil] The method name to lazily resolve `obj`, or nil if `obj`'s class wasn't registered with {#lazy_resolve}.
    def self.lazy_method_name: (untyped obj) -> untyped

    # @return [Boolean] True if this object should be lazily resolved
    def self.lazy?: (untyped obj) -> untyped

    # Return a lazy if any of `maybe_lazies` are lazy,
    # otherwise, call the block eagerly and return the result.
    # @param maybe_lazies [Array]
    # @api private
    def self.after_any_lazies: (untyped maybe_lazies) { (untyped) -> untyped } -> untyped

    private

    # @param t [Module, Array<Module>]
    # @return [void]
    def self.add_type_and_traverse: (untyped t, root: untyped root) -> untyped

    def self.lazy_methods: () -> untyped

    def self.own_types: () -> untyped

    def self.non_introspection_types: () -> untyped

    def self.own_plugins: () -> untyped

    def self.own_orphan_types: () -> untyped

    def self.own_possible_types: () -> untyped

    def self.own_union_memberships: () -> untyped

    def self.own_directives: () -> untyped

    def self.own_instrumenters: () -> untyped

    def self.own_tracers: () -> untyped

    def self.own_query_analyzers: () -> untyped

    def self.own_multiplex_analyzers: () -> untyped
  end
end

module GraphQL
  # A combination of query string and {Schema} instance which can be reduced to a {#result}.
  class Query
    include Tracing::Traceable

    extend Forwardable

    class OperationNameMissingError < GraphQL::ExecutionError
      def initialize: (untyped name) -> void
    end

    attr_reader schema: untyped

    attr_reader context: untyped

    attr_reader provided_variables: untyped

    # The value for root types
    attr_accessor root_value: untyped

    # @return [nil, String] The operation name provided by client or the one inferred from the document. Used to determine which operation to run.
    attr_accessor operation_name: untyped

    # @return [Boolean] if false, static validation is skipped (execution behavior for invalid queries is undefined)
    attr_accessor validate: untyped

    attr_writer query_string: untyped

    # @return [GraphQL::Language::Nodes::Document]
    def document: () -> untyped

    def inspect: () -> "query ..."

    # @return [String, nil] The name of the operation to run (may be inferred)
    def selected_operation_name: () -> (nil | untyped)

    # @return [String, nil] the triggered event, if this query is a subscription update
    attr_reader subscription_topic: untyped

    attr_reader tracers: untyped

    # Prepare query `query_string` on `schema`
    # @param schema [GraphQL::Schema]
    # @param query_string [String]
    # @param context [#[]] an arbitrary hash of values which you can access in {GraphQL::Field#resolve}
    # @param variables [Hash] values for `$variables` in the query
    # @param operation_name [String] if the query string contains many operations, this is the one which should be executed
    # @param root_value [Object] the object used to resolve fields on the root type
    # @param max_depth [Numeric] the maximum number of nested selections allowed for this query (falls back to schema-level value)
    # @param max_complexity [Numeric] the maximum field complexity for this query (falls back to schema-level value)
    # @param except [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns truthy
    # @param only [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns false
    def initialize: (untyped schema, ?untyped? query_string, ?query: untyped? query, ?document: untyped? document, ?context: untyped? context, ?variables: untyped? variables, ?validate: bool validate, ?subscription_topic: untyped? subscription_topic, ?operation_name: untyped? operation_name, ?root_value: untyped? root_value, ?max_depth: untyped max_depth, ?max_complexity: untyped max_complexity, ?except: untyped? except, ?only: untyped? only, ?warden: untyped? warden) -> void

    # If a document was provided to `GraphQL::Schema#execute` instead of the raw query string, we will need to get it from the document
    def query_string: () -> untyped

    def interpreter?: () -> true

    attr_accessor multiplex: untyped

    def subscription_update?: () -> untyped

    # A lookahead for the root selections of this query
    # @return [GraphQL::Execution::Lookahead]
    def lookahead: () -> untyped

    # @api private
    def result_values=: (untyped result_hash) -> untyped

    # @api private
    attr_reader result_values: untyped

    def fragments: () -> untyped

    def operations: () -> untyped

    # Get the result for this query, executing it once
    # @return [Hash] A GraphQL response, with `"data"` and/or `"errors"` keys
    def result: () -> untyped

    def executed?: () -> untyped

    def static_errors: () -> untyped

    # This is the operation to run for this query.
    # If more than one operation is present, it must be named at runtime.
    # @return [GraphQL::Language::Nodes::OperationDefinition, nil]
    def selected_operation: () -> untyped

    # Determine the values for variables of this query, using default values
    # if a value isn't provided at runtime.
    #
    # If some variable is invalid, errors are added to {#validation_errors}.
    #
    # @return [GraphQL::Query::Variables] Variables to apply to this query
    def variables: () -> untyped

    # Node-level cache for calculating arguments. Used during execution and query analysis.
    # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
    # @param definition [GraphQL::Schema::Field]
    # @param parent_object [GraphQL::Schema::Object]
    # @return Hash{Symbol => Object}
    def arguments_for: (untyped ast_node, untyped definition, ?parent_object: untyped? parent_object) -> untyped

    def arguments_cache: () -> untyped

    # A version of the given query string, with:
    # - Variables inlined to the query
    # - Strings replaced with `<REDACTED>`
    # @return [String, nil] Returns nil if the query is invalid.
    def sanitized_query_string: (?inline_variables: bool inline_variables) -> untyped

    # This contains a few components:
    #
    # - The selected operation name (or `anonymous`)
    # - The fingerprint of the query string
    # - The number of given variables (for readability)
    # - The fingerprint of the given variables
    #
    # This fingerprint can be used to track runs of the same operation-variables combination over time.
    #
    # @see operation_fingerprint
    # @see variables_fingerprint
    # @return [String] An opaque hash identifying this operation-variables combination
    def fingerprint: () -> untyped

    # @return [String] An opaque hash for identifying this query's given query string and selected operation
    def operation_fingerprint: () -> untyped

    # @return [String] An opaque hash for identifying this query's given a variable values (not including defaults)
    def variables_fingerprint: () -> untyped

    def validation_pipeline: () -> untyped

    attr_accessor analysis_errors: untyped

    def valid?: () -> untyped

    def warden: () -> untyped

    # @param abstract_type [GraphQL::UnionType, GraphQL::InterfaceType]
    # @param value [Object] Any runtime value
    # @return [GraphQL::ObjectType, nil] The runtime type of `value` from {Schema#resolve_type}
    # @see {#possible_types} to apply filtering from `only` / `except`
    def resolve_type: (untyped abstract_type, ?::Symbol value) -> untyped

    def mutation?: () -> untyped

    def query?: () -> untyped

    # @return [void]
    def merge_filters: (?only: untyped? only, ?except: untyped? except) -> nil

    def subscription?: () -> untyped

    # @api private
    def handle_or_reraise: (untyped err) -> untyped

    private

    def find_operation: (untyped operations, untyped operation_name) -> untyped

    def prepare_ast: () -> untyped

    # Since the query string is processed at the last possible moment,
    # any internal values which depend on it should be accessed within this wrapper.
    def with_prepared_ast: () { () -> untyped } -> untyped
  end
end

module GraphQL
  # This plugin supports Fiber-based concurrency, along with {GraphQL::Dataloader::Source}.
  #
  # @example Installing Dataloader
  #
  #   class MySchema < GraphQL::Schema
  #     use GraphQL::Dataloader
  #   end
  #
  # @example Waiting for batch-loaded data in a GraphQL field
  #
  #   field :team, Types::Team, null: true
  #
  #   def team
  #     dataloader.with(Sources::Record, Team).load(object.team_id)
  #   end
  #
  class Dataloader
    attr_accessor self.default_nonblocking: untyped

    AsyncDataloader: untyped

    def self.use: (untyped schema, ?nonblocking: untyped? nonblocking) -> untyped

    # Call the block with a Dataloader instance,
    # then run all enqueued jobs and return the result of the block.
    def self.with_dataloading: () { () -> untyped } -> untyped

    def initialize: (?nonblocking: untyped nonblocking) -> void

    def nonblocking?: () -> untyped

    # Get a Source instance from this dataloader, for calling `.load(...)` or `.request(...)` on.
    #
    # @param source_class [Class<GraphQL::Dataloader::Source]
    # @param batch_parameters [Array<Object>]
    # @return [GraphQL::Dataloader::Source] An instance of {source_class}, initialized with `self, *batch_parameters`,
    #   and cached for the lifetime of this {Multiplex}.
    # truffle-ruby wasn't doing well with the implementation below
    # def with: (untyped source_class, *untyped batch_args) -> untyped

    def with: (untyped source_class, *untyped batch_args, **untyped batch_kwargs) -> untyped

    # Tell the dataloader that this fiber is waiting for data.
    #
    # Dataloader will resume the fiber after the requested data has been loaded (by another Fiber).
    #
    # @return [void]
    def yield: () -> nil

    # @api private Nothing to see here
    def append_job: () { () -> untyped } -> nil

    # Use a self-contained queue for the work in the block.
    def run_isolated: () { () -> untyped } -> untyped

    # @api private Move along, move along
    def run: () -> nil

    def join_queues: (untyped previous_queue, untyped next_queue) -> untyped

    private

    # If there are pending sources, return a fiber for running them.
    # Otherwise, return `nil`.
    #
    # @return [Fiber, nil]
    def create_source_fiber: () -> untyped

    def resume: (untyped fiber) -> untyped

    # Copies the thread local vars into the fiber thread local vars. Many
    # gems (such as RequestStore, MiniRacer, etc.) rely on thread local vars
    # to keep track of execution context, and without this they do not
    # behave as expected.
    #
    # @see https://github.com/rmosolgo/graphql-ruby/issues/3449
    def spawn_fiber: () { () -> untyped } -> untyped
  end
end

module GraphQL
  # @api private
  class Filter
    def initialize: (?only: untyped? only, ?except: untyped? except) -> void

    # Returns true if `member, ctx` passes this filter
    def call: (untyped member, untyped ctx) -> untyped

    def merge: (?only: untyped? only, ?except: untyped? except) -> untyped

    private

    class MergedOnly
      def initialize: (untyped first, untyped second) -> void

      def call: (untyped member, untyped ctx) -> untyped

      def self.build: (untyped onlies) -> untyped
    end

    class MergedExcept < MergedOnly
      def call: (untyped member, untyped ctx) -> untyped
    end
  end
end

module GraphQL
  class Schema
    BUILT_IN_TYPES: ::Hash[::String, untyped]
  end
end

module GraphQL
  class Schema
    # Used to convert your {GraphQL::Schema} to a GraphQL schema string
    #
    # @example print your schema to standard output (via helper)
    #   puts GraphQL::Schema::Printer.print_schema(MySchema)
    #
    # @example print your schema to standard output
    #   puts GraphQL::Schema::Printer.new(MySchema).print_schema
    #
    # @example print a single type to standard output
    #   class Types::Query < GraphQL::Schema::Object
    #     description "The query root of this schema"
    #
    #     field :post, Types::Post, null: true
    #   end
    #
    #   class Types::Post < GraphQL::Schema::Object
    #     description "A blog post"
    #
    #     field :id, ID, null: false
    #     field :title, String, null: false
    #     field :body, String, null: false
    #   end
    #
    #   class MySchema < GraphQL::Schema
    #     query(Types::Query)
    #   end
    #
    #   printer = GraphQL::Schema::Printer.new(MySchema)
    #   puts printer.print_type(Types::Post)
    #
    class Printer < GraphQL::Language::Printer
      attr_reader schema: untyped

      attr_reader warden: untyped

      # @param schema [GraphQL::Schema]
      # @param context [Hash]
      # @param only [<#call(member, ctx)>]
      # @param except [<#call(member, ctx)>]
      # @param introspection [Boolean] Should include the introspection types in the string?
      def initialize: (untyped schema, ?context: untyped? context, ?only: untyped? only, ?except: untyped? except, ?introspection: bool introspection) -> void

      # Return the GraphQL schema string for the introspection type system
      def self.print_introspection_schema: () -> untyped

      # Return a GraphQL schema string for the defined types in the schema
      # @param schema [GraphQL::Schema]
      # @param context [Hash]
      # @param only [<#call(member, ctx)>]
      # @param except [<#call(member, ctx)>]
      def self.print_schema: (untyped schema, **untyped args) -> untyped

      # Return a GraphQL schema string for the defined types in the schema
      def print_schema: () -> untyped

      def print_type: (untyped `type`) -> untyped

      class IntrospectionPrinter < GraphQL::Language::Printer
        def print_schema_definition: (untyped schema) -> ::String
      end
    end
  end
end

module GraphQL
  class Schema
    # You can use the result of {GraphQL::Introspection::INTROSPECTION_QUERY}
    # to make a schema. This schema is missing some important details like
    # `resolve` functions, but it does include the full type system,
    # so you can use it to validate queries.
    #
    # @see GraphQL::Schema.from_introspection for a public API
    module Loader
      extend ::GraphQL::Schema::Loader

      # Create schema with the result of an introspection query.
      # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
      # @return [Class] the schema described by `input`
      def load: (untyped introspection_result) -> untyped

      NullScalarCoerce: untyped

      private

      def self.resolve_type: (untyped types, untyped `type`) -> untyped

      def self.extract_default_value: (untyped default_value_str, untyped input_value_ast) -> untyped

      def self.define_type: (untyped `type`, untyped type_resolver) -> untyped

      def self.define_directive: (untyped directive, untyped type_resolver) -> untyped

      public

      def self.build_fields: (untyped type_defn, untyped fields, untyped type_resolver) -> untyped

      def self.build_arguments: (untyped arg_owner, untyped args, untyped type_resolver) -> untyped
    end
  end
end

module GraphQL
  module Introspection
    def self.query: (?include_deprecated_args: bool include_deprecated_args, ?include_schema_description: bool include_schema_description, ?include_is_repeatable: bool include_is_repeatable, ?include_specified_by_url: bool include_specified_by_url) -> ::String
  end
end

module GraphQL
  VERSION: "2.0.5"
end

module GraphQL
  class Subscriptions
    # Raised when either:
    # - the triggered `event_name` doesn't match a field in the schema; or
    # - one or more arguments don't match the field arguments
    class InvalidTriggerError < GraphQL::Error
    end

    # Raised when either:
    # - An initial subscription didn't have a value for `context[subscription_scope]`
    # - Or, an update didn't pass `.trigger(..., scope:)`
    # When raised, the initial subscription or update fails completely.
    class SubscriptionScopeMissingError < GraphQL::Error
    end

    # @see {Subscriptions#initialize} for options, concrete implementations may add options.
    def self.use: (untyped defn, ?::Hash[untyped, untyped] options) -> nil

    # @param schema [Class] the GraphQL schema this manager belongs to
    def initialize: (schema: untyped schema, ?broadcast: bool broadcast, ?default_broadcastable: bool default_broadcastable, **untyped rest) -> void

    # @return [Boolean] Used when fields don't have `broadcastable:` explicitly set
    attr_reader default_broadcastable: untyped

    # Fetch subscriptions matching this field + arguments pair
    # And pass them off to the queue.
    # @param event_name [String]
    # @param args [Hash<String, Symbol => Object]
    # @param object [Object]
    # @param scope [Symbol, String]
    # @param context [Hash]
    # @return [void]
    def trigger: (untyped event_name, untyped args, untyped object, ?scope: untyped? scope, ?context: ::Hash[untyped, untyped] context) -> untyped

    # `event` was triggered on `object`, and `subscription_id` was subscribed,
    # so it should be updated.
    #
    # Load `subscription_id`'s GraphQL data, re-evaluate the query and return the result.
    #
    # @param subscription_id [String]
    # @param event [GraphQL::Subscriptions::Event] The event which was triggered
    # @param object [Object] The value for the subscription field
    # @return [GraphQL::Query::Result]
    def execute_update: (untyped subscription_id, untyped event, untyped object) -> (nil | untyped)

    # Run the update query for this subscription and deliver it
    # @see {#execute_update}
    # @see {#deliver}
    # @return [void]
    def execute: (untyped subscription_id, untyped event, untyped object) -> untyped

    # Event `event` occurred on `object`,
    # Update all subscribers.
    # @param event [Subscriptions::Event]
    # @param object [Object]
    # @return [void]
    def execute_all: (untyped event, untyped object) -> untyped

    # The system wants to send an update to this subscription.
    # Read its data and return it.
    # @param subscription_id [String]
    # @return [Hash] Containing required keys
    def read_subscription: (untyped subscription_id) -> untyped

    # A subscription query was re-evaluated, returning `result`.
    # The result should be send to `subscription_id`.
    # @param subscription_id [String]
    # @param result [Hash]
    # @return [void]
    def deliver: (untyped subscription_id, untyped result) -> untyped

    # `query` was executed and found subscriptions to `events`.
    # Update the database to reflect this new state.
    # @param query [GraphQL::Query]
    # @param events [Array<GraphQL::Subscriptions::Event>]
    # @return [void]
    def write_subscription: (untyped query, untyped events) -> untyped

    # A subscription was terminated server-side.
    # Clean up the database.
    # @param subscription_id [String]
    # @return void.
    def delete_subscription: (untyped subscription_id) -> untyped

    # @return [String] A new unique identifier for a subscription
    def build_id: () -> untyped

    # Convert a user-provided event name or argument
    # to the equivalent in GraphQL.
    #
    # By default, it converts the identifier to camelcase.
    # Override this in a subclass to change the transformation.
    #
    # @param event_or_arg_name [String, Symbol]
    # @return [String]
    def normalize_name: (untyped event_or_arg_name) -> untyped

    # @return [Boolean] if true, then a query like this one would be broadcasted
    def broadcastable?: (untyped query_str, **untyped query_options) -> untyped

    private

    # Recursively normalize `args` as belonging to `arg_owner`:
    # - convert symbols to strings,
    # - if needed, camelize the string (using {#normalize_name})
    # @param arg_owner [GraphQL::Field, GraphQL::BaseType]
    # @param args [Hash, Array, Any] some GraphQL input value to coerce as `arg_owner`
    # @return [Any] normalized arguments value
    def normalize_arguments: (untyped event_name, untyped arg_owner, untyped args, untyped context) -> untyped
  end
end

module GraphQL
  class ParseError < GraphQL::Error
    attr_reader line: untyped

    attr_reader col: untyped

    attr_reader query: untyped

    def initialize: (untyped message, untyped line, untyped col, untyped query, ?filename: untyped? filename) -> void

    def to_h: () -> ::Hash[::String, untyped]
  end
end

module GraphQL
  # Wrap unhandled errors with {TracedError}.
  #
  # {TracedError} provides a GraphQL backtrace with arguments and return values.
  # The underlying error is available as {TracedError#cause}.
  #
  # @example toggling backtrace annotation
  #   class MySchema < GraphQL::Schema
  #     if Rails.env.development? || Rails.env.test?
  #       use GraphQL::Backtrace
  #     end
  #   end
  #
  class Backtrace
    include Enumerable

    extend Forwardable

    def self.use: (untyped schema_defn) -> untyped

    def initialize: (untyped context, ?value: untyped? value) -> void

    def inspect: () -> untyped

    alias to_s inspect

    def to_a: () -> untyped

    # Used for internal bookkeeping
    # @api private
    class Frame
      attr_reader path: untyped

      attr_reader query: untyped

      attr_reader ast_node: untyped

      attr_reader object: untyped

      attr_reader field: untyped

      attr_reader arguments: untyped

      attr_reader parent_frame: untyped

      def initialize: (path: untyped path, query: untyped query, ast_node: untyped ast_node, object: untyped object, field: untyped field, arguments: untyped arguments, parent_frame: untyped parent_frame) -> void
    end
  end
end

module GraphQL
  # When an `authorized?` hook returns false, this error is used to communicate the failure.
  # It's passed to {Schema.unauthorized_object}.
  #
  # Alternatively, custom code in `authorized?` may raise this error. It will be routed the same way.
  class UnauthorizedError < GraphQL::Error
    # @return [Object] the application object that failed the authorization check
    attr_reader object: untyped

    # @return [Class] the GraphQL object type whose `.authorized?` method was called (and returned false)
    attr_reader type: untyped

    # @return [GraphQL::Query::Context] the context for the current query
    attr_accessor context: untyped

    def initialize: (?untyped? message, ?object: untyped? object, ?type: untyped? `type`, ?context: untyped? context) -> void
  end
end

module GraphQL
  class UnauthorizedFieldError < GraphQL::UnauthorizedError
    # @return [Field] the field that failed the authorization check
    attr_accessor field: untyped

    def initialize: (?untyped? message, ?object: untyped? object, ?type: untyped? `type`, ?context: untyped? context, ?field: untyped? field) -> void
  end
end

module GraphQL
  # Raised when a argument is configured with `loads:` and the client provides an `ID`,
  # but no object is loaded for that ID.
  #
  # @see GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader#load_application_object_failed, A hook which you can override in resolvers, mutations and input objects.
  class LoadApplicationObjectFailedError < GraphQL::ExecutionError
    # @return [GraphQL::Schema::Argument] the argument definition for the argument that was looked up
    attr_reader argument: untyped

    # @return [String] The ID provided by the client
    attr_reader id: untyped

    # @return [Object] The value found with this ID
    attr_reader object: untyped

    def initialize: (argument: untyped argument, id: untyped id, object: untyped object) -> void
  end
end

module GraphQL
  module Deprecation
    def self.warn: (untyped message) -> untyped
  end
end

module GraphQL
  class Schema
    class Member
      module HasAstNode
        # If this schema was parsed from a `.graphql` file (or other SDL),
        # this is the AST node that defined this part of the schema.
        def ast_node: (?untyped? new_ast_node) -> untyped
      end
    end
  end
end

module GraphQL
  class Schema
    module FindInheritedValue
      module EmptyObjects
        EMPTY_HASH: ::Hash[untyped, untyped]

        EMPTY_ARRAY: ::Array[untyped]
      end

      def self.extended: (untyped child_cls) -> untyped

      def self.included: (untyped child_cls) -> untyped

      private

      def find_inherited_value: (untyped method_name, ?untyped? default_value) -> untyped
    end
  end
end

module GraphQL
  module Language
    class Printer
      # Turn an arbitrary AST node back into a string.
      #
      # @example Turning a document into a query string
      #    document = GraphQL.parse(query_string)
      #    GraphQL::Language::Printer.new.print(document)
      #    # => "{ ... }"
      #
      #
      # @example Building a custom printer
      #
      #  class MyPrinter < GraphQL::Language::Printer
      #    def print_argument(arg)
      #      "#{arg.name}: <HIDDEN>"
      #    end
      #  end
      #
      #  MyPrinter.new.print(document)
      #  # => "mutation { pay(creditCard: <HIDDEN>) { success } }"
      #
      #
      # @param indent [String] Whitespace to add to the printed node
      # @return [String] Valid GraphQL for `node`
      def print: (untyped node, ?indent: ::String indent) -> untyped

      def print_document: (untyped document) -> untyped

      def print_argument: (untyped argument) -> ::String

      def print_directive: (untyped directive) -> untyped

      def print_enum: (untyped enum) -> ::String

      def print_null_value: () -> "null"

      def print_field: (untyped field, ?indent: ::String indent) -> untyped

      def print_fragment_definition: (untyped fragment_def, ?indent: ::String indent) -> untyped

      def print_fragment_spread: (untyped fragment_spread, ?indent: ::String indent) -> untyped

      def print_inline_fragment: (untyped inline_fragment, ?indent: ::String indent) -> untyped

      def print_input_object: (untyped input_object) -> ::String

      def print_list_type: (untyped list_type) -> ::String

      def print_non_null_type: (untyped non_null_type) -> ::String

      def print_operation_definition: (untyped operation_definition, ?indent: ::String indent) -> untyped

      def print_type_name: (untyped type_name) -> ::String

      def print_variable_definition: (untyped variable_definition) -> untyped

      def print_variable_identifier: (untyped variable_identifier) -> ::String

      def print_schema_definition: (untyped schema) -> (nil | untyped)

      def print_scalar_type_definition: (untyped scalar_type) -> untyped

      def print_object_type_definition: (untyped object_type) -> untyped

      def print_implements: (untyped `type`) -> ::String

      def print_input_value_definition: (untyped input_value) -> untyped

      def print_arguments: (untyped arguments, ?indent: ::String indent) -> (::String | untyped)

      def print_field_definition: (untyped field) -> untyped

      def print_interface_type_definition: (untyped interface_type) -> untyped

      def print_union_type_definition: (untyped union_type) -> untyped

      def print_enum_type_definition: (untyped enum_type) -> untyped

      def print_enum_value_definition: (untyped enum_value) -> untyped

      def print_input_object_type_definition: (untyped input_object_type) -> untyped

      def print_directive_definition: (untyped directive) -> untyped

      def print_description: (untyped node, ?indent: ::String indent, ?first_in_block: bool first_in_block) -> (::String | untyped)

      def print_field_definitions: (untyped fields) -> untyped

      def print_directives: (untyped directives) -> untyped

      def print_selections: (untyped selections, ?indent: ::String indent) -> untyped

      def print_node: (untyped node, ?indent: ::String indent) -> untyped

      private

      attr_reader node: untyped
    end
  end
end