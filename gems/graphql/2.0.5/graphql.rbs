module GraphQL
  # forwards-compat for argument handling
  module Ruby2Keywords
    def ruby2_keywords: () -> nil
  end

  class Error < StandardError
  end

  # This error is raised when GraphQL-Ruby encounters a situation
  # that it *thought* would never happen. Please report this bug!
  class InvariantError < Error
    def initialize: (untyped message) -> void
  end

  class RequiredImplementationMissingError < Error
  end

  def self.default_parser: () -> untyped

  attr_writer self.default_parser: untyped

  # Turn a query string or schema definition into an AST
  # @param graphql_string [String] a GraphQL query string or schema definition
  # @return [GraphQL::Language::Nodes::Document]
  def self.parse: (untyped graphql_string, ?tracer: untyped tracer) -> untyped

  # Read the contents of `filename` and parse them as GraphQL
  # @param filename [String] Path to a `.graphql` file containing IDL or query
  # @return [GraphQL::Language::Nodes::Document]
  def self.parse_file: (untyped filename) -> untyped

  def self.parse_with_racc: (untyped string, ?filename: untyped? filename, ?tracer: untyped tracer) -> untyped

  # @return [Array<GraphQL::Language::Token>]
  def self.scan: (untyped graphql_string) -> untyped

  def self.scan_with_ragel: (untyped graphql_string) -> untyped

  class Schema
    # Mutations that extend this base class get some conventions added for free:
    #
    # - An argument called `clientMutationId` is _always_ added, but it's not passed
    #   to the resolve method. The value is re-inserted to the response. (It's for
    #   client libraries to manage optimistic updates.)
    # - The returned object type always has a field called `clientMutationId` to support that.
    # - The mutation accepts one argument called `input`, `argument`s defined in the mutation
    #   class are added to that input object, which is generated by the mutation.
    #
    # These conventions were first specified by Relay Classic, but they come in handy:
    #
    # - `clientMutationId` supports optimistic updates and cache rollbacks on the client
    # - using a single `input:` argument makes it easy to post whole JSON objects to the mutation
    #   using one GraphQL variable (`$input`) instead of making a separate variable for each argument.
    #
    # @see {GraphQL::Schema::Mutation} for an example, it's basically the same.
    #
    class RelayClassicMutation < GraphQL::Schema::Mutation
      # Override {GraphQL::Schema::Resolver#resolve_with_support} to
      # delete `client_mutation_id` from the kwargs.
      def resolve_with_support: (**untyped inputs) -> untyped

      def self.dummy: () -> untyped

      def self.field_arguments: (?untyped context) -> untyped

      def self.get_field_argument: (untyped name, ?untyped context) -> untyped

      def self.own_field_arguments: () -> untyped

      def self.all_field_argument_definitions: () -> untyped

      # Also apply this argument to the input type:
      def self.argument: (*untyped args, ?own_argument: bool own_argument, **untyped kwargs) { () -> untyped } -> untyped

      # The base class for generated input object types
      # @param new_class [Class] The base class to use for generating input object definitions
      # @return [Class] The base class for this mutation's generated input object (default is {GraphQL::Schema::InputObject})
      def self.input_object_class: (?untyped? new_class) -> untyped

      # @param new_input_type [Class, nil] If provided, it configures this mutation to accept `new_input_type` instead of generating an input type
      # @return [Class] The generated {Schema::InputObject} class for this mutation's `input`
      def self.input_type: (?untyped? new_input_type) -> untyped

      private

      # Generate the input type for the `input:` argument
      # To customize how input objects are generated, override this method
      # @return [Class] a subclass of {.input_object_class}
      def self.generate_input_type: () -> untyped

      def authorize_arguments: (untyped args, untyped values) -> untyped
    end
  end
end