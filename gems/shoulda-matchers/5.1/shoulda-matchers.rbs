
module Shoulda
  module Matchers
    # @private
    attr_accessor self.assertion_exception_class: untyped
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `route` matcher tests that a route resolves to a controller,
      # action, and params; and that the controller, action, and params
      # generates the same route. For an RSpec suite, this is like using a
      # combination of `route_to` and `be_routable`. In a test suite using
      # Minitest + Shoulda, it provides a more expressive syntax over
      # `assert_routing`.
      #
      # You can use this matcher either in a controller test case or in a
      # routing test case. For instance, given these routes:
      #
      #     My::Application.routes.draw do
      #       get '/posts', to: 'posts#index'
      #       get '/posts/:id', to: 'posts#show'
      #     end
      #
      # You could choose to write tests for these routes alongside other tests
      # for PostsController:
      #
      #     class PostsController < ApplicationController
      #       # ...
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       it { should route(:get, '/posts').to(action: :index) }
      #       it { should route(:get, '/posts/1').to(action: :show, id: 1) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       should route(:get, '/posts').to(action: 'index')
      #       should route(:get, '/posts/1').to(action: :show, id: 1)
      #     end
      #
      # Or you could place the tests along with other route tests:
      #
      #     # RSpec
      #     describe 'Routing', type: :routing do
      #       it do
      #         should route(:get, '/posts').
      #           to(controller: :posts, action: :index)
      #       end
      #
      #       it do
      #         should route(:get, '/posts/1').
      #           to('posts#show', id: 1)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RoutesTest < ActionController::IntegrationTest
      #       should route(:get, '/posts').
      #         to(controller: :posts, action: :index)
      #
      #       should route(:get, '/posts/1').
      #         to('posts#show', id: 1)
      #     end
      #
      # Notice that in the former case, as we are inside of a test case for
      # PostsController, we do not have to specify that the routes resolve to
      # this controller. In the latter case we specify this using the
      # `controller` key passed to the `to` qualifier.
      #
      # #### Specifying a port
      #
      # If the route you're testing has a constraint on it that limits the route
      # to a particular port, you can specify it by passing a `port` option to
      # the matcher:
      #
      #     class PortConstraint
      #       def initialize(port)
      #         @port = port
      #       end
      #
      #       def matches?(request)
      #         request.port == @port
      #       end
      #     end
      #
      #     My::Application.routes.draw do
      #       get '/posts',
      #         to: 'posts#index',
      #         constraints: PortConstraint.new(12345)
      #     end
      #
      #     # RSpec
      #     describe 'Routing', type: :routing do
      #       it do
      #         should route(:get, '/posts', port: 12345).
      #           to('posts#index')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RoutesTest < ActionController::IntegrationTest
      #       should route(:get, '/posts', port: 12345).
      #         to('posts#index')
      #     end
      #
      # #### Qualifiers
      #
      # ##### to
      #
      # Use `to` to specify the action (along with the controller, if needed)
      # that the route resolves to.
      #
      # `to` takes either keyword arguments (`controller` and `action`) or a
      # string that represents the controller/action pair:
      #
      #     route(:get, '/posts').to(action: index)
      #     route(:get, '/posts').to(controller: :posts, action: index)
      #     route(:get, '/posts').to('posts#index')
      #
      # If there are parameters in your route, then specify those too:
      #
      #     route(:get, '/posts/1').to('posts#show', id: 1)
      #
      # You may also specify special parameters such as `:format`:
      #
      #     route(:get, '/posts').to('posts#index', format: :json)
      #
      # @return [RouteMatcher]
      #
      def route: (untyped method, untyped path, ?port: untyped?) -> untyped

      # @private
      class RouteMatcher
        def initialize: (untyped context, untyped method, untyped path, ?port: untyped?) -> void

        attr_reader failure_message: untyped

        def to: (*untyped args) -> self

        def in_context: (untyped context) -> self

        def matches?: (untyped controller) -> untyped

        def description: () -> ::String

        def failure_message_when_negated: () -> ::String

        private

        attr_reader context: untyped

        attr_reader method: untyped

        attr_reader path: untyped

        attr_reader params: untyped

        def normalize_path: (untyped path) -> (untyped | ::String)

        def add_port_to_path: (untyped path, untyped port) -> untyped

        def guess_controller_if_necessary: (untyped controller) -> untyped

        def route_recognized?: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `rescue_from` matcher tests usage of the `rescue_from` macro. It
      # asserts that an exception and method are present in the list of
      # exception handlers, and that the handler method exists.
      #
      #     class ApplicationController < ActionController::Base
      #       rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found
      #
      #       private
      #
      #       def handle_not_found
      #         # ...
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe ApplicationController, type: :controller do
      #       it do
      #         should rescue_from(ActiveRecord::RecordNotFound).
      #           with(:handle_not_found)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ApplicationControllerTest < ActionController::TestCase
      #       should rescue_from(ActiveRecord::RecordNotFound).
      #         with(:handle_not_found)
      #     end
      #
      # @return [RescueFromMatcher]
      #
      def rescue_from: (untyped exception) -> untyped

      # @private
      class RescueFromMatcher
        def initialize: (untyped exception) -> void

        def with: (untyped method) -> self

        def matches?: (untyped controller) -> untyped

        def description: () -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        attr_reader controller: untyped

        attr_reader exception: untyped

        attr_reader expected_method: untyped

        attr_reader handlers: untyped

        def expectation: () -> untyped

        def rescues_from_exception?: () -> untyped

        def method_name_matches?: () -> (untyped | true)

        def handler_exists?: () -> (untyped | true)
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `use_before_action` matcher is used to test that a before_action
      # callback is defined within your controller.
      #
      #     class UsersController < ApplicationController
      #       before_action :authenticate_user!
      #     end
      #
      #     # RSpec
      #     RSpec.describe UsersController, type: :controller do
      #       it { should use_before_action(:authenticate_user!) }
      #       it { should_not use_before_action(:prevent_ssl) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UsersControllerTest < ActionController::TestCase
      #       should use_before_action(:authenticate_user!)
      #       should_not use_before_action(:prevent_ssl)
      #     end
      #
      # @return [CallbackMatcher]
      #
      def use_before_action: (untyped callback) -> untyped

      # The `use_after_action` matcher is used to test that an after_action
      # callback is defined within your controller.
      #
      #     class IssuesController < ApplicationController
      #       after_action :log_activity
      #     end
      #
      #     # RSpec
      #     RSpec.describe IssuesController, type: :controller do
      #       it { should use_after_action(:log_activity) }
      #       it { should_not use_after_action(:destroy_user) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssuesControllerTest < ActionController::TestCase
      #       should use_after_action(:log_activity)
      #       should_not use_after_action(:destroy_user)
      #     end
      #
      # @return [CallbackMatcher]
      #
      def use_after_action: (untyped callback) -> untyped

      # The `use_around_action` matcher is used to test that an around_action
      # callback is defined within your controller.
      #
      #     class ChangesController < ApplicationController
      #       around_action :wrap_in_transaction
      #     end
      #
      #     # RSpec
      #     RSpec.describe ChangesController, type: :controller do
      #       it { should use_around_action(:wrap_in_transaction) }
      #       it { should_not use_around_action(:save_view_context) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ChangesControllerTest < ActionController::TestCase
      #       should use_around_action(:wrap_in_transaction)
      #       should_not use_around_action(:save_view_context)
      #     end
      #
      # @return [CallbackMatcher]
      #
      def use_around_action: (untyped callback) -> untyped

      # @private
      class CallbackMatcher
        def initialize: (untyped method_name, untyped kind, untyped callback_type) -> void

        def matches?: (untyped controller) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> ::String

        def callbacks: () -> untyped

        attr_reader method_name: untyped

        attr_reader controller: untyped

        attr_reader controller_class: untyped

        attr_reader kind: untyped

        attr_reader callback_type: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `permit` matcher tests that an action in your controller receives a
      # whitelist of parameters using Rails' Strong Parameters feature
      # (specifically that `permit` was called with the correct arguments).
      #
      # Here's an example:
      #
      #     class UsersController < ApplicationController
      #       def create
      #         user = User.create(user_params)
      #         # ...
      #       end
      #
      #       private
      #
      #       def user_params
      #         params.require(:user).permit(
      #           :first_name,
      #           :last_name,
      #           :email,
      #           :password
      #         )
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe UsersController, type: :controller do
      #       it do
      #         params = {
      #           user: {
      #             first_name: 'John',
      #             last_name: 'Doe',
      #             email: 'johndoe@example.com',
      #             password: 'password'
      #           }
      #         }
      #         should permit(:first_name, :last_name, :email, :password).
      #           for(:create, params: params).
      #           on(:user)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UsersControllerTest < ActionController::TestCase
      #       should "(for POST #create) restrict parameters on :user to first_name, last_name, email, and password" do
      #         params = {
      #           user: {
      #             first_name: 'John',
      #             last_name: 'Doe',
      #             email: 'johndoe@example.com',
      #             password: 'password'
      #           }
      #         }
      #         matcher = permit(:first_name, :last_name, :email, :password).
      #           for(:create, params: params).
      #           on(:user)
      #         assert_accepts matcher, subject
      #       end
      #     end
      #
      # If your action requires query parameters in order to work, then you'll
      # need to supply them:
      #
      #     class UsersController < ApplicationController
      #       def update
      #         user = User.find(params[:id])
      #
      #         if user.update_attributes(user_params)
      #           # ...
      #         else
      #           # ...
      #         end
      #       end
      #
      #       private
      #
      #       def user_params
      #         params.require(:user).permit(
      #           :first_name,
      #           :last_name,
      #           :email,
      #           :password
      #         )
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe UsersController, type: :controller do
      #       before do
      #         create(:user, id: 1)
      #       end
      #
      #       it do
      #         params = {
      #           id: 1,
      #           user: {
      #             first_name: 'Jon',
      #             last_name: 'Doe',
      #             email: 'jondoe@example.com',
      #             password: 'password'
      #           }
      #         }
      #         should permit(:first_name, :last_name, :email, :password).
      #           for(:update, params: params).
      #           on(:user)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UsersControllerTest < ActionController::TestCase
      #       setup do
      #         create(:user, id: 1)
      #       end
      #
      #       should "(for PATCH #update) restrict parameters on :user to :first_name, :last_name, :email, and :password" do
      #         params = {
      #           id: 1,
      #           user: {
      #             first_name: 'Jon',
      #             last_name: 'Doe',
      #             email: 'jondoe@example.com',
      #             password: 'password'
      #           }
      #         }
      #         matcher = permit(:first_name, :last_name, :email, :password).
      #           for(:update, params: params).
      #           on(:user)
      #         assert_accepts matcher, subject
      #       end
      #     end
      #
      # Finally, if you have an action that isn't one of the seven resourceful
      # actions, then you'll need to provide the HTTP verb that it responds to:
      #
      #     Rails.application.routes.draw do
      #       resources :users do
      #         member do
      #           put :toggle
      #         end
      #       end
      #     end
      #
      #     class UsersController < ApplicationController
      #       def toggle
      #         user = User.find(params[:id])
      #
      #         if user.update_attributes(user_params)
      #           # ...
      #         else
      #           # ...
      #         end
      #       end
      #
      #       private
      #
      #       def user_params
      #         params.require(:user).permit(:activated)
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe UsersController, type: :controller do
      #       before do
      #         create(:user, id: 1)
      #       end
      #
      #       it do
      #         params = { id: 1, user: { activated: true } }
      #         should permit(:activated).
      #           for(:toggle, params: params, verb: :put).
      #           on(:user)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UsersControllerTest < ActionController::TestCase
      #       setup do
      #         create(:user, id: 1)
      #       end
      #
      #       should "(for PUT #toggle) restrict parameters on :user to :activated" do
      #         params = { id: 1, user: { activated: true } }
      #         matcher = permit(:activated).
      #           for(:toggle, params: params, verb: :put).
      #           on(:user)
      #         assert_accepts matcher, subject
      #       end
      #     end
      #
      # @return [PermitMatcher]
      #
      def permit: (*untyped params) -> untyped

      # @private
      class PermitMatcher
        attr_writer stubbed_params: untyped

        def initialize: (untyped expected_permitted_parameter_names) -> void

        def for: (untyped action, ?::Hash[untyped, untyped] options) -> self

        def add_params: (untyped params) -> self

        def on: (untyped subparameter_name) -> self

        def in_context: (untyped context) -> self

        def description: () -> untyped

        def matches?: (untyped controller) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        attr_reader controller: untyped

        attr_reader double_collections_by_parameter_name: untyped

        attr_reader action: untyped

        attr_reader verb: untyped

        attr_reader request_params: untyped

        attr_reader expected_permitted_parameter_names: untyped

        attr_reader context: untyped

        attr_reader subparameter_name: untyped

        attr_reader parameters_double_registry: untyped

        def expectation: () -> untyped

        def reality: () -> ("it did not restrict any parameters" | ::String)

        def format_parameter_names: (untyped parameter_names) -> untyped

        def actual_permitted_parameter_names: () -> untyped

        def unpermitted_parameter_names: () -> untyped

        def ensure_action_and_verb_present!: () -> untyped

        def default_verb: () -> untyped

        def parameter_names_as_sentence: () -> untyped

        # @private
        class CompositeParametersDoubleRegistry
          def initialize: () -> void

          def register: () -> untyped

          def permitted_parameter_names: (?::Hash[untyped, untyped] options) -> untyped

          attr_reader parameters_double_registries: untyped
        end

        # @private
        class ParametersDoubleRegistry
          TOP_LEVEL: untyped

          def self.permitted_parameter_names_within: (untyped double_collection) -> untyped

          def initialize: (untyped params) -> void

          def register: () -> untyped

          def permitted_parameter_names: (?::Hash[untyped, untyped] args) -> untyped

          attr_reader params: untyped

          attr_reader double_collections_by_parameter_name: untyped

          private

          def register_double_for_permit_against: (untyped params, untyped subparameter_name) -> untyped

          def register_double_for_permit_on: (untyped double_collection) -> untyped

          def register_double_for_require_on: (untyped double_collection) -> untyped
        end

        # @private
        class ActionNotDefinedError < StandardError
          def message: () -> "You must specify the controller action using the #for method."
        end

        # @private
        class VerbNotDefinedError < StandardError
          def message: () -> "You must specify an HTTP verb when using a non-RESTful action. For example: for(:authorize, verb: :post)"
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # @private
      class SessionStore
        attr_accessor controller: untyped

        def name: () -> "session"

        def has_key?: (untyped key) -> untyped

        def has_value?: (untyped expected_value) -> untyped

        def empty?: () -> untyped

        private

        def session: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `render_template` matcher tests that an action renders a template
      # or partial. In RSpec, it is very similar to rspec-rails's
      # `render_template` matcher. In a test suite using Minitest + Shoulda, it
      # provides a more expressive syntax over `assert_template`.
      #
      #     class PostsController < ApplicationController
      #       def show
      #       end
      #     end
      #
      #     # app/views/posts/show.html.erb
      #     <%= render 'sidebar' %>
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #show' do
      #         before { get :show }
      #
      #         it { should render_template('show') }
      #         it { should render_template(partial: '_sidebar') }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #show' do
      #         setup { get :show }
      #
      #         should render_template('show')
      #         should render_template(partial: '_sidebar')
      #       end
      #     end
      #
      # @return [RenderTemplateMatcher]
      #
      def render_template: (?::Hash[untyped, untyped] options, ?untyped? message) -> untyped

      # @private
      class RenderTemplateMatcher
        attr_reader failure_message: untyped

        attr_reader failure_message_when_negated: untyped

        def initialize: (untyped options, untyped message, untyped context) -> void

        def matches?: (untyped controller) -> untyped

        def description: () -> ::String

        def in_context: (untyped context) -> self

        private

        def renders_template?: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # @private
      class FlashStore
        def self.future: () -> untyped

        def self.now: () -> untyped

        attr_accessor controller: untyped

        def initialize: () -> void

        def name: () -> ("flash.now" | "flash")

        def has_key?: (untyped key) -> untyped

        def has_value?: (untyped expected_value) -> untyped

        def use_now!: () -> self

        private

        def flash: () -> untyped

        def copy_of_flash_from_controller: () -> untyped

        def copy_flashes: (untyped original_flash, untyped new_flash) -> untyped

        def copy_discard_if_necessary: (untyped original_flash, untyped new_flash) -> untyped

        def set_values: () -> untyped

        def keys_to_discard: () -> untyped

        def values_to_check: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # @private
      class RouteParams
        PARAMS_TO_SYMBOLIZE: ::Array[:format]

        def initialize: (untyped args) -> void

        def normalize: () -> untyped

        attr_reader args: untyped

        def controller_and_action_given_as_string?: () -> untyped

        def extract_params_from_string: () -> untyped

        def stringify_params: () -> untyped

        def normalize_values: (untyped hash) -> untyped

        def symbolize_or_stringify: (untyped key, untyped value) -> untyped

        def stringify: (untyped value) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `set_flash` matcher is used to make assertions about the
      # `flash` hash.
      #
      #     class PostsController < ApplicationController
      #       def index
      #         flash[:foo] = 'A candy bar'
      #       end
      #
      #       def destroy
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should set_flash }
      #       end
      #
      #       describe 'DELETE #destroy' do
      #         before { delete :destroy }
      #
      #         it { should_not set_flash }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :index }
      #
      #         should set_flash
      #       end
      #
      #       context 'DELETE #destroy' do
      #         setup { delete :destroy }
      #
      #         should_not set_flash
      #       end
      #     end
      #
      # #### Qualifiers
      #
      # ##### []
      #
      # Use `[]` to narrow the scope of the matcher to a particular key.
      #
      #     class PostsController < ApplicationController
      #       def index
      #         flash[:foo] = 'A candy bar'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should set_flash[:foo] }
      #         it { should_not set_flash[:bar] }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :show }
      #
      #         should set_flash[:foo]
      #         should_not set_flash[:bar]
      #       end
      #     end
      #
      # ##### to
      #
      # Use `to` to assert that some key was set to a particular value, or that
      # some key matches a particular regex.
      #
      #     class PostsController < ApplicationController
      #       def index
      #         flash[:foo] = 'A candy bar'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should set_flash.to('A candy bar') }
      #         it { should set_flash.to(/bar/) }
      #         it { should set_flash[:foo].to('bar') }
      #         it { should_not set_flash[:foo].to('something else') }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :show }
      #
      #         should set_flash.to('A candy bar')
      #         should set_flash.to(/bar/)
      #         should set_flash[:foo].to('bar')
      #         should_not set_flash[:foo].to('something else')
      #       end
      #     end
      #
      # ##### now
      #
      # Use `now` to change the scope of the matcher to use the "now" hash
      # instead of the usual "future" hash.
      #
      #     class PostsController < ApplicationController
      #       def show
      #         flash.now[:foo] = 'bar'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #show' do
      #         before { get :show }
      #
      #         it { should set_flash.now }
      #         it { should set_flash.now[:foo] }
      #         it { should set_flash.now[:foo].to('bar') }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :show }
      #
      #         should set_flash.now
      #         should set_flash.now[:foo]
      #         should set_flash.now[:foo].to('bar')
      #       end
      #     end
      #
      # @return [SetFlashMatcher]
      #
      def set_flash: () -> untyped

      # @private
      class SetFlashMatcher
        # extend Forwardable

        # alias failure_message_for_should failure_message

        # alias failure_message_for_should_not failure_message_when_negated

        def initialize: () -> void

        def now: () -> self

        def in_context: (untyped context) -> self

        def []: (untyped key) -> self

        def to: (?untyped? expected_value) ?{ () -> untyped } -> self

        attr_reader underlying_matcher: untyped

        attr_reader key: untyped

        attr_reader expected_value: untyped

        # @private
        class QualifierOrderError < StandardError
          def message: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `filter_param` matcher is used to test parameter filtering
      # configuration. Specifically, it asserts that the given parameter is
      # present in `config.filter_parameters`.
      #
      #     class MyApplication < Rails::Application
      #       config.filter_parameters << :secret_key
      #     end
      #
      #     # RSpec
      #     RSpec.describe ApplicationController, type: :controller do
      #       it { should filter_param(:secret_key) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ApplicationControllerTest < ActionController::TestCase
      #       should filter_param(:secret_key)
      #     end
      #
      # @return [FilterParamMatcher]
      #
      def filter_param: (untyped key) -> untyped

      # @private
      class FilterParamMatcher
        def initialize: (untyped key) -> void

        def matches?: (untyped _controller) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> ::String

        private

        def filters_key?: () -> untyped

        def filtered_keys: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # @private
      class SetSessionOrFlashMatcher
        def initialize: (untyped store) -> void

        def in_context: (untyped context) -> self

        def []: (untyped key) -> self

        def to: (?untyped? expected_value) ?{ () -> untyped } -> self

        def description: () -> ::String

        def matches?: (untyped controller) -> untyped

        def failure_message: () -> ::String

        alias failure_message_for_should failure_message

        def failure_message_when_negated: () -> ::String

        alias failure_message_for_should_not failure_message_when_negated

        attr_reader store: untyped

        attr_reader context: untyped

        attr_reader key: untyped

        attr_reader expected_value: untyped

        attr_reader controller: untyped

        private

        def context_set?: () -> untyped

        def key_set?: () -> untyped

        def expected_value_set?: () -> untyped

        def key_matches?: () -> untyped

        def expected_value_matches?: () -> untyped

        def expectation_description: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `set_session` matcher is used to make assertions about the
      # `session` hash.
      #
      #     class PostsController < ApplicationController
      #       def index
      #         session[:foo] = 'A candy bar'
      #       end
      #
      #       def destroy
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should set_session }
      #       end
      #
      #       describe 'DELETE #destroy' do
      #         before { delete :destroy }
      #
      #         it { should_not set_session }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :index }
      #
      #         should set_session
      #       end
      #
      #       context 'DELETE #destroy' do
      #         setup { delete :destroy }
      #
      #         should_not set_session
      #       end
      #     end
      #
      # #### Qualifiers
      #
      # ##### []
      #
      # Use `[]` to narrow the scope of the matcher to a particular key.
      #
      #     class PostsController < ApplicationController
      #       def index
      #         session[:foo] = 'A candy bar'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should set_session[:foo] }
      #         it { should_not set_session[:bar] }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :show }
      #
      #         should set_session[:foo]
      #         should_not set_session[:bar]
      #       end
      #     end
      #
      # ##### to
      #
      # Use `to` to assert that some key was set to a particular value, or that
      # some key matches a particular regex.
      #
      #     class PostsController < ApplicationController
      #       def index
      #         session[:foo] = 'A candy bar'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should set_session.to('A candy bar') }
      #         it { should set_session.to(/bar/) }
      #         it { should set_session[:foo].to('bar') }
      #         it { should_not set_session[:foo].to('something else') }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :show }
      #
      #         should set_session.to('A candy bar')
      #         should set_session.to(/bar/)
      #         should set_session[:foo].to('bar')
      #         should_not set_session[:foo].to('something else')
      #       end
      #     end
      #
      # @return [SetSessionMatcher]
      #
      def set_session: () -> untyped

      # @private
      class SetSessionMatcher
        # extend Forwardable

        # alias failure_message_for_should failure_message

        # alias failure_message_for_should_not failure_message_when_negated

        def initialize: () -> void

        def in_context: (untyped context) -> self

        def []: (untyped key) -> self

        def to: (?untyped? expected_value) ?{ () -> untyped } -> self

        attr_reader underlying_matcher: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `respond_with` matcher tests that an action responds with a certain
      # status code.
      #
      # You can specify that the status should be a number:
      #
      #     class PostsController < ApplicationController
      #       def index
      #         render status: 403
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #index' do
      #         before { get :index }
      #
      #         it { should respond_with(403) }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #index' do
      #         setup { get :index }
      #
      #         should respond_with(403)
      #       end
      #     end
      #
      # You can specify that the status should be within a range of numbers:
      #
      #     class PostsController < ApplicationController
      #       def destroy
      #         render status: 508
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'DELETE #destroy' do
      #         before { delete :destroy }
      #
      #         it { should respond_with(500..600) }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'DELETE #destroy' do
      #         setup { delete :destroy }
      #
      #         should respond_with(500..600)
      #       end
      #     end
      #
      # Finally, you can specify that the status should be a symbol:
      #
      #     class PostsController < ApplicationController
      #       def show
      #         render status: :locked
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #show' do
      #         before { get :show }
      #
      #         it { should respond_with(:locked) }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #show' do
      #         setup { get :show }
      #
      #         should respond_with(:locked)
      #       end
      #     end
      #
      # @return [RespondWithMatcher]
      #
      def respond_with: (untyped status) -> untyped

      # @private
      class RespondWithMatcher
        def initialize: (untyped status) -> void

        def matches?: (untyped controller) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> ::String

        def correct_status_code?: () -> untyped

        def correct_status_code_range?: () -> untyped

        def response_code: () -> untyped

        def symbol_to_status_code: (untyped potential_symbol) -> untyped

        def expectation: () -> ::String
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `redirect_to` matcher tests that an action redirects to a certain
      # location. In a test suite using RSpec, it is very similar to
      # rspec-rails's `redirect_to` matcher. In a test suite using Minitest +
      # Shoulda, it provides a more expressive syntax over
      # `assert_redirected_to`.
      #
      #     class PostsController < ApplicationController
      #       def show
      #         redirect_to :index
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #show' do
      #         before { get :show }
      #
      #         it { should redirect_to(posts_path) }
      #         it { should redirect_to(action: :index) }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #show' do
      #         setup { get :show }
      #
      #         should redirect_to('/posts') { posts_path }
      #         should redirect_to(action: :index)
      #       end
      #     end
      #
      # @return [RedirectToMatcher]
      #
      def redirect_to: (untyped url_or_description) ?{ () -> untyped } -> untyped

      # @private
      class RedirectToMatcher
        attr_reader failure_message: untyped

        attr_reader failure_message_when_negated: untyped

        def initialize: (untyped url_or_description, untyped context) ?{ () -> untyped } -> void

        def in_context: (untyped context) -> self

        def matches?: (untyped controller) -> untyped

        def description: () -> ::String

        private

        def redirects_to_url?: () -> untyped

        def url: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActionController
      # The `render_with_layout` matcher asserts that an action is rendered with
      # a particular layout.
      #
      #     class PostsController < ApplicationController
      #       def show
      #         render layout: 'posts'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #show' do
      #         before { get :show }
      #
      #         it { should render_with_layout('posts') }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #show' do
      #         setup { get :show }
      #
      #         should render_with_layout('posts')
      #       end
      #     end
      #
      # It can also be used to assert that the action is not rendered with a
      # layout at all:
      #
      #     class PostsController < ApplicationController
      #       def sidebar
      #         render layout: false
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe PostsController, type: :controller do
      #       describe 'GET #sidebar' do
      #         before { get :sidebar }
      #
      #         it { should_not render_with_layout }
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostsControllerTest < ActionController::TestCase
      #       context 'GET #sidebar' do
      #         setup { get :sidebar }
      #
      #         should_not render_with_layout
      #       end
      #     end
      #
      # @return [RenderWithLayoutMatcher]
      #
      def render_with_layout: (?untyped? expected_layout) -> untyped

      # @private
      class RenderWithLayoutMatcher
        def initialize: (untyped expected_layout) -> void

        # Used to provide access to layouts recorded by
        # ActionController::TemplateAssertions in Rails 3
        def in_context: (untyped context) -> self

        def matches?: (untyped controller) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> untyped

        private

        def rendered_with_layout?: () -> untyped

        def rendered_with_expected_layout?: () -> (true | untyped)

        def rendered_layouts: () -> untyped

        def recorded_layouts: () -> (untyped | ::Hash[untyped, untyped])

        def expectation: () -> ::String

        def result: () -> (::String | "rendered without a layout")
      end
    end
  end
end

module Shoulda
  module Matchers
    # @private
    module Integrations
      def self.register_library: (untyped klass, untyped name) -> untyped

      def self.find_library!: (untyped name) -> untyped

      def self.register_test_framework: (untyped klass, untyped name) -> untyped

      def self.find_test_framework!: (untyped name) -> untyped

      private

      def self.library_registry: () -> untyped

      def self.test_framework_registry: () -> untyped
    end
  end
end

module Shoulda
  module Matchers
    # This module provides matchers that are used to test behavior within
    # controllers.
    module ActionController
    end
  end
end

module Shoulda
  module Matchers
    # @private
    module WordWrap
      TERMINAL_WIDTH: 72

      def word_wrap: (untyped document, ?::Hash[untyped, untyped] options) -> untyped
    end

    extend WordWrap

    # @private
    class Document
      def initialize: (untyped document, ?indent: ::Integer) -> void

      def wrap: () -> untyped

      attr_reader document: untyped

      attr_reader indent: untyped

      private

      def paragraphs: () -> untyped

      def wrapped_paragraphs: () -> untyped
    end

    # @private
    class Text < ::String
      LIST_ITEM_REGEXP: ::Regexp

      def indented?: () -> untyped

      def list_item?: () -> untyped

      def match_as_list_item: () -> untyped
    end

    # @private
    class Paragraph
      def initialize: (untyped paragraph, ?indent: ::Integer) -> void

      def wrap: () -> untyped

      attr_reader paragraph: untyped

      attr_reader indent: untyped

      private

      def wrap_list_item: () -> untyped

      def lines: () -> untyped

      def combine_list_item_lines: (untyped lines) -> untyped

      def wrap_lines: (untyped lines) -> untyped

      def wrap_generic_paragraph: () -> untyped

      def combine_paragraph_into_one_line: () -> untyped
    end

    # @private
    class Line
      OFFSETS: { left: -1, right: 1 }

      def initialize: (untyped line, ?indent: ::Integer) -> void

      def wrap: () -> (::Array[untyped] | untyped)

      attr_reader indent: untyped

      attr_reader original_line: untyped

      attr_reader line_to_wrap: untyped

      attr_reader indentation: untyped

      attr_reader previous_line_to_wrap: untyped

      private

      def read_indentation: () -> untyped

      def wrap_line: (untyped line) -> { fitted_line: untyped, leftover: untyped }

      def determine_where_to_break_line: (untyped line, untyped args) -> untyped

      def normalize_whitespace: (untyped string) -> untyped
    end
  end
end

module Shoulda
  module Matchers
    # This module provides matchers that are used to test behavior within
    # ActiveModel or ActiveRecord classes.
    #
    # ### Testing conditional validations
    #
    # If your model defines a validation conditionally -- meaning that the
    # validation is declared with an `:if` or `:unless` option -- how do you
    # test it? You might expect the validation matchers here to have
    # corresponding `if` or `unless` qualifiers, but this isn't what you use.
    # Instead, before using the matcher in question, you place the record
    # you're testing in a state such that the validation you're also testing
    # will be run. A common way to do this is to make a new `context` and
    # override the subject to populate the record accordingly. You'll also want
    # to make sure to test that the validation is *not* run when the
    # conditional fails.
    #
    # Here's an example to illustrate what we mean:
    #
    #     class User
    #       include ActiveModel::Model
    #
    #       attr_accessor :role, :admin
    #
    #       validates_presence_of :role, if: :admin
    #     end
    #
    #     # RSpec
    #     RSpec.describe User, type: :model do
    #       context "when an admin" do
    #         subject { User.new(admin: true) }
    #
    #         it { should validate_presence_of(:role) }
    #       end
    #
    #       context "when not an admin" do
    #         subject { User.new(admin: false) }
    #
    #         it { should_not validate_presence_of(:role) }
    #       end
    #     end
    #
    #     # Minitest (Shoulda)
    #     class UserTest < ActiveSupport::TestCase
    #       context "when an admin" do
    #         subject { User.new(admin: true) }
    #
    #         should validate_presence_of(:role)
    #       end
    #
    #       context "when not an admin" do
    #         subject { User.new(admin: false) }
    #
    #         should_not validate_presence_of(:role)
    #       end
    #     end
    #
    module ActiveModel
    end
  end
end

module Shoulda
  module Matchers
    # @private
    module Routing
      def route: (untyped method, untyped path, ?port: untyped?) -> untyped
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      module Helpers
        def pretty_error_messages: (untyped object) -> untyped

        def format_validation_errors: (untyped errors) -> untyped

        def default_error_message: (untyped `type`, ?::Hash[untyped, untyped] options) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      class ValidationMessageFinder
        include Helpers

        def initialize: (untyped `instance`, untyped attribute, ?untyped? context) -> void

        def allow_description: (untyped allowed_values) -> ::String

        def expected_message_from: (untyped attribute_message) -> untyped

        def has_messages?: () -> untyped

        def source_description: () -> "errors"

        def messages_description: () -> (" no errors" | ::String)

        def messages: () -> untyped

        private

        def messages_for_attribute: () -> untyped

        def errors: () -> untyped

        def validated_instance: () -> untyped

        def validate_instance: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_numericality_of` matcher tests usage of the
      # `validates_numericality_of` validation.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :gpa
      #
      #       validates_numericality_of :gpa
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should validate_numericality_of(:gpa) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:gpa)
      #     end
      #
      # #### Qualifiers
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :number_of_dependents
      #
      #       validates_numericality_of :number_of_dependents, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:number_of_dependents).
      #           on(:create)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:number_of_dependents).on(:create)
      #     end
      #
      # ##### only_integer
      #
      # Use `only_integer` to test usage of the `:only_integer` option. This
      # asserts that your attribute only allows integer numbers and disallows
      # non-integer ones.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :age
      #
      #       validates_numericality_of :age, only_integer: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should validate_numericality_of(:age).only_integer }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:age).only_integer
      #     end
      #
      # ##### is_less_than
      #
      # Use `is_less_than` to test usage of the the `:less_than` option. This
      # asserts that the attribute can take a number which is less than the
      # given value and cannot take a number which is greater than or equal to
      # it.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :number_of_cars
      #
      #       validates_numericality_of :number_of_cars, less_than: 2
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:number_of_cars).
      #           is_less_than(2)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:number_of_cars).
      #         is_less_than(2)
      #     end
      #
      # ##### is_less_than_or_equal_to
      #
      # Use `is_less_than_or_equal_to` to test usage of the
      # `:less_than_or_equal_to` option. This asserts that the attribute can
      # take a number which is less than or equal to the given value and cannot
      # take a number which is greater than it.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :birth_year
      #
      #       validates_numericality_of :birth_year, less_than_or_equal_to: 1987
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:birth_year).
      #           is_less_than_or_equal_to(1987)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:birth_year).
      #         is_less_than_or_equal_to(1987)
      #     end
      #
      # ##### is_equal_to
      #
      # Use `is_equal_to` to test usage of the `:equal_to` option. This asserts
      # that the attribute can take a number which is equal to the given value
      # and cannot take a number which is not equal.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :weight
      #
      #       validates_numericality_of :weight, equal_to: 150
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should validate_numericality_of(:weight).is_equal_to(150) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:weight).is_equal_to(150)
      #     end
      #
      # ##### is_greater_than_or_equal_to
      #
      # Use `is_greater_than_or_equal_to` to test usage of the
      # `:greater_than_or_equal_to` option. This asserts that the attribute can
      # take a number which is greater than or equal to the given value and
      # cannot take a number which is less than it.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :height
      #
      #       validates_numericality_of :height, greater_than_or_equal_to: 55
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:height).
      #           is_greater_than_or_equal_to(55)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:height).
      #         is_greater_than_or_equal_to(55)
      #     end
      #
      # ##### is_greater_than
      #
      # Use `is_greater_than` to test usage of the `:greater_than` option.
      # This asserts that the attribute can take a number which is greater than
      # the given value and cannot take a number less than or equal to it.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :legal_age
      #
      #       validates_numericality_of :legal_age, greater_than: 21
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:legal_age).
      #           is_greater_than(21)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:legal_age).
      #         is_greater_than(21)
      #     end
      #
      # ##### is_other_than
      #
      # Use `is_other_than` to test usage of the `:other_than` option.
      # This asserts that the attribute can take a number which is not equal to
      # the given value.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :legal_age
      #
      #       validates_numericality_of :legal_age, other_than: 21
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:legal_age).
      #           is_other_than(21)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:legal_age).
      #         is_other_than(21)
      #     end
      #
      # ##### even
      #
      # Use `even` to test usage of the `:even` option. This asserts that the
      # attribute can take odd numbers and cannot take even ones.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :birth_month
      #
      #       validates_numericality_of :birth_month, even: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should validate_numericality_of(:birth_month).even }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:birth_month).even
      #     end
      #
      # ##### odd
      #
      # Use `odd` to test usage of the `:odd` option. This asserts that the
      # attribute can take a number which is odd and cannot take a number which
      # is even.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :birth_day
      #
      #       validates_numericality_of :birth_day, odd: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should validate_numericality_of(:birth_day).odd }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:birth_day).odd
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :number_of_dependents
      #
      #       validates_numericality_of :number_of_dependents,
      #         message: 'Number of dependents must be a number'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_numericality_of(:number_of_dependents).
      #           with_message('Number of dependents must be a number')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:number_of_dependents).
      #         with_message('Number of dependents must be a number')
      #     end
      #
      # ##### allow_nil
      #
      # Use `allow_nil` to assert that the attribute allows nil.
      #
      #     class Post
      #       include ActiveModel::Model
      #       attr_accessor :age
      #
      #       validates_numericality_of :age, allow_nil: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_numericality_of(:age).allow_nil }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_numericality_of(:age).allow_nil
      #     end
      #
      # @return [ValidateNumericalityOfMatcher]
      #
      def validate_numericality_of: (untyped attr) -> untyped

      # @private
      class ValidateNumericalityOfMatcher
        NUMERIC_NAME: "number"

        DEFAULT_DIFF_TO_COMPARE: 1

        include Qualifiers::IgnoringInterferenceByWriter

        attr_reader diff_to_compare: untyped

        def initialize: (untyped attribute) -> void

        def strict: () -> self

        def expects_strict?: () -> untyped

        def only_integer: () -> self

        def allow_nil: () -> self

        def expects_to_allow_nil?: () -> untyped

        def odd: () -> self

        def even: () -> self

        def is_greater_than: (untyped value) -> self

        def is_greater_than_or_equal_to: (untyped value) -> self

        def is_equal_to: (untyped value) -> self

        def is_less_than: (untyped value) -> self

        def is_less_than_or_equal_to: (untyped value) -> self

        def is_other_than: (untyped value) -> self

        def with_message: (untyped message) -> self

        def expects_custom_validation_message?: () -> untyped

        def on: (untyped context) -> self

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        def simple_description: () -> untyped

        def description: () -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> untyped

        def given_numeric_column?: () -> untyped

        private

        def matches_or_does_not_match?: (untyped subject) -> untyped

        def overall_failure_message: () -> untyped

        def overall_failure_message_when_negated: () -> untyped

        def attribute_is_active_record_column?: () -> untyped

        def column_type: () -> untyped

        def columns_hash: () -> (untyped | ::Hash[untyped, untyped])

        def add_disallow_value_matcher: () -> untyped

        def prepare_submatcher: (untyped submatcher) -> untyped

        def comparison_matcher_for: (untyped value, untyped operator) -> untyped

        def add_submatcher: (untyped submatcher) -> untyped

        def qualify_submatchers: () -> untyped

        def number_of_submatchers_for_failure_message: () -> untyped

        def has_been_qualified?: () -> untyped

        def first_submatcher_that_fails_to_match: () -> untyped

        def first_submatcher_that_fails_to_not_match: () -> untyped

        def failure_message_for_first_submatcher_that_fails_to_match: () -> untyped

        def failure_message_for_first_submatcher_that_fails_to_not_match: () -> untyped

        def build_submatcher_failure_message_for: (untyped submatcher, untyped failure_message_method) -> untyped

        def full_allowed_type: () -> untyped

        def comparison_descriptions: () -> untyped

        def submatcher_comparison_descriptions: () -> untyped

        def model: () -> untyped

        def non_numeric_value: () -> "abcd"
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_inclusion_of` matcher tests usage of the
      # `validates_inclusion_of` validation, asserting that an attribute can
      # take a whitelist of values and cannot take values outside of this list.
      #
      # If your whitelist is an array of values, use `in_array`:
      #
      #     class Issue
      #       include ActiveModel::Model
      #       attr_accessor :state
      #
      #       validates_inclusion_of :state,
      #         in: ['open', 'resolved', 'unresolved']
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should validate_inclusion_of(:state).
      #           in_array(['open', 'resolved', 'unresolved'])
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssueTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:state).
      #         in_array(['open', 'resolved', 'unresolved'])
      #     end
      #
      # If your whitelist is a range of values, use `in_range`:
      #
      #     class Issue
      #       include ActiveModel::Model
      #       attr_accessor :priority
      #
      #       validates_inclusion_of :priority, in: 1..5
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it { should validate_inclusion_of(:state).in_range(1..5) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssueTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:state).in_range(1..5)
      #     end
      #
      # #### Caveats
      #
      # We discourage using `validate_inclusion_of` with boolean columns. In
      # fact, there is never a case where a boolean column will be anything but
      # true, false, or nil, as ActiveRecord will type-cast an incoming value to
      # one of these three values. That means there isn't any way we can refute
      # this logic in a test. Hence, this will produce a warning:
      #
      #     it do
      #       should validate_inclusion_of(:imported).
      #         in_array([true, false])
      #     end
      #
      # The only case where `validate_inclusion_of` *could* be appropriate is
      # for ensuring that a boolean column accepts nil, but we recommend
      # using `allow_value` instead, like this:
      #
      #     it { should allow_value(nil).for(:imported) }
      #
      # #### Qualifiers
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class Issue
      #       include ActiveModel::Model
      #       attr_accessor :severity
      #
      #       validates_inclusion_of :severity,
      #         in: %w(low medium high),
      #         on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should validate_inclusion_of(:severity).
      #           in_array(%w(low medium high)).
      #           on(:create)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssueTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:severity).
      #         in_array(%w(low medium high)).
      #         on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class Issue
      #       include ActiveModel::Model
      #       attr_accessor :severity
      #
      #       validates_inclusion_of :severity,
      #         in: %w(low medium high),
      #         message: 'Severity must be low, medium, or high'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should validate_inclusion_of(:severity).
      #           in_array(%w(low medium high)).
      #           with_message('Severity must be low, medium, or high')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssueTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:severity).
      #         in_array(%w(low medium high)).
      #         with_message('Severity must be low, medium, or high')
      #     end
      #
      # ##### with_low_message
      #
      # Use `with_low_message` if you have a custom validation message for when
      # a given value is too low.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :age
      #
      #       validate :age_must_be_valid
      #
      #       private
      #
      #       def age_must_be_valid
      #         if age < 65
      #           self.errors.add :age, 'You do not receive any benefits'
      #         end
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_inclusion_of(:age).
      #           in_range(0..65).
      #           with_low_message('You do not receive any benefits')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:age).
      #         in_range(0..65).
      #         with_low_message('You do not receive any benefits')
      #     end
      #
      # ##### with_high_message
      #
      # Use `with_high_message` if you have a custom validation message for
      # when a given value is too high.
      #
      #     class Person
      #       include ActiveModel::Model
      #       attr_accessor :age
      #
      #       validate :age_must_be_valid
      #
      #       private
      #
      #       def age_must_be_valid
      #         if age > 21
      #           self.errors.add :age, "You're too old for this stuff"
      #         end
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should validate_inclusion_of(:age).
      #           in_range(0..21).
      #           with_high_message("You're too old for this stuff")
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:age).
      #         in_range(0..21).
      #         with_high_message("You're too old for this stuff")
      #     end
      #
      # ##### allow_nil
      #
      # Use `allow_nil` to assert that the attribute allows nil.
      #
      #     class Issue
      #       include ActiveModel::Model
      #       attr_accessor :state
      #
      #       validates_presence_of :state
      #       validates_inclusion_of :state,
      #         in: ['open', 'resolved', 'unresolved'],
      #         allow_nil: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should validate_inclusion_of(:state).
      #           in_array(['open', 'resolved', 'unresolved']).
      #           allow_nil
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssueTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:state).
      #         in_array(['open', 'resolved', 'unresolved']).
      #         allow_nil
      #     end
      #
      # ##### allow_blank
      #
      # Use `allow_blank` to assert that the attribute allows blank.
      #
      #     class Issue
      #       include ActiveModel::Model
      #       attr_accessor :state
      #
      #       validates_presence_of :state
      #       validates_inclusion_of :state,
      #         in: ['open', 'resolved', 'unresolved'],
      #         allow_blank: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should validate_inclusion_of(:state).
      #           in_array(['open', 'resolved', 'unresolved']).
      #           allow_blank
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class IssueTest < ActiveSupport::TestCase
      #       should validate_inclusion_of(:state).
      #         in_array(['open', 'resolved', 'unresolved']).
      #         allow_blank
      #     end
      #
      # @return [ValidateInclusionOfMatcher]
      #
      def validate_inclusion_of: (untyped attr) -> untyped

      # @private
      class ValidateInclusionOfMatcher < ValidationMatcher
        BLANK_VALUES: ::Array["" | " " | "\n" | "\r" | "\t" | "\f"]

        ARBITRARY_OUTSIDE_STRING: "shoulda-matchers test string"

        ARBITRARY_OUTSIDE_INTEGER: 123456789

        ARBITRARY_OUTSIDE_DECIMAL: untyped

        ARBITRARY_OUTSIDE_DATE: untyped

        ARBITRARY_OUTSIDE_DATETIME: untyped

        ARBITRARY_OUTSIDE_TIME: untyped

        BOOLEAN_ALLOWS_BOOLEAN_MESSAGE: "You are using `validate_inclusion_of` to assert that a boolean column allows\nboolean values and disallows non-boolean ones. Be aware that it is not possible\nto fully test this, as boolean columns will automatically convert non-boolean\nvalues to boolean ones. Hence, you should consider removing this test.\n"

        BOOLEAN_ALLOWS_NIL_MESSAGE: "You are using `validate_inclusion_of` to assert that a boolean column allows nil.\nBe aware that it is not possible to fully test this, as anything other than\ntrue, false or nil will be converted to false. Hence, you should consider\nremoving this test.\n"

        def initialize: (untyped attribute) -> void

        def in_array: (untyped array) -> self

        def in_range: (untyped range) -> self

        def allow_nil: () -> self

        def expects_to_allow_nil?: () -> untyped

        def with_message: (untyped message) -> self

        def with_low_message: (untyped message) -> self

        def with_high_message: (untyped message) -> self

        def simple_description: () -> untyped

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        private

        def matches_for_range?: () -> untyped

        def does_not_match_for_range?: () -> untyped

        def matches_for_array?: () -> untyped

        def does_not_match_for_array?: () -> untyped

        def allows_lower_value: () -> untyped

        def disallows_lower_value: () -> untyped

        def allows_minimum_value: () -> untyped

        def disallows_minimum_value: () -> untyped

        def allows_maximum_value: () -> untyped

        def disallows_maximum_value: () -> untyped

        def allows_higher_value: () -> untyped

        def disallows_higher_value: () -> untyped

        def allows_all_values_in_array?: () -> untyped

        def disallows_any_values_in_array?: () -> untyped

        def allows_any_value_outside_of_array?: () -> (true | untyped)

        def disallows_all_values_outside_of_array?: () -> (true | untyped)

        def values_outside_of_array: () -> untyped

        def outside_values: () -> untyped

        def boolean_outside_values: () -> untyped

        def attribute_type: () -> untyped

        def attribute_allows_nil?: () -> (untyped | true)

        def attribute_column: () -> (untyped | nil)

        def column_type_to_attribute_type: (untyped `type`) -> untyped

        def value_to_attribute_type: (untyped value) -> untyped

        def allows_nil_value?: () -> untyped

        def disallows_nil_value?: () -> untyped

        def inspected_array: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      class ValidationMatcher
        include Qualifiers::IgnoringInterferenceByWriter

        def initialize: (untyped attribute) -> void

        def description: () -> untyped

        def on: (untyped context) -> self

        def allow_blank: () -> self

        def strict: () -> self

        def expects_strict?: () -> untyped

        def with_message: (untyped expected_message) -> self

        def expects_custom_validation_message?: () -> untyped

        def matches?: (untyped subject) -> false

        def does_not_match?: (untyped subject) -> true

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> untyped

        attr_reader attribute: untyped

        attr_reader context: untyped

        attr_reader subject: untyped

        attr_reader last_submatcher_run: untyped

        def model: () -> untyped

        def allows_value_of: (untyped value, ?untyped? message) ?{ () -> untyped } -> untyped

        def disallows_value_of: (untyped value, ?untyped? message) ?{ () -> untyped } -> untyped

        def allow_value_matcher: (untyped value, ?untyped? message) ?{ () -> untyped } -> untyped

        def disallow_value_matcher: (untyped value, ?untyped? message) ?{ () -> untyped } -> untyped

        def allow_blank_matches?: () -> untyped

        def allow_blank_does_not_match?: () -> untyped

        private

        attr_reader options: untyped

        def overall_failure_message: () -> untyped

        def overall_failure_message_when_negated: () -> untyped

        def failure_reason: () -> untyped

        def failure_reason_when_negated: () -> untyped

        def build_allow_or_disallow_value_matcher: (untyped args) { (untyped) -> untyped } -> untyped

        def run_allow_or_disallow_matcher: (untyped matcher) -> untyped

        def expects_to_allow_blank?: () -> untyped

        def blank_values: () -> ::Array["" | " " | "\n" | "\r" | "\t" | "\f"]
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      class CouldNotDetermineValueOutsideOfArray < RuntimeError
      end

      # @private
      class NonNullableBooleanError < Shoulda::Matchers::Error
        def self.create: (untyped attribute) -> untyped

        attr_accessor attribute: untyped

        def message: () -> untyped
      end

      # @private
      class CouldNotSetPasswordError < Shoulda::Matchers::Error
        def self.create: (untyped model) -> untyped

        attr_accessor model: untyped

        def message: () -> untyped

        private

        def model_name: () -> untyped

        def record_name: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module NumericalityMatchers
        # @private
        class EvenNumberMatcher < NumericTypeMatcher
          NON_EVEN_NUMBER_VALUE: 1

          def simple_description: () -> untyped

          def allowed_type_adjective: () -> "even"

          def diff_to_compare: () -> 2

          def wrap_disallow_value_matcher: (untyped matcher) -> untyped

          def disallowed_value: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module NumericalityMatchers
        # @private
        class NumericTypeMatcher
          # extend Forwardable

          def initialize: (untyped numeric_type_matcher, untyped attribute) -> void

          def allowed_type_name: () -> "number"

          def allowed_type_adjective: () -> ""

          def diff_to_compare: () -> untyped

          attr_reader attribute: untyped

          def wrap_disallow_value_matcher: (untyped _matcher) -> untyped

          def disallowed_value: () -> untyped

          private

          def disallow_value_matcher: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module NumericalityMatchers
        # @private
        class OddNumberMatcher < NumericTypeMatcher
          NON_ODD_NUMBER_VALUE: 2

          def simple_description: () -> untyped

          def allowed_type_adjective: () -> "odd"

          def diff_to_compare: () -> 2

          def wrap_disallow_value_matcher: (untyped matcher) -> untyped

          def disallowed_value: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module NumericalityMatchers
        # @private
        class OnlyIntegerMatcher < NumericTypeMatcher
          NON_INTEGER_VALUE: ::Float

          def simple_description: () -> untyped

          def allowed_type_name: () -> "integer"

          def diff_to_compare: () -> 1

          def wrap_disallow_value_matcher: (untyped matcher) -> untyped

          def disallowed_value: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module NumericalityMatchers
        # @private
        class ComparisonMatcher < ValidationMatcher
          ERROR_MESSAGES: { :> => { label: :greater_than, assertions: ::Array[false | true] }, :>= => { label: :greater_than_or_equal_to, assertions: ::Array[false | true] }, :< => { label: :less_than, assertions: ::Array[true | false] }, :<= => { label: :less_than_or_equal_to, assertions: ::Array[true | false] }, :== => { label: :equal_to, assertions: ::Array[false | true] }, :!= => { label: :other_than, assertions: ::Array[true | false] } }

          def initialize: (untyped numericality_matcher, untyped value, untyped operator) -> void

          def simple_description: () -> untyped

          def for: (untyped attribute) -> self

          def with_message: (untyped message) -> self

          def expects_custom_validation_message?: () -> untyped

          def matches?: (untyped subject) -> untyped

          def failure_message: () -> untyped

          def failure_message_when_negated: () -> untyped

          def comparison_description: () -> ::String

          private

          def all_bounds_correct?: () -> untyped

          def failing_submatchers: () -> untyped

          def last_failing_submatcher: () -> untyped

          def submatchers: () -> untyped

          def submatchers_and_results: () -> untyped

          def comparison_combos: () -> untyped

          def submatcher_method_names: () -> untyped

          def assertions: () -> untyped

          def diffs_to_compare: () -> untyped

          def comparison_expectation: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class AttributeDoesNotExistError < Shoulda::Matchers::Error
          attr_accessor model: untyped

          attr_accessor attribute_name: untyped

          attr_accessor value: untyped

          def message: () -> untyped

          def successful?: () -> false
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class AttributeSetters
          include Enumerable[untyped]

          def initialize: (untyped allow_value_matcher, untyped values) -> void

          def each: () ?{ () -> untyped } -> untyped

          def first_failing: () -> untyped

          attr_reader tuples: untyped

          private

          def does_not_match?: (untyped tuple) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class AttributeSetterAndValidator
          # extend Forwardable

          def initialize: (untyped allow_value_matcher, untyped attribute_name, untyped value) -> void

          def attribute_setter: () -> untyped

          def attribute_setter_description: () -> untyped

          def validator: () -> untyped

          attr_reader allow_value_matcher: untyped

          attr_reader attribute_name: untyped

          attr_reader value: untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class AttributeChangedValueError < Shoulda::Matchers::Error
          attr_accessor matcher_name: untyped

          attr_accessor model: untyped

          attr_accessor attribute_name: untyped

          attr_accessor value_written: untyped

          attr_accessor value_read: untyped

          def message: () -> untyped

          def successful?: () -> false
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class AttributeSettersAndValidators
          include Enumerable[untyped]

          def initialize: (untyped allow_value_matcher, untyped values) -> void

          def each: () ?{ () -> untyped } -> untyped

          def first_passing: () -> untyped

          def first_failing: () -> untyped

          attr_reader tuples: untyped

          private

          def matches?: (untyped tuple) -> untyped

          def does_not_match?: (untyped tuple) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class SuccessfulCheck
          def successful?: () -> true
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class SuccessfulSetting
          def successful?: () -> true
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class AllowValueMatcher
        # @private
        class AttributeSetter
          def self.set: (untyped args) -> untyped

          attr_reader attribute_name: untyped

          attr_reader result_of_checking: untyped

          attr_reader result_of_setting: untyped

          attr_reader value_written: untyped

          def initialize: (untyped args) -> void

          def description: () -> untyped

          def run: () -> untyped

          def run!: () -> untyped

          def check: () -> (true | false)

          def set!: () -> (true | untyped)

          def set: () -> untyped

          def failure_message: () -> untyped

          def successful?: () -> untyped

          def unsuccessful?: () -> untyped

          def checked?: () -> untyped

          def successfully_checked?: () -> untyped

          def unsuccessfully_checked?: () -> untyped

          def set?: () -> untyped

          def successfully_set?: () -> untyped

          def value_read: () -> untyped

          def attribute_changed_value?: () -> untyped

          attr_reader args: untyped

          attr_reader matcher_name: untyped

          attr_reader object: untyped

          attr_reader after_set_callback: untyped

          private

          def model: () -> untyped

          def attribute_exists?: () -> untyped

          def ignore_interference_by_writer: () -> untyped

          def raise_attribute_changed_value_error?: () -> untyped

          def attribute_is_an_enum?: () -> untyped

          def value_read_is_expected_for_an_enum?: () -> untyped

          def enum_values: () -> untyped

          def defined_enums: () -> (untyped | ::Hash[untyped, untyped])

          def successful_check: () -> untyped

          def successful_setting: () -> untyped

          def attribute_changed_value!: () -> untyped

          def attribute_changed_value_error: () -> untyped

          def attribute_does_not_exist!: () -> untyped

          def attribute_does_not_exist_error: () -> untyped

          def active_resource_object?: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_presence_of` matcher tests usage of the
      # `validates_presence_of` validation.
      #
      #     class Robot
      #       include ActiveModel::Model
      #       attr_accessor :arms
      #
      #       validates_presence_of :arms
      #     end
      #
      #     # RSpec
      #     RSpec.describe Robot, type: :model do
      #       it { should validate_presence_of(:arms) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RobotTest < ActiveSupport::TestCase
      #       should validate_presence_of(:arms)
      #     end
      #
      # #### Caveats
      #
      # Under Rails 4 and greater, if your model `has_secure_password` and you
      # are validating presence of the password using a record whose password
      # has already been set prior to calling the matcher, you will be
      # instructed to use a record whose password is empty instead.
      #
      # For example, given this scenario:
      #
      #     class User < ActiveRecord::Base
      #       has_secure_password validations: false
      #
      #       validates_presence_of :password
      #     end
      #
      #     RSpec.describe User, type: :model do
      #       subject { User.new(password: '123456') }
      #
      #       it { should validate_presence_of(:password) }
      #     end
      #
      # the above test will raise an error like this:
      #
      #     The validation failed because your User model declares
      #     `has_secure_password`, and `validate_presence_of` was called on a
      #     user which has `password` already set to a value. Please use a user
      #     with an empty `password` instead.
      #
      # This happens because `has_secure_password` itself overrides your model
      # so that it is impossible to set `password` to nil. This means that it is
      # impossible to test that setting `password` to nil places your model in
      # an invalid state (which in turn means that the validation itself is
      # unnecessary).
      #
      # #### Qualifiers
      #
      # ##### allow_nil
      #
      # Use `allow_nil` if your model has an optional attribute.
      #
      #   class Robot
      #     include ActiveModel::Model
      #     attr_accessor :nickname
      #
      #     validates_presence_of :nickname, allow_nil: true
      #   end
      #
      #   # RSpec
      #   RSpec.describe Robot, type: :model do
      #     it { should validate_presence_of(:nickname).allow_nil }
      #   end
      #
      #   # Minitest (Shoulda)
      #   class RobotTest < ActiveSupport::TestCase
      #     should validate_presence_of(:nickname).allow_nil
      #   end
      #
      # #### allow_blank
      #
      # Use `allow_blank` to assert that the attribute allows blank.
      #
      #   class Robot
      #     include ActiveModel::Model
      #     attr_accessor :nickname
      #
      #     validates_presence_of :nickname, allow_blank: true
      #   end
      #
      #   # RSpec
      #   RSpec.describe Robot, type: :model do
      #     it { should validate_presence_of(:nickname).allow_blank }
      #   end
      #
      #   # Minitest (Shoulda)
      #   class RobotTest < ActiveSupport::TestCase
      #     should validate_presence_of(:nickname).allow_blank
      #   end
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class Robot
      #       include ActiveModel::Model
      #       attr_accessor :arms
      #
      #       validates_presence_of :arms, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe Robot, type: :model do
      #       it { should validate_presence_of(:arms).on(:create) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RobotTest < ActiveSupport::TestCase
      #       should validate_presence_of(:arms).on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class Robot
      #       include ActiveModel::Model
      #       attr_accessor :legs
      #
      #       validates_presence_of :legs, message: 'Robot has no legs'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Robot, type: :model do
      #       it do
      #         should validate_presence_of(:legs).
      #           with_message('Robot has no legs')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RobotTest < ActiveSupport::TestCase
      #       should validate_presence_of(:legs).
      #         with_message('Robot has no legs')
      #     end
      #
      # @return [ValidatePresenceOfMatcher]
      #
      def validate_presence_of: (untyped attr) -> untyped

      # @private
      class ValidatePresenceOfMatcher < ValidationMatcher
        include Qualifiers::AllowNil

        include Qualifiers::AllowBlank

        def initialize: (untyped attribute) -> void

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        def simple_description: () -> ::String

        def failure_message: () -> untyped

        private

        def secure_password_being_validated?: () -> untyped

        def possibly_ignore_interference_by_writer: () -> (untyped | nil)

        def allows_and_double_checks_value_of!: (untyped value) -> untyped

        def allows_original_or_typecast_value?: (untyped value) -> untyped

        def disallows_and_double_checks_value_of!: (untyped value) -> untyped

        def disallows_original_or_typecast_value?: (untyped value) -> untyped

        def disallowed_values: () -> (::Array[untyped] | ::Array[nil] | untyped)

        def should_add_footnote_about_belongs_to?: () -> untyped

        def reason_for_existing_presence_validation: () -> ("you've instructed your `belongs_to` association to add a presence validation to the attribute" | "ActiveRecord is configured to add a presence validation to all `belongs_to` associations, and this includes yours")

        def suggestions_for_belongs_to: () -> ::String

        def example_of_belongs_to: (?with: untyped?) -> untyped

        def belongs_to_association_configured_to_be_required?: () -> untyped

        def belongs_to_association_being_validated?: () -> untyped

        def attribute_accepts_string_values?: () -> (false | untyped)

        def association?: () -> untyped

        def collection_association?: () -> untyped

        def attachment?: () -> untyped

        def association_name: () -> untyped

        def association_options: () -> untyped

        def association_reflection: () -> untyped

        def model_has_associations?: (untyped associations) -> untyped

        def attribute_serialization_coder: () -> untyped

        def attribute_type: () -> untyped

        def presence_validation_exists_on_attribute?: () -> untyped

        def model: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module Qualifiers
        # @private
        module AllowBlank
          def initialize: (*untyped args) -> void

          def allow_blank: () -> self

          def expects_to_allow_blank?: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module Qualifiers
        # @private
        class IgnoreInterferenceByWriter
          attr_reader setting: untyped

          attr_reader condition: untyped

          def initialize: (?::Symbol argument) -> void

          def set: (untyped argument) -> untyped

          def default_to: (untyped argument) -> self

          def considering?: (untyped value) -> untyped

          def always?: () -> untyped

          def never?: () -> untyped

          def changed?: () -> untyped

          private

          def invalid_argument_error: (untyped invalid_argument) -> untyped

          def condition_matches?: (untyped value) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module Qualifiers
        # @private
        module IgnoringInterferenceByWriter
          attr_reader ignore_interference_by_writer: untyped

          def initialize: () -> void

          def ignoring_interference_by_writer: (?::Symbol value) -> self
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      module Qualifiers
        # @private
        module AllowNil
          def initialize: (*untyped args) -> void

          def allow_nil: () -> self

          def expects_to_allow_nil?: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_confirmation_of` matcher tests usage of the
      # `validates_confirmation_of` validation.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :email
      #
      #       validates_confirmation_of :email
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should validate_confirmation_of(:email) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_confirmation_of(:email)
      #     end
      #
      # #### Qualifiers
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :password
      #
      #       validates_confirmation_of :password, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should validate_confirmation_of(:password).on(:create) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_confirmation_of(:password).on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :password
      #
      #       validates_confirmation_of :password,
      #         message: 'Please re-enter your password'
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it do
      #         should validate_confirmation_of(:password).
      #           with_message('Please re-enter your password')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_confirmation_of(:password).
      #         with_message('Please re-enter your password')
      #     end
      #
      # @return [ValidateConfirmationOfMatcher]
      #
      def validate_confirmation_of: (untyped attr) -> untyped

      # @private
      class ValidateConfirmationOfMatcher < ValidationMatcher
        include Helpers

        attr_reader attribute: untyped

        attr_reader confirmation_attribute: untyped

        def initialize: (untyped attribute) -> void

        def simple_description: () -> ::String

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        private

        def allows_different_value: () -> untyped

        def disallows_different_value: () -> untyped

        def allows_same_value: () -> untyped

        def disallows_same_value: () -> untyped

        def allows_missing_confirmation: () -> untyped

        def disallows_missing_confirmation: () -> untyped

        def qualify_matcher: (untyped matcher, untyped confirmation_attribute_value) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_acceptance_of` matcher tests usage of the
      # `validates_acceptance_of` validation.
      #
      #     class Registration
      #       include ActiveModel::Model
      #       attr_accessor :eula
      #
      #       validates_acceptance_of :eula
      #     end
      #
      #     # RSpec
      #     RSpec.describe Registration, type: :model do
      #       it { should validate_acceptance_of(:eula) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RegistrationTest < ActiveSupport::TestCase
      #       should validate_acceptance_of(:eula)
      #     end
      #
      # #### Qualifiers
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class Registration
      #       include ActiveModel::Model
      #       attr_accessor :terms_of_service
      #
      #       validates_acceptance_of :terms_of_service, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe Registration, type: :model do
      #       it do
      #         should validate_acceptance_of(:terms_of_service).
      #           on(:create)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RegistrationTest < ActiveSupport::TestCase
      #       should validate_acceptance_of(:terms_of_service).on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class Registration
      #       include ActiveModel::Model
      #       attr_accessor :terms_of_service
      #
      #       validates_acceptance_of :terms_of_service,
      #         message: 'You must accept the terms of service'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Registration, type: :model do
      #       it do
      #         should validate_acceptance_of(:terms_of_service).
      #           with_message('You must accept the terms of service')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class RegistrationTest < ActiveSupport::TestCase
      #       should validate_acceptance_of(:terms_of_service).
      #         with_message('You must accept the terms of service')
      #     end
      #
      # @return [ValidateAcceptanceOfMatcher]
      #
      def validate_acceptance_of: (untyped attr) -> untyped

      # @private
      class ValidateAcceptanceOfMatcher < ValidationMatcher
        def initialize: (untyped attribute) -> void

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        def simple_description: () -> ::String
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      module NumericalityMatchers
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      module Qualifiers
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_length_of` matcher tests usage of the
      # `validates_length_of` matcher. Note that this matcher is intended to be
      # used against string columns and not integer columns.
      #
      # #### Qualifiers
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :password
      #
      #       validates_length_of :password, minimum: 10, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it do
      #         should validate_length_of(:password).
      #           is_at_least(10).
      #           on(:create)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:password).
      #         is_at_least(10).
      #         on(:create)
      #     end
      #
      # ##### is_at_least
      #
      # Use `is_at_least` to test usage of the `:minimum` option. This asserts
      # that the attribute can take a string which is equal to or longer than
      # the given length and cannot take a string which is shorter.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :bio
      #
      #       validates_length_of :bio, minimum: 15
      #     end
      #
      #     # RSpec
      #
      #     RSpec.describe User, type: :model do
      #       it { should validate_length_of(:bio).is_at_least(15) }
      #     end
      #
      #     # Minitest (Shoulda)
      #
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:bio).is_at_least(15)
      #     end
      #
      # ##### is_at_most
      #
      # Use `is_at_most` to test usage of the `:maximum` option. This asserts
      # that the attribute can take a string which is equal to or shorter than
      # the given length and cannot take a string which is longer.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :status_update
      #
      #       validates_length_of :status_update, maximum: 140
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should validate_length_of(:status_update).is_at_most(140) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:status_update).is_at_most(140)
      #     end
      #
      # ##### is_equal_to
      #
      # Use `is_equal_to` to test usage of the `:is` option. This asserts that
      # the attribute can take a string which is exactly equal to the given
      # length and cannot take a string which is shorter or longer.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :favorite_superhero
      #
      #       validates_length_of :favorite_superhero, is: 6
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should validate_length_of(:favorite_superhero).is_equal_to(6) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:favorite_superhero).is_equal_to(6)
      #     end
      #
      # ##### is_at_least + is_at_most
      #
      # Use `is_at_least` and `is_at_most` together to test usage of the `:in`
      # option.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :password
      #
      #       validates_length_of :password, in: 5..30
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it do
      #         should validate_length_of(:password).
      #           is_at_least(5).is_at_most(30)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:password).
      #         is_at_least(5).is_at_most(30)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :password
      #
      #       validates_length_of :password,
      #         minimum: 10,
      #         message: "Password isn't long enough"
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it do
      #         should validate_length_of(:password).
      #           is_at_least(10).
      #           with_message("Password isn't long enough")
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:password).
      #         is_at_least(10).
      #         with_message("Password isn't long enough")
      #     end
      #
      # ##### with_short_message
      #
      # Use `with_short_message` if you are using a custom "too short" message.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :secret_key
      #
      #       validates_length_of :secret_key,
      #         in: 15..100,
      #         too_short: 'Secret key must be more than 15 characters'
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it do
      #         should validate_length_of(:secret_key).
      #           is_at_least(15).
      #           with_short_message('Secret key must be more than 15 characters')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:secret_key).
      #         is_at_least(15).
      #         with_short_message('Secret key must be more than 15 characters')
      #     end
      #
      # ##### with_long_message
      #
      # Use `with_long_message` if you are using a custom "too long" message.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :secret_key
      #
      #       validates_length_of :secret_key,
      #         in: 15..100,
      #         too_long: 'Secret key must be less than 100 characters'
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it do
      #         should validate_length_of(:secret_key).
      #           is_at_most(100).
      #           with_long_message('Secret key must be less than 100 characters')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:secret_key).
      #         is_at_most(100).
      #         with_long_message('Secret key must be less than 100 characters')
      #     end
      #
      # ##### allow_nil
      #
      # Use `allow_nil` to assert that the attribute allows nil.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :bio
      #
      #       validates_length_of :bio, minimum: 15, allow_nil: true
      #     end
      #
      #     # RSpec
      #     describe User do
      #       it { should validate_length_of(:bio).is_at_least(15).allow_nil }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:bio).is_at_least(15).allow_nil
      #     end
      #
      # @return [ValidateLengthOfMatcher]
      #
      # ##### allow_blank
      #
      # Use `allow_blank` to assert that the attribute allows blank.
      #
      #     class User
      #       include ActiveModel::Model
      #       attr_accessor :bio
      #
      #       validates_length_of :bio, minimum: 15, allow_blank: true
      #     end
      #
      #     # RSpec
      #     describe User do
      #       it { should validate_length_of(:bio).is_at_least(15).allow_blank }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should validate_length_of(:bio).is_at_least(15).allow_blank
      #     end
      #
      def validate_length_of: (untyped attr) -> untyped

      # @private
      class ValidateLengthOfMatcher < ValidationMatcher
        include Helpers

        def initialize: (untyped attribute) -> void

        def is_at_least: (untyped length) -> self

        def is_at_most: (untyped length) -> self

        def is_equal_to: (untyped length) -> self

        def with_message: (untyped message) -> self

        def with_short_message: (untyped message) -> self

        def with_long_message: (untyped message) -> self

        def allow_nil: () -> self

        def simple_description: () -> untyped

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        private

        def expects_to_allow_nil?: () -> untyped

        def lower_bound_matches?: () -> untyped

        def lower_bound_does_not_match?: () -> untyped

        def upper_bound_matches?: () -> untyped

        def upper_bound_does_not_match?: () -> untyped

        def allows_lower_length?: () -> untyped

        def disallows_lower_length?: () -> untyped

        def allows_higher_length?: () -> untyped

        def disallows_higher_length?: () -> untyped

        def allows_minimum_length?: () -> untyped

        def disallows_minimum_length?: () -> untyped

        def allows_maximum_length?: () -> untyped

        def disallows_maximum_length?: () -> untyped

        def allow_nil_matches?: () -> untyped

        def allow_nil_does_not_match?: () -> untyped

        def allows_length_of?: (untyped length, untyped message) -> untyped

        def disallows_length_of?: (untyped length, untyped message) -> untyped

        def string_of_length: (untyped length) -> untyped

        def translated_short_message: () -> untyped

        def translated_long_message: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `have_secure_password` matcher tests usage of the
      # `has_secure_password` macro.
      #
      # #### Example
      #
      #     class User
      #       include ActiveModel::Model
      #       include ActiveModel::SecurePassword
      #       attr_accessor :password
      #       attr_accessor :reset_password
      #
      #       has_secure_password
      #       has_secure_password :reset_password
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should have_secure_password }
      #       it { should have_secure_password(:reset_password) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should have_secure_password
      #       should have_secure_password(:reset_password)
      #     end
      #
      # @return [HaveSecurePasswordMatcher]
      #
      def have_secure_password: (?::Symbol attr) -> untyped

      # @private
      class HaveSecurePasswordMatcher
        attr_reader failure_message: untyped

        CORRECT_PASSWORD: "aBcDe12345"

        INCORRECT_PASSWORD: "password"

        MESSAGES: { authenticated_incorrect_password: "expected %{subject} to not authenticate an incorrect %{attribute}", did_not_authenticate_correct_password: "expected %{subject} to authenticate the correct %{attribute}", method_not_found: "expected %{subject} to respond to %{methods}" }

        def initialize: (untyped attribute) -> void

        def description: () -> ::String

        def matches?: (untyped subject) -> untyped

        attr_reader subject: untyped

        def validate: () -> untyped

        private

        def expected_methods: () -> untyped

        def authenticate_method: () -> (:authenticate | untyped)
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      class DisallowValueMatcher
        # extend Forwardable

        def initialize: (untyped value) -> void

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        def for: (untyped attribute) -> self

        def on: (untyped context) -> self

        def with_message: (untyped message, ?::Hash[untyped, untyped] options) -> self

        def strict: (?bool strict) -> self

        def ignoring_interference_by_writer: (?::Symbol value) -> self

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> untyped

        attr_reader allow_matcher: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      class ValidationMatcher
        # @private
        class BuildDescription
          def self.call: (untyped matcher, untyped main_description) -> untyped

          def initialize: (untyped matcher, untyped main_description) -> void

          def call: () -> (::String | untyped)

          attr_reader matcher: untyped

          attr_reader main_description: untyped

          private

          def clause_for_allow_blank_or_nil: () -> (" as long as it is not blank" | " as long as it is not nil" | "")

          def description_clauses_for_qualifiers: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_absence_of` matcher tests the usage of the
      # `validates_absence_of` validation.
      #
      #     class PowerHungryCountry
      #       include ActiveModel::Model
      #       attr_accessor :nuclear_weapons
      #
      #       validates_absence_of :nuclear_weapons
      #     end
      #
      #     # RSpec
      #     RSpec.describe PowerHungryCountry, type: :model do
      #       it { should validate_absence_of(:nuclear_weapons) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PowerHungryCountryTest < ActiveSupport::TestCase
      #       should validate_absence_of(:nuclear_weapons)
      #     end
      #
      # #### Qualifiers
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class PowerHungryCountry
      #       include ActiveModel::Model
      #       attr_accessor :nuclear_weapons
      #
      #       validates_absence_of :nuclear_weapons, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe PowerHungryCountry, type: :model do
      #       it { should validate_absence_of(:nuclear_weapons).on(:create) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PowerHungryCountryTest < ActiveSupport::TestCase
      #       should validate_absence_of(:nuclear_weapons).on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class PowerHungryCountry
      #       include ActiveModel::Model
      #       attr_accessor :nuclear_weapons
      #
      #       validates_absence_of :nuclear_weapons,
      #         message: "there shall be peace on Earth"
      #     end
      #
      #     # RSpec
      #     RSpec.describe PowerHungryCountry, type: :model do
      #       it do
      #         should validate_absence_of(:nuclear_weapons).
      #           with_message("there shall be peace on Earth")
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PowerHungryCountryTest < ActiveSupport::TestCase
      #       should validate_absence_of(:nuclear_weapons).
      #         with_message("there shall be peace on Earth")
      #     end
      #
      # @return [ValidateAbsenceOfMatcher}
      #
      def validate_absence_of: (untyped attr) -> untyped

      # @private
      class ValidateAbsenceOfMatcher < ValidationMatcher
        def initialize: (untyped attribute) -> void

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        def simple_description: () -> ::String

        private

        def value: () -> (untyped | ::Array["an arbitary value"] | untyped)

        def column_type: () -> untyped

        def collection?: () -> (untyped | false)

        def reflection: () -> untyped

        def array_column?: () -> untyped

        def enum_column?: () -> untyped

        def enum_values: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # The `validate_exclusion_of` matcher tests usage of the
      # `validates_exclusion_of` validation, asserting that an attribute cannot
      # take a blacklist of values, and inversely, can take values outside of
      # this list.
      #
      # If your blacklist is an array of values, use `in_array`:
      #
      #     class Game
      #       include ActiveModel::Model
      #       attr_accessor :supported_os
      #
      #       validates_exclusion_of :supported_os, in: ['Mac', 'Linux']
      #     end
      #
      #     # RSpec
      #     RSpec.describe Game, type: :model do
      #       it do
      #         should validate_exclusion_of(:supported_os).
      #           in_array(['Mac', 'Linux'])
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class GameTest < ActiveSupport::TestCase
      #       should validate_exclusion_of(:supported_os).
      #         in_array(['Mac', 'Linux'])
      #     end
      #
      # If your blacklist is a range of values, use `in_range`:
      #
      #     class Game
      #       include ActiveModel::Model
      #       attr_accessor :supported_os
      #
      #       validates_exclusion_of :supported_os, in: 5..8
      #     end
      #
      #     # RSpec
      #     RSpec.describe Game, type: :model do
      #       it do
      #         should validate_exclusion_of(:floors_with_enemies).
      #           in_range(5..8)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class GameTest < ActiveSupport::TestCase
      #       should validate_exclusion_of(:floors_with_enemies).
      #         in_range(5..8)
      #     end
      #
      # #### Qualifiers
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class Game
      #       include ActiveModel::Model
      #       attr_accessor :weapon
      #
      #       validates_exclusion_of :weapon,
      #         in: ['pistol', 'paintball gun', 'stick'],
      #         on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe Game, type: :model do
      #       it do
      #         should validate_exclusion_of(:weapon).
      #           in_array(['pistol', 'paintball gun', 'stick']).
      #           on(:create)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class GameTest < ActiveSupport::TestCase
      #       should validate_exclusion_of(:weapon).
      #         in_array(['pistol', 'paintball gun', 'stick']).
      #         on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class Game
      #       include ActiveModel::Model
      #       attr_accessor :weapon
      #
      #       validates_exclusion_of :weapon,
      #         in: ['pistol', 'paintball gun', 'stick'],
      #         message: 'You chose a puny weapon'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Game, type: :model do
      #       it do
      #         should validate_exclusion_of(:weapon).
      #           in_array(['pistol', 'paintball gun', 'stick']).
      #           with_message('You chose a puny weapon')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class GameTest < ActiveSupport::TestCase
      #       should validate_exclusion_of(:weapon).
      #         in_array(['pistol', 'paintball gun', 'stick']).
      #         with_message('You chose a puny weapon')
      #     end
      #
      # @return [ValidateExclusionOfMatcher]
      #
      def validate_exclusion_of: (untyped attr) -> untyped

      # @private
      class ValidateExclusionOfMatcher < ValidationMatcher
        def initialize: (untyped attribute) -> void

        def in_array: (untyped array) -> self

        def in_range: (untyped range) -> self

        def simple_description: () -> untyped

        def matches?: (untyped subject) -> untyped

        def does_not_match?: (untyped subject) -> untyped

        private

        def allows_any_values_in_array?: () -> untyped

        def disallows_all_values_in_array?: () -> untyped

        def allows_lower_value: () -> untyped

        def disallows_lower_value: () -> untyped

        def allows_minimum_value: () -> untyped

        def disallows_minimum_value: () -> untyped

        def allows_maximum_value: () -> untyped

        def disallows_maximum_value: () -> untyped

        def allows_higher_value: () -> untyped

        def disallows_higher_value: () -> untyped

        def inspect_message: () -> untyped

        def inspected_array: () -> untyped
      end
    end
  end
end

class Object
  include Shoulda::Matchers::ActiveModel
end

module Shoulda
  module Matchers
    module ActiveModel : BasicObject
      # The `allow_value` matcher (or its alias, `allow_values`) is used to
      # ensure that an attribute is valid or invalid if set to one or more
      # values.
      #
      # Take this model for example:
      #
      #     class UserProfile
      #       include ActiveModel::Model
      #       attr_accessor :website_url
      #
      #       validates_format_of :website_url, with: URI.regexp
      #     end
      #
      # You can use `allow_value` to test one value at a time:
      #
      #     # RSpec
      #     RSpec.describe UserProfile, type: :model do
      #       it { should allow_value('https://foo.com').for(:website_url) }
      #       it { should allow_value('https://bar.com').for(:website_url) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserProfileTest < ActiveSupport::TestCase
      #       should allow_value('https://foo.com').for(:website_url)
      #       should allow_value('https://bar.com').for(:website_url)
      #     end
      #
      # You can also test multiple values in one go, if you like. In the
      # positive sense, this makes an assertion that none of the values cause the
      # record to be invalid. In the negative sense, this makes an assertion
      # that none of the values cause the record to be valid:
      #
      #     # RSpec
      #     RSpec.describe UserProfile, type: :model do
      #       it do
      #         should allow_values('https://foo.com', 'https://bar.com').
      #           for(:website_url)
      #       end
      #
      #       it do
      #         should_not allow_values('foo', 'buz').
      #           for(:website_url)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserProfileTest < ActiveSupport::TestCase
      #       should allow_values('https://foo.com', 'https://bar.com/baz').
      #         for(:website_url)
      #
      #       should_not allow_values('foo', 'buz').
      #         for(:website_url)
      #     end
      #
      # #### Caveats
      #
      # When using `allow_value` or any matchers that depend on it, you may
      # encounter an AttributeChangedValueError. This exception is raised if the
      # matcher, in attempting to set a value on the attribute, detects that
      # the value set is different from the value that the attribute returns
      # upon reading it back.
      #
      # This usually happens if the writer method (`foo=`, `bar=`, etc.) for
      # that attribute has custom logic to ignore certain incoming values or
      # change them in any way. Here are three examples we've seen:
      #
      # * You're attempting to assert that an attribute should not allow nil,
      #   yet the attribute's writer method contains a conditional to do nothing
      #   if the attribute is set to nil:
      #
      #         class Foo
      #           include ActiveModel::Model
      #
      #           attr_reader :bar
      #
      #           def bar=(value)
      #             return if value.nil?
      #             @bar = value
      #           end
      #         end
      #
      #         RSpec.describe Foo, type: :model do
      #           it do
      #             foo = Foo.new
      #             foo.bar = "baz"
      #             # This will raise an AttributeChangedValueError since `foo.bar` is now "123"
      #             expect(foo).not_to allow_value(nil).for(:bar)
      #           end
      #         end
      #
      # * You're attempting to assert that a numeric attribute should not allow
      #   a string that contains non-numeric characters, yet the writer method
      #   for that attribute strips out non-numeric characters:
      #
      #         class Foo
      #           include ActiveModel::Model
      #
      #           attr_reader :bar
      #
      #           def bar=(value)
      #             @bar = value.gsub(/\D+/, '')
      #           end
      #         end
      #
      #         RSpec.describe Foo, type: :model do
      #           it do
      #             foo = Foo.new
      #             # This will raise an AttributeChangedValueError since `foo.bar` is now "123"
      #             expect(foo).not_to allow_value("abc123").for(:bar)
      #           end
      #         end
      #
      # * You're passing a value to `allow_value` that the model typecasts into
      #   another value:
      #
      #         RSpec.describe Foo, type: :model do
      #           # Assume that `attr` is a string
      #           # This will raise an AttributeChangedValueError since `attr` typecasts `[]` to `"[]"`
      #           it { should_not allow_value([]).for(:attr) }
      #         end
      #
      # Fortunately, if you understand why this is happening, and wish to get
      # around this exception, it is possible to do so. You can use the
      # `ignoring_interference_by_writer` qualifier like so:
      #
      #         it do
      #           should_not allow_value([]).
      #             for(:attr).
      #             ignoring_interference_by_writer
      #         end
      #
      # Please note, however, that this qualifier won't magically cause your
      # test to pass. It may just so happen that the final value that ends up
      # being set causes the model to fail validation. In that case, you'll have
      # to figure out what to do. You may need to write your own test, or
      # perhaps even remove your test altogether.
      #
      # #### Qualifiers
      #
      # ##### on
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class UserProfile
      #       include ActiveModel::Model
      #       attr_accessor :birthday_as_string
      #
      #       validates_format_of :birthday_as_string,
      #         with: /^(\d+)-(\d+)-(\d+)$/,
      #         on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe UserProfile, type: :model do
      #       it do
      #         should allow_value('2013-01-01').
      #           for(:birthday_as_string).
      #           on(:create)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserProfileTest < ActiveSupport::TestCase
      #       should allow_value('2013-01-01').
      #         for(:birthday_as_string).
      #         on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class UserProfile
      #       include ActiveModel::Model
      #       attr_accessor :state
      #
      #       validates_format_of :state,
      #         with: /^(open|closed)$/,
      #         message: 'State must be open or closed'
      #     end
      #
      #     # RSpec
      #     RSpec.describe UserProfile, type: :model do
      #       it do
      #         should allow_value('open', 'closed').
      #           for(:state).
      #           with_message('State must be open or closed')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserProfileTest < ActiveSupport::TestCase
      #       should allow_value('open', 'closed').
      #         for(:state).
      #         with_message('State must be open or closed')
      #     end
      #
      # Use `with_message` with a regexp to perform a partial match:
      #
      #     class UserProfile
      #       include ActiveModel::Model
      #       attr_accessor :state
      #
      #       validates_format_of :state,
      #         with: /^(open|closed)$/,
      #         message: 'State must be open or closed'
      #     end
      #
      #     # RSpec
      #     RSpec.describe UserProfile, type: :model do
      #       it do
      #         should allow_value('open', 'closed').
      #           for(:state).
      #           with_message(/open or closed/)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserProfileTest < ActiveSupport::TestCase
      #       should allow_value('open', 'closed').
      #         for(:state).
      #         with_message(/open or closed/)
      #     end
      #
      # Use `with_message` with the `:against` option if the attribute the
      # validation message is stored under is different from the attribute
      # being validated:
      #
      #     class UserProfile
      #       include ActiveModel::Model
      #       attr_accessor :sports_team
      #
      #       validate :sports_team_must_be_valid
      #
      #       private
      #
      #       def sports_team_must_be_valid
      #         if sports_team !~ /^(Broncos|Titans)$/i
      #           self.errors.add :chosen_sports_team,
      #             'Must be either a Broncos fan or a Titans fan'
      #         end
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe UserProfile, type: :model do
      #       it do
      #         should allow_value('Broncos', 'Titans').
      #           for(:sports_team).
      #           with_message('Must be either a Broncos or Titans fan',
      #             against: :chosen_sports_team
      #           )
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserProfileTest < ActiveSupport::TestCase
      #       should allow_value('Broncos', 'Titans').
      #         for(:sports_team).
      #         with_message('Must be either a Broncos or Titans fan',
      #           against: :chosen_sports_team
      #         )
      #     end
      #
      # ##### ignoring_interference_by_writer
      #
      # Use `ignoring_interference_by_writer` to bypass an
      # AttributeChangedValueError that you have encountered. Please read the
      # Caveats section above for more information.
      #
      #     class Address < ActiveRecord::Base
      #       # Address has a zip_code field which is a string
      #     end
      #
      #     # RSpec
      #     RSpec.describe Address, type: :model do
      #       it do
      #         should_not allow_value([]).
      #           for(:zip_code).
      #           ignoring_interference_by_writer
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class AddressTest < ActiveSupport::TestCase
      #       should_not allow_value([]).
      #         for(:zip_code).
      #         ignoring_interference_by_writer
      #     end
      #
      # @return [AllowValueMatcher]
      #
      def allow_value: (*untyped values) -> untyped

      # @private
      alias allow_values allow_value

      # @private
      class AllowValueMatcher
        include Helpers

        include Qualifiers::IgnoringInterferenceByWriter

        attr_reader after_setting_value_callback: untyped

        attr_reader attribute_to_check_message_against: untyped

        attr_reader attribute_to_set: untyped

        attr_reader context: untyped

        attr_reader instance: untyped

        attr_writer attribute_changed_value_message: untyped

        attr_writer failure_message_preface: untyped

        attr_writer values_to_preset: untyped

        def initialize: (*untyped values) -> void

        def for: (untyped attribute_name) -> self

        def on: (untyped context) -> self

        def with_message: (untyped message, ?::Hash[untyped, untyped] given_options) -> self

        def expected_message: () -> (untyped | nil)

        def expects_custom_validation_message?: () -> untyped

        def strict: (?bool expects_strict) -> self

        def expects_strict?: () -> untyped

        def _after_setting_value: () ?{ () -> untyped } -> untyped

        def matches?: (untyped `instance`) -> untyped

        def does_not_match?: (untyped `instance`) -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> untyped

        def description: () -> untyped

        def simple_description: () -> ::String

        def model: () -> untyped

        def last_attribute_setter_used: () -> untyped

        def last_value_set: () -> untyped

        attr_reader options: untyped

        attr_reader result: untyped

        attr_reader values_to_preset: untyped

        attr_reader values_to_set: untyped

        private

        def run: (untyped strategy) -> untyped

        def failure_message_preface: () -> untyped

        def default_failure_message_preface: () -> untyped

        def include_attribute_changed_value_message?: () -> untyped

        def attribute_changed_value_message: () -> untyped

        def default_attribute_changed_value_message: () -> untyped

        def descriptions_for_preset_values: () -> untyped

        def description_for_resulting_attribute_setter: () -> untyped

        def attribute_setters_for_values_to_preset: () -> untyped

        def attribute_setters_and_validators_for_values_to_set: () -> untyped

        def inspected_values_to_set: () -> untyped

        def default_expected_message: () -> (::String | untyped)

        def default_attribute_message: () -> untyped

        def default_attribute_message_values: () -> untyped

        def model_name: () -> untyped

        def human_attribute_name: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveModel
      # @private
      class Validator
        include Helpers

        def initialize: (untyped record, untyped attribute, ?::Hash[untyped, untyped] options) -> void

        def call: () -> untyped

        def has_messages?: () -> untyped

        def captured_validation_exception?: () -> untyped

        def type_of_message_matched?: () -> untyped

        def all_formatted_validation_error_messages: () -> untyped

        def validation_exception_message: () -> untyped

        attr_reader attribute: untyped

        attr_reader context: untyped

        attr_reader record: untyped

        private

        def expects_strict?: () -> untyped

        def messages_match?: () -> untyped

        def messages: () -> (::Array[untyped] | untyped)

        def matched_messages: () -> untyped

        def captured_range_error?: () -> untyped

        def all_validation_errors: () -> untyped

        def validation_error_messages: () -> untyped

        def validation_result: () -> untyped

        def perform_validation: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    # @private
    module RailsShim
      def self.action_pack_version: () -> untyped

      def self.active_record_gte_6?: () -> untyped

      def self.active_record_version: () -> untyped

      def self.generate_validation_message: (untyped record, untyped attribute, untyped `type`, untyped model_name, untyped options) -> untyped

      def self.serialized_attributes_for: (untyped model) -> untyped

      def self.attribute_serialization_coder_for: (untyped model, untyped attribute_name) -> untyped

      def self.verb_for_update: () -> :patch

      def self.parent_of: (untyped mod) -> untyped

      def self.has_secure_password?: (untyped record, untyped attribute_name) -> untyped

      def self.digestible_attributes_in: (untyped record) -> untyped

      def self.secure_password_module: () -> untyped

      def self.attribute_types_for: (untyped model) -> untyped

      def self.attribute_type_for: (untyped model, untyped attribute_name) -> untyped

      def self.supports_full_attributes_api?: (untyped model) -> untyped

      private

      def self.simply_generate_validation_message: (untyped attribute, untyped `type`, untyped model_name, untyped options) -> untyped

      class FakeAttributeType
        def initialize: (untyped model, untyped attribute_name) -> void

        def coder: () -> nil

        private

        attr_reader model: untyped

        attr_reader attribute_name: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `validate_uniqueness_of` matcher tests usage of the
      # `validates_uniqueness_of` validation. It first checks for an existing
      # instance of your model in the database, creating one if necessary. It
      # then takes a new instance of that model and asserts that it fails
      # validation if the attribute or attributes you've specified in the
      # validation are set to values which are the same as those of the
      # pre-existing record (thereby failing the uniqueness check).
      #
      #     class Post < ActiveRecord::Base
      #       validates :permalink, uniqueness: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:permalink) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:permalink)
      #     end
      #
      # #### Caveat
      #
      # This matcher works a bit differently than other matchers. As noted
      # before, it will create an instance of your model if one doesn't already
      # exist. Sometimes this step fails, especially if you have database-level
      # restrictions on any attributes other than the one which is unique. In
      # this case, the solution is to populate these attributes with values
      # before you call `validate_uniqueness_of`.
      #
      # For example, say you have the following migration and model:
      #
      #     class CreatePosts < ActiveRecord::Migration
      #       def change
      #         create_table :posts do |t|
      #           t.string :title
      #           t.text :content, null: false
      #         end
      #       end
      #     end
      #
      #     class Post < ActiveRecord::Base
      #       validates :title, uniqueness: true
      #     end
      #
      # You may be tempted to test the model like this:
      #
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:title) }
      #     end
      #
      # However, running this test will fail with an exception such as:
      #
      #     Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::ExistingRecordInvalid:
      #       validate_uniqueness_of works by matching a new record against an
      #       existing record. If there is no existing record, it will create one
      #       using the record you provide.
      #
      #       While doing this, the following error was raised:
      #
      #         PG::NotNullViolation: ERROR:  null value in column "content" violates not-null constraint
      #         DETAIL:  Failing row contains (1, null, null).
      #         : INSERT INTO "posts" DEFAULT VALUES RETURNING "id"
      #
      #       The best way to fix this is to provide the matcher with a record where
      #       any required attributes are filled in with valid values beforehand.
      #
      # (The exact error message will differ depending on which database you're
      # using, but you get the idea.)
      #
      # This happens because `validate_uniqueness_of` tries to create a new post
      # but cannot do so because of the `content` attribute: though unrelated to
      # this test, it nevertheless needs to be filled in. As indicated at the
      # end of the error message, the solution is to build a custom Post object
      # ahead of time with `content` filled in:
      #
      #     RSpec.describe Post, type: :model do
      #       describe "validations" do
      #         subject { Post.new(content: "Here is the content") }
      #         it { should validate_uniqueness_of(:title) }
      #       end
      #     end
      #
      # Or, if you're using
      # [FactoryBot](https://github.com/thoughtbot/factory_bot) and you have a
      # `post` factory defined which automatically fills in `content`, you can
      # say:
      #
      #     RSpec.describe Post, type: :model do
      #       describe "validations" do
      #         subject { FactoryBot.build(:post) }
      #         it { should validate_uniqueness_of(:title) }
      #       end
      #     end
      #
      # #### Qualifiers
      #
      # Use `on` if your validation applies only under a certain context.
      #
      #     class Post < ActiveRecord::Base
      #       validates :title, uniqueness: true, on: :create
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:title).on(:create) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:title).on(:create)
      #     end
      #
      # ##### with_message
      #
      # Use `with_message` if you are using a custom validation message.
      #
      #     class Post < ActiveRecord::Base
      #       validates :title, uniqueness: true, message: 'Please choose another title'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it do
      #         should validate_uniqueness_of(:title).
      #           with_message('Please choose another title')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:title).
      #         with_message('Please choose another title')
      #     end
      #
      # ##### scoped_to
      #
      # Use `scoped_to` to test usage of the `:scope` option. This asserts that
      # a new record fails validation if not only the primary attribute is not
      # unique, but the scoped attributes are not unique either.
      #
      #     class Post < ActiveRecord::Base
      #       validates :slug, uniqueness: { scope: :journal_id }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:slug).scoped_to(:journal_id) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:slug).scoped_to(:journal_id)
      #     end
      #
      # NOTE: Support for testing uniqueness validation scoped to an array of
      # associations is not available.
      #
      # For more information, please refer to
      # https://github.com/thoughtbot/shoulda-matchers/issues/814
      #
      # ##### case_insensitive
      #
      # Use `case_insensitive` to test usage of the `:case_sensitive` option
      # with a false value. This asserts that the uniquable attributes fail
      # validation even if their values are a different case than corresponding
      # attributes in the pre-existing record.
      #
      #     class Post < ActiveRecord::Base
      #       validates :key, uniqueness: { case_sensitive: false }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:key).case_insensitive }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:key).case_insensitive
      #     end
      #
      # ##### ignoring_case_sensitivity
      #
      # By default, `validate_uniqueness_of` will check that the
      # validation is case sensitive: it asserts that uniquable attributes pass
      # validation when their values are in a different case than corresponding
      # attributes in the pre-existing record.
      #
      # Use `ignoring_case_sensitivity` to skip this check. This qualifier is
      # particularly handy if your model has somehow changed the behavior of
      # attribute you're testing so that it modifies the case of incoming values
      # as they are set. For instance, perhaps you've overridden the writer
      # method or added a `before_validation` callback to normalize the
      # attribute.
      #
      #     class User < ActiveRecord::Base
      #       validates :email, uniqueness: true
      #
      #       def email=(value)
      #         super(value.downcase)
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it do
      #         should validate_uniqueness_of(:email).ignoring_case_sensitivity
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:email).ignoring_case_sensitivity
      #     end
      #
      # ##### allow_nil
      #
      # Use `allow_nil` to assert that the attribute allows nil.
      #
      #     class Post < ActiveRecord::Base
      #       validates :author_id, uniqueness: true, allow_nil: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:author_id).allow_nil }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:author_id).allow_nil
      #     end
      #
      # @return [ValidateUniquenessOfMatcher]
      #
      # ##### allow_blank
      #
      # Use `allow_blank` to assert that the attribute allows a blank value.
      #
      #     class Post < ActiveRecord::Base
      #       validates :author_id, uniqueness: true, allow_blank: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should validate_uniqueness_of(:author_id).allow_blank }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should validate_uniqueness_of(:author_id).allow_blank
      #     end
      #
      # @return [ValidateUniquenessOfMatcher]
      #
      def validate_uniqueness_of: (untyped attr) -> untyped

      # @private
      class ValidateUniquenessOfMatcher < ActiveModel::ValidationMatcher
        include ActiveModel::Helpers

        def initialize: (untyped attribute) -> void

        def scoped_to: (*untyped scopes) -> self

        def case_insensitive: () -> self

        def ignoring_case_sensitivity: () -> self

        def allow_nil: () -> self

        def expects_to_allow_nil?: () -> untyped

        def allow_blank: () -> self

        def expects_to_allow_blank?: () -> untyped

        def simple_description: () -> untyped

        def matches?: (untyped given_record) -> untyped

        def does_not_match?: (untyped given_record) -> untyped

        def failure_reason: () -> untyped

        def failure_reason_when_negated: () -> untyped

        def build_allow_or_disallow_value_matcher: (untyped args) -> untyped

        private

        def case_sensitivity_strategy: () -> untyped

        def new_record: () -> untyped

        alias subject new_record

        def description_for_case_sensitive_qualifier: () -> untyped

        def validations: () -> untyped

        def matches_scopes_configuration?: () -> (true | false)

        def does_not_match_scopes_configuration?: () -> (false | true)

        def scopes_match?: () -> untyped

        def inspected_expected_scopes: () -> untyped

        def inspected_actual_scopes: () -> untyped

        def inspected_actual_sets_of_scopes: () -> untyped

        def expected_scopes: () -> untyped

        def actual_sets_of_scopes: () -> untyped

        def matches_allow_nil?: () -> untyped

        def does_not_match_allow_nil?: () -> untyped

        def matches_allow_blank?: () -> untyped

        def does_not_match_allow_blank?: () -> untyped

        def existing_record: () -> untyped

        def find_or_create_existing_record: () -> untyped

        def find_existing_record: () -> untyped

        def create_existing_record: () -> untyped

        def update_existing_record!: (untyped value) -> true

        def arbitrary_non_blank_value: () -> untyped

        def has_secure_password?: () -> untyped

        def build_new_record: () -> untyped

        def matches_presence_of_attribute?: () -> (true | false)

        def does_not_match_presence_of_attribute?: () -> (false | true)

        def attribute_present_on_model?: () -> untyped

        def matches_presence_of_scopes?: () -> (true | false)

        def does_not_match_presence_of_scopes?: () -> (true | false)

        def scopes_present_on_model: () -> untyped

        def scopes_missing_on_model: () -> untyped

        def matches_uniqueness_without_scopes?: () -> untyped

        def does_not_match_uniqueness_without_scopes?: () -> untyped

        def matches_uniqueness_with_case_sensitivity_strategy?: () -> (untyped | true)

        def does_not_match_uniqueness_with_case_sensitivity_strategy?: () -> (untyped | true)

        def should_test_case_sensitivity?: () -> untyped

        def model_class?: (untyped model_name) -> untyped

        def matches_uniqueness_with_scopes?: () -> untyped

        def does_not_match_uniqueness_with_scopes?: () -> untyped

        def setting_next_value_for: (untyped scope) { () -> untyped } -> untyped

        def dummy_value_for: (untyped scope) -> untyped

        def dummy_scalar_value_for: (untyped column) -> untyped

        def next_value_for: (untyped scope, untyped previous_value) -> (::Array[untyped] | untyped)

        def next_scalar_value_for: (untyped scope, untyped previous_value) -> untyped

        def all_scopes_are_booleans?: () -> untyped

        def boolean_value?: (untyped value) -> untyped

        def defined_as_enum?: (untyped scope) -> untyped

        def polymorphic_type_attribute?: (untyped scope, untyped previous_value) -> untyped

        def available_enum_values_for: (untyped scope, untyped previous_value) -> untyped

        def set_attribute_on!: (untyped record_type, untyped record, untyped attribute_name, untyped value) -> untyped

        def set_attribute_on_existing_record!: (untyped attribute_name, untyped value) -> untyped

        def set_attribute_on_new_record!: (untyped attribute_name, untyped value) -> untyped

        def attribute_setter_for_existing_record: () -> untyped

        def attribute_setters_for_new_record: () -> untyped

        def attribute_names_under_test: () -> untyped

        def build_attribute_setter: (untyped record, untyped attribute_name, untyped value) -> untyped

        def existing_value_read: () -> untyped

        def existing_value_written: () -> untyped

        def column_for: (untyped scope) -> untyped

        def column_limit_for: (untyped attribute) -> untyped

        def model: () -> untyped

        def failure_message_preface: () -> untyped

        def attribute_changed_value_message: () -> untyped

        def description_for_attribute_setter: (untyped attribute_setter, ?same_as_existing: untyped?) -> untyped

        def descriptions_for_attribute_setters_for_new_record: () -> untyped

        def attribute_setter_descriptions_for_new_record: () -> untyped

        def existing_and_new_values_are_same?: () -> untyped

        def last_attribute_setter_used_on_new_record: () -> untyped

        def last_value_set_on_new_record: () -> untyped

        # @private
        class AttributeSetters
          include Enumerable[untyped]

          def initialize: () -> void

          def <<: (untyped given_attribute_setter) -> untyped

          def +: (untyped other_attribute_setters) -> untyped

          def each: () ?{ () -> untyped } -> untyped

          def last: () -> untyped

          private

          def find_index_of: (untyped given_attribute_setter) -> untyped
        end

        # @private
        class NonCaseSwappableValueError < Shoulda::Matchers::Error
          attr_accessor model: untyped

          attr_accessor attribute: untyped

          attr_accessor value: untyped

          def message: () -> untyped
        end

        # @private
        class ExistingRecordInvalid < Shoulda::Matchers::Error
          include Shoulda::Matchers::ActiveModel::Helpers

          attr_accessor underlying_exception: untyped

          def message: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `serialize` matcher tests usage of the `serialize` macro.
      #
      #     class Product < ActiveRecord::Base
      #       serialize :customizations
      #     end
      #
      #     # RSpec
      #     RSpec.describe Product, type: :model do
      #       it { should serialize(:customizations) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProductTest < ActiveSupport::TestCase
      #       should serialize(:customizations)
      #     end
      #
      # #### Qualifiers
      #
      # ##### as
      #
      # Use `as` if you are using a custom serializer class.
      #
      #     class ProductSpecsSerializer
      #       def load(string)
      #         # ...
      #       end
      #
      #       def dump(options)
      #         # ...
      #       end
      #     end
      #
      #     class Product < ActiveRecord::Base
      #       serialize :specifications, ProductSpecsSerializer
      #     end
      #
      #     # RSpec
      #     RSpec.describe Product, type: :model do
      #       it do
      #         should serialize(:specifications).
      #           as(ProductSpecsSerializer)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProductTest < ActiveSupport::TestCase
      #       should serialize(:specifications).
      #         as(ProductSpecsSerializer)
      #     end
      #
      # ##### as_instance_of
      #
      # Use `as_instance_of` if you are using a custom serializer object.
      #
      #     class ProductOptionsSerializer
      #       def load(string)
      #         # ...
      #       end
      #
      #       def dump(options)
      #         # ...
      #       end
      #     end
      #
      #     class Product < ActiveRecord::Base
      #       serialize :options, ProductOptionsSerializer.new
      #     end
      #
      #     # RSpec
      #     RSpec.describe Product, type: :model do
      #       it do
      #         should serialize(:options).
      #           as_instance_of(ProductOptionsSerializer)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProductTest < ActiveSupport::TestCase
      #       should serialize(:options).
      #         as_instance_of(ProductOptionsSerializer)
      #     end
      #
      # @return [SerializeMatcher]
      #
      def serialize: (untyped name) -> untyped

      # @private
      class SerializeMatcher
        def initialize: (untyped name) -> void

        def as: (untyped `type`) -> self

        def as_instance_of: (untyped `type`) -> self

        def matches?: (untyped subject) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> untyped

        def serialization_valid?: () -> (true | false)

        def class_valid?: () -> (untyped | true)

        def model_class: () -> untyped

        def instance_class_valid?: () -> (true | false | true)

        def type_valid?: () -> untyped

        def expectation: () -> untyped

        def attribute_is_serialized?: () -> untyped

        def serialization_coder: () -> untyped

        def model: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # @private
      module AssociationMatchers
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `have_rich_text` matcher tests usage of the
      # `has_rich_text` macro.
      #
      # #### Example
      #
      #     class Post < ActiveRecord
      #       has_rich_text :content
      #     end
      #
      #     # RSpec
      #     RSpec.describe Post, type: :model do
      #       it { should have_rich_text(:content) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PostTest < ActiveSupport::TestCase
      #       should have_rich_text(:content)
      #     end
      #
      # @return [HaveRichTextMatcher]
      #
      def have_rich_text: (untyped rich_text_attribute) -> untyped

      # @private
      class HaveRichTextMatcher
        def initialize: (untyped rich_text_attribute) -> void

        def description: () -> ::String

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def matches?: (untyped subject) -> untyped

        private

        attr_reader error: untyped

        attr_reader rich_text_attribute: untyped

        attr_reader subject: untyped

        def run_checks: () -> (::String | :default | nil)

        def has_attribute?: () -> untyped

        def has_expected_action_text?: () -> untyped

        def error_description: () -> (untyped | ::String)
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `have_db_column` matcher tests that the table that backs your model
      # has a specific column.
      #
      #     class CreatePhones < ActiveRecord::Migration
      #       def change
      #         create_table :phones do |t|
      #           t.string :supported_ios_version
      #         end
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Phone, type: :model do
      #       it { should have_db_column(:supported_ios_version) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PhoneTest < ActiveSupport::TestCase
      #       should have_db_column(:supported_ios_version)
      #     end
      #
      # #### Qualifiers
      #
      # ##### of_type
      #
      # Use `of_type` to assert that a column is defined as a certain type.
      #
      #     class CreatePhones < ActiveRecord::Migration
      #       def change
      #         create_table :phones do |t|
      #           t.decimal :camera_aperture
      #         end
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Phone, type: :model do
      #       it do
      #         should have_db_column(:camera_aperture).of_type(:decimal)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PhoneTest < ActiveSupport::TestCase
      #       should have_db_column(:camera_aperture).of_type(:decimal)
      #     end
      #
      # ##### with_options
      #
      # Use `with_options` to assert that a column has been defined with
      # certain options (`:precision`, `:limit`, `:default`, `:null`, `:scale`,
      # `:primary` or `:array`).
      #
      #     class CreatePhones < ActiveRecord::Migration
      #       def change
      #         create_table :phones do |t|
      #           t.decimal :camera_aperture, precision: 1, null: false
      #         end
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Phone, type: :model do
      #       it do
      #         should have_db_column(:camera_aperture).
      #           with_options(precision: 1, null: false)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PhoneTest < ActiveSupport::TestCase
      #       should have_db_column(:camera_aperture).
      #         with_options(precision: 1, null: false)
      #     end
      #
      # @return [HaveDbColumnMatcher]
      #
      def have_db_column: (untyped column) -> untyped

      # @private
      class HaveDbColumnMatcher
        OPTIONS: ::Array[:precision | :limit | :default | :null | :scale | :primary | :array]

        def initialize: (untyped column) -> void

        def of_type: (untyped column_type) -> self

        def with_options: (?::Hash[untyped, untyped] opts) -> self

        def matches?: (untyped subject) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> untyped

        def validate_options: (untyped opts) -> untyped

        def column_exists?: () -> (true | false)

        def correct_column_type?: () -> (true | untyped)

        def correct_precision?: () -> (true | untyped)

        def correct_limit?: () -> (true | untyped)

        def correct_default?: () -> (true | untyped)

        def correct_null?: () -> (true | untyped)

        def correct_scale?: () -> (true | untyped)

        def correct_primary?: () -> (true | untyped)

        def correct_array?: () -> (true | untyped)

        def matched_column: () -> untyped

        def model_class: () -> untyped

        def actual_scale: () -> untyped

        def actual_primary?: () -> untyped

        def expectation: () -> ::String

        # @private
        class DecoratedColumn < SimpleDelegator
          def initialize: (untyped model, untyped column) -> void

          def type_cast_default: () -> untyped

          def primary?: () -> untyped

          attr_reader model: untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `belong_to` matcher is used to ensure that a `belong_to` association
      # exists on your model.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:organization) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization)
      #     end
      #
      # Note that polymorphic associations are automatically detected and do not
      # need any qualifiers:
      #
      #     class Comment < ActiveRecord::Base
      #       belongs_to :commentable, polymorphic: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Comment, type: :model do
      #       it { should belong_to(:commentable) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class CommentTest < ActiveSupport::TestCase
      #       should belong_to(:commentable)
      #     end
      #
      # #### Qualifiers
      #
      # ##### conditions
      #
      # Use `conditions` if your association is defined with a scope that sets
      # the `where` clause.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :family, -> { where(everyone_is_perfect: false) }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should belong_to(:family).
      #           conditions(everyone_is_perfect: false)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:family).
      #         conditions(everyone_is_perfect: false)
      #     end
      #
      # ##### order
      #
      # Use `order` if your association is defined with a scope that sets the
      # `order` clause.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :previous_company, -> { order('hired_on desc') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:previous_company).order('hired_on desc') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:previous_company).order('hired_on desc')
      #     end
      #
      # ##### class_name
      #
      # Use `class_name` to test usage of the `:class_name` option. This
      # asserts that the model you're referring to actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :ancient_city, class_name: 'City'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:ancient_city).class_name('City') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:ancient_city).class_name('City')
      #     end
      #
      # ##### with_primary_key
      #
      # Use `with_primary_key` to test usage of the `:primary_key` option.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :great_country, primary_key: 'country_id'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should belong_to(:great_country).
      #           with_primary_key('country_id')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:great_country).
      #         with_primary_key('country_id')
      #     end
      #
      # ##### with_foreign_key
      #
      # Use `with_foreign_key` to test usage of the `:foreign_key` option.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :great_country, foreign_key: 'country_id'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should belong_to(:great_country).
      #           with_foreign_key('country_id')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:great_country).
      #         with_foreign_key('country_id')
      #     end
      #
      # ##### dependent
      #
      # Use `dependent` to assert that the `:dependent` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :world, dependent: :destroy
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:world).dependent(:destroy) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:world).dependent(:destroy)
      #     end
      #
      # To assert that *any* `:dependent` option was specified, use `true`:
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:world).dependent(true) }
      #     end
      #
      # To assert that *no* `:dependent` option was specified, use `false`:
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :company
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:company).dependent(false) }
      #     end
      #
      # ##### counter_cache
      #
      # Use `counter_cache` to assert that the `:counter_cache` option was
      # specified.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization, counter_cache: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:organization).counter_cache(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization).counter_cache(true)
      #     end
      #
      # ##### touch
      #
      # Use `touch` to assert that the `:touch` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization, touch: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should belong_to(:organization).touch(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization).touch(true)
      #     end
      #
      # ##### autosave
      #
      # Use `autosave` to assert that the `:autosave` option was specified.
      #
      #     class Account < ActiveRecord::Base
      #       belongs_to :bank, autosave: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Account, type: :model do
      #       it { should belong_to(:bank).autosave(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class AccountTest < ActiveSupport::TestCase
      #       should belong_to(:bank).autosave(true)
      #     end
      #
      # ##### inverse_of
      #
      # Use `inverse_of` to assert that the `:inverse_of` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization, inverse_of: :employees
      #     end
      #
      #     # RSpec
      #     describe Person
      #       it { should belong_to(:organization).inverse_of(:employees) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization).inverse_of(:employees)
      #     end
      #
      # ##### required
      #
      # Use `required` to assert that the association is not allowed to be nil.
      # (Enabled by default in Rails 5+.)
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization, required: true
      #     end
      #
      #     # RSpec
      #     describe Person
      #       it { should belong_to(:organization).required }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization).required
      #     end
      #
      # ##### without_validating_presence
      #
      # Use `without_validating_presence` with `belong_to` to prevent the
      # matcher from checking whether the association disallows nil (Rails 5+
      # only). This can be helpful if you have a custom hook that always sets
      # the association to a meaningful value:
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization
      #
      #       before_validation :autoassign_organization
      #
      #       private
      #
      #       def autoassign_organization
      #         self.organization = Organization.create!
      #       end
      #     end
      #
      #     # RSpec
      #     describe Person
      #       it { should belong_to(:organization).without_validating_presence }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization).without_validating_presence
      #     end
      #
      # ##### optional
      #
      # Use `optional` to assert that the association is allowed to be nil.
      # (Rails 5+ only.)
      #
      #     class Person < ActiveRecord::Base
      #       belongs_to :organization, optional: true
      #     end
      #
      #     # RSpec
      #     describe Person
      #       it { should belong_to(:organization).optional }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should belong_to(:organization).optional
      #     end
      #
      # @return [AssociationMatcher]
      #
      def belong_to: (untyped name) -> untyped

      # The `have_many` matcher is used to test that a `has_many` or `has_many
      # :through` association exists on your model.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :friends
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:friends) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:friends)
      #     end
      #
      # Note that polymorphic associations are automatically detected and do not
      # need any qualifiers:
      #
      #     class Person < ActiveRecord::Base
      #       has_many :pictures, as: :imageable
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:pictures) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:pictures)
      #     end
      #
      # #### Qualifiers
      #
      # ##### conditions
      #
      # Use `conditions` if your association is defined with a scope that sets
      # the `where` clause.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :coins, -> { where(quality: 'mint') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:coins).conditions(quality: 'mint') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:coins).conditions(quality: 'mint')
      #     end
      #
      # ##### order
      #
      # Use `order` if your association is defined with a scope that sets the
      # `order` clause.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :shirts, -> { order('color') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:shirts).order('color') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:shirts).order('color')
      #     end
      #
      # ##### class_name
      #
      # Use `class_name` to test usage of the `:class_name` option. This
      # asserts that the model you're referring to actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :hopes, class_name: 'Dream'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:hopes).class_name('Dream') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:hopes).class_name('Dream')
      #     end
      #
      # ##### with_primary_key
      #
      # Use `with_primary_key` to test usage of the `:primary_key` option.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :worries, primary_key: 'worrier_id'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:worries).with_primary_key('worrier_id') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:worries).with_primary_key('worrier_id')
      #     end
      #
      # ##### with_foreign_key
      #
      # Use `with_foreign_key` to test usage of the `:foreign_key` option.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :worries, foreign_key: 'worrier_id'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:worries).with_foreign_key('worrier_id') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:worries).with_foreign_key('worrier_id')
      #     end
      #
      # ##### dependent
      #
      # Use `dependent` to assert that the `:dependent` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :secret_documents, dependent: :destroy
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:secret_documents).dependent(:destroy) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:secret_documents).dependent(:destroy)
      #     end
      #
      # ##### through
      #
      # Use `through` to test usage of the `:through` option. This asserts that
      # the association you are going through actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :acquaintances, through: :friends
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:acquaintances).through(:friends) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:acquaintances).through(:friends)
      #     end
      #
      # ##### source
      #
      # Use `source` to test usage of the `:source` option on a `:through`
      # association.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :job_offers, through: :friends, source: :opportunities
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should have_many(:job_offers).
      #           through(:friends).
      #           source(:opportunities)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:job_offers).
      #         through(:friends).
      #         source(:opportunities)
      #     end
      #
      # ##### validate
      #
      # Use `validate` to assert that the `:validate` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       has_many :ideas, validate: false
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_many(:ideas).validate(false) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_many(:ideas).validate(false)
      #     end
      #
      # ##### autosave
      #
      # Use `autosave` to assert that the `:autosave` option was specified.
      #
      #     class Player < ActiveRecord::Base
      #       has_many :games, autosave: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Player, type: :model do
      #       it { should have_many(:games).autosave(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PlayerTest < ActiveSupport::TestCase
      #       should have_many(:games).autosave(true)
      #     end
      #
      # ##### index_errors
      #
      # Use `index_errors` to assert that the `:index_errors` option was
      # specified.
      #
      #     class Player < ActiveRecord::Base
      #       has_many :games, index_errors: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Player, type: :model do
      #       it { should have_many(:games).index_errors(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PlayerTest < ActiveSupport::TestCase
      #       should have_many(:games).index_errors(true)
      #     end
      #
      # ##### inverse_of
      #
      # Use `inverse_of` to assert that the `:inverse_of` option was specified.
      #
      #     class Organization < ActiveRecord::Base
      #       has_many :employees, inverse_of: :company
      #     end
      #
      #     # RSpec
      #     describe Organization
      #       it { should have_many(:employees).inverse_of(:company) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class OrganizationTest < ActiveSupport::TestCase
      #       should have_many(:employees).inverse_of(:company)
      #     end
      #
      # @return [AssociationMatcher]
      #
      def have_many: (untyped name) -> untyped

      # The `have_one` matcher is used to test that a `has_one` or `has_one
      # :through` association exists on your model.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :partner
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:partner) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:partner)
      #     end
      #
      # #### Qualifiers
      #
      # ##### conditions
      #
      # Use `conditions` if your association is defined with a scope that sets
      # the `where` clause.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :pet, -> { where('weight < 80') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:pet).conditions('weight < 80') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:pet).conditions('weight < 80')
      #     end
      #
      # ##### order
      #
      # Use `order` if your association is defined with a scope that sets the
      # `order` clause.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :focus, -> { order('priority desc') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:focus).order('priority desc') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:focus).order('priority desc')
      #     end
      #
      # ##### class_name
      #
      # Use `class_name` to test usage of the `:class_name` option. This
      # asserts that the model you're referring to actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :chance, class_name: 'Opportunity'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:chance).class_name('Opportunity') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:chance).class_name('Opportunity')
      #     end
      #
      # ##### dependent
      #
      # Use `dependent` to test that the `:dependent` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :contract, dependent: :nullify
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:contract).dependent(:nullify) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:contract).dependent(:nullify)
      #     end
      #
      # ##### with_primary_key
      #
      # Use `with_primary_key` to test usage of the `:primary_key` option.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :job, primary_key: 'worker_id'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:job).with_primary_key('worker_id') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:job).with_primary_key('worker_id')
      #     end
      #
      # ##### with_foreign_key
      #
      # Use `with_foreign_key` to test usage of the `:foreign_key` option.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :job, foreign_key: 'worker_id'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:job).with_foreign_key('worker_id') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:job).with_foreign_key('worker_id')
      #     end
      #
      # ##### through
      #
      # Use `through` to test usage of the `:through` option. This asserts that
      # the association you are going through actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :life, through: :partner
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:life).through(:partner) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:life).through(:partner)
      #     end
      #
      # ##### source
      #
      # Use `source` to test usage of the `:source` option on a `:through`
      # association.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :car, through: :partner, source: :vehicle
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:car).through(:partner).source(:vehicle) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:car).through(:partner).source(:vehicle)
      #     end
      #
      # ##### validate
      #
      # Use `validate` to assert that the the `:validate` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       has_one :parking_card, validate: false
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_one(:parking_card).validate(false) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:parking_card).validate(false)
      #     end
      #
      # ##### autosave
      #
      # Use `autosave` to assert that the `:autosave` option was specified.
      #
      #     class Account < ActiveRecord::Base
      #       has_one :bank, autosave: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Account, type: :model do
      #       it { should have_one(:bank).autosave(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class AccountTest < ActiveSupport::TestCase
      #       should have_one(:bank).autosave(true)
      #     end
      #
      # ##### required
      #
      # Use `required` to assert that the association is not allowed to be nil.
      # (Rails 5+ only.)
      #
      #     class Person < ActiveRecord::Base
      #       has_one :brain, required: true
      #     end
      #
      #     # RSpec
      #     describe Person
      #       it { should have_one(:brain).required }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_one(:brain).required
      #     end
      #
      # @return [AssociationMatcher]
      #
      def have_one: (untyped name) -> untyped

      # The `have_and_belong_to_many` matcher is used to test that a
      # `has_and_belongs_to_many` association exists on your model and that the
      # join table exists in the database.
      #
      #     class Person < ActiveRecord::Base
      #       has_and_belongs_to_many :awards
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it { should have_and_belong_to_many(:awards) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:awards)
      #     end
      #
      # #### Qualifiers
      #
      # ##### conditions
      #
      # Use `conditions` if your association is defined with a scope that sets
      # the `where` clause.
      #
      #     class Person < ActiveRecord::Base
      #       has_and_belongs_to_many :issues, -> { where(difficulty: 'hard') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should have_and_belong_to_many(:issues).
      #           conditions(difficulty: 'hard')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:issues).
      #         conditions(difficulty: 'hard')
      #     end
      #
      # ##### order
      #
      # Use `order` if your association is defined with a scope that sets the
      # `order` clause.
      #
      #     class Person < ActiveRecord::Base
      #       has_and_belongs_to_many :projects, -> { order('time_spent') }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should have_and_belong_to_many(:projects).
      #           order('time_spent')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:projects).
      #         order('time_spent')
      #     end
      #
      # ##### class_name
      #
      # Use `class_name` to test usage of the `:class_name` option. This
      # asserts that the model you're referring to actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       has_and_belongs_to_many :places_visited, class_name: 'City'
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should have_and_belong_to_many(:places_visited).
      #           class_name('City')
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:places_visited).
      #         class_name('City')
      #     end
      #
      # ##### join_table
      #
      # Use `join_table` to test usage of the `:join_table` option. This
      # asserts that the table you're referring to actually exists.
      #
      #     class Person < ActiveRecord::Base
      #       has_and_belongs_to_many :issues, join_table: :people_tickets
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should have_and_belong_to_many(:issues).
      #           join_table(:people_tickets)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:issues).
      #         join_table(:people_tickets)
      #     end
      #
      # ##### validate
      #
      # Use `validate` to test that the `:validate` option was specified.
      #
      #     class Person < ActiveRecord::Base
      #       has_and_belongs_to_many :interviews, validate: false
      #     end
      #
      #     # RSpec
      #     RSpec.describe Person, type: :model do
      #       it do
      #         should have_and_belong_to_many(:interviews).
      #           validate(false)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class PersonTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:interviews).
      #         validate(false)
      #     end
      #
      # ##### autosave
      #
      # Use `autosave` to assert that the `:autosave` option was specified.
      #
      #     class Publisher < ActiveRecord::Base
      #       has_and_belongs_to_many :advertisers, autosave: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Publisher, type: :model do
      #       it { should have_and_belong_to_many(:advertisers).autosave(true) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class AccountTest < ActiveSupport::TestCase
      #       should have_and_belong_to_many(:advertisers).autosave(true)
      #     end
      #
      # @return [AssociationMatcher]
      #
      def have_and_belong_to_many: (untyped name) -> untyped

      # @private
      class AssociationMatcher
        MACROS: ::Hash[::String, "belong to" | "have many" | "have one" | "have and belong to many"]

        attr_reader name: untyped

        attr_reader options: untyped

        def initialize: (untyped macro, untyped name) -> void

        def through: (untyped through) -> self

        def dependent: (untyped dependent) -> self

        def order: (untyped order) -> self

        def counter_cache: (?bool counter_cache) -> self

        def inverse_of: (untyped inverse_of) -> self

        def source: (untyped source) -> self

        def conditions: (untyped conditions) -> self

        def autosave: (untyped autosave) -> self

        def index_errors: (untyped index_errors) -> self

        def class_name: (untyped class_name) -> self

        def with_foreign_key: (untyped foreign_key) -> self

        def with_primary_key: (untyped primary_key) -> self

        def required: (?bool required) -> self

        def optional: (?bool optional) -> self

        def validate: (?bool validate) -> self

        def touch: (?bool touch) -> self

        def join_table: (untyped join_table_name) -> self

        def without_validating_presence: () -> self

        def description: () -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def matches?: (untyped subject) -> untyped

        def join_table_name: () -> untyped

        def option_verifier: () -> untyped

        attr_reader submatchers: untyped

        attr_reader missing: untyped

        attr_reader subject: untyped

        attr_reader macro: untyped

        def reflector: () -> untyped

        def add_submatcher: (untyped matcher_class, *untyped args) -> untyped

        def remove_submatcher: (untyped matcher_class) -> untyped

        def macro_description: () -> untyped

        def expectation: () -> untyped

        def missing_options: () -> untyped

        def failing_submatchers: () -> untyped

        def missing_options_for_failing_submatchers: () -> (untyped | ::Array[untyped])

        def association_exists?: () -> (false | true)

        def macro_correct?: () -> (true | untyped | false)

        def validate_inverse_of_through_association: () -> untyped

        def macro_supports_primary_key?: () -> untyped

        def foreign_key_exists?: () -> untyped

        def primary_key_exists?: () -> untyped

        def belongs_foreign_key_missing?: () -> untyped

        def has_foreign_key_missing?: () -> untyped

        def class_name_correct?: () -> (true | false | true)

        def join_table_correct?: () -> (true | false)

        def join_table_matcher: () -> untyped

        def class_exists?: () -> untyped

        def autosave_correct?: () -> (true | false | true)

        def index_errors_correct?: () -> (true | untyped)

        def conditions_correct?: () -> (true | false | true)

        def validate_correct?: () -> (true | false)

        def touch_correct?: () -> (true | false)

        def class_has_foreign_key?: (untyped klass) -> untyped

        def validate_foreign_key: (untyped klass) -> (untyped | untyped | nil)

        def has_column?: (untyped klass, untyped column) -> untyped

        def foreign_key_correct?: () -> untyped

        def foreign_key_failure_message: (untyped klass, untyped foreign_key) -> ::String

        def primary_key_correct?: (untyped klass) -> (true | false | true)

        def actual_foreign_key: () -> (nil | untyped)

        def foreign_key_reflection: () -> untyped

        def submatchers_match?: () -> untyped

        def column_names_for: (untyped klass) -> untyped

        def belongs_to_required_by_default?: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class DependentMatcher
          attr_accessor missing_option: untyped

          def initialize: (untyped dependent, untyped name) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> untyped

          attr_accessor subject: untyped

          attr_accessor dependent: untyped

          attr_accessor name: untyped

          private

          def option_verifier: () -> untyped

          def option_matches?: () -> untyped

          def option_type: () -> untyped

          def generate_missing_option: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class InverseOfMatcher
          attr_accessor missing_option: untyped

          def initialize: (untyped inverse_of, untyped name) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> untyped

          attr_accessor subject: untyped

          attr_accessor inverse_of: untyped

          attr_accessor name: untyped

          def option_verifier: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class ModelReflector
          def initialize: (untyped subject, untyped name) -> void

          def association_relation: () -> untyped

          def reflection: () -> untyped

          def reflect_on_association: (untyped name) -> untyped

          def model_class: () -> untyped

          def build_relation_with_clause: (untyped name, untyped value) -> untyped

          def extract_relation_clause_from: (untyped relation, untyped name) -> untyped

          attr_reader subject: untyped

          attr_reader name: untyped

          def value_as_sql: (untyped value) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class OptionVerifier
          DEFAULT_VALUE_OF_OPTIONS: { has_many: { validate: true } }

          RELATION_OPTIONS: ::Array[:conditions | :order]

          def initialize: (untyped reflector) -> void

          def correct_for_string?: (untyped name, untyped expected_value) -> untyped

          def correct_for_boolean?: (untyped name, untyped expected_value) -> untyped

          def correct_for_hash?: (untyped name, untyped expected_value) -> untyped

          def correct_for_constant?: (untyped name, untyped expected_unresolved_value) -> untyped

          def correct_for_relation_clause?: (untyped name, untyped expected_value) -> untyped

          def correct_for?: (*untyped args) -> untyped

          def actual_value_for: (untyped name) -> untyped

          attr_reader reflector: untyped

          def type_cast: (untyped `type`, untyped value) -> untyped

          def expected_value_for: (untyped `type`, untyped name, untyped value) -> untyped

          def expected_value_for_relation_clause: (untyped name, untyped value) -> untyped

          def expected_value_for_constant: (untyped name) -> untyped

          def actual_value_for_relation_clause: (untyped name) -> untyped

          def actual_value_for_class_name: () -> untyped

          def actual_value_for_option: (untyped name) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class OptionalMatcher
          attr_reader missing_option: untyped

          def initialize: (untyped attribute_name, untyped optional) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> (true | false)

          private

          attr_reader attribute_name: untyped

          attr_reader optional: untyped

          attr_reader submatcher: untyped

          def submatcher_passes?: (untyped subject) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class CounterCacheMatcher
          attr_accessor missing_option: untyped

          def initialize: (untyped counter_cache, untyped name) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> untyped

          attr_accessor subject: untyped

          attr_accessor counter_cache: untyped

          attr_accessor name: untyped

          def option_verifier: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class JoinTableMatcher
          attr_reader failure_message: untyped

          alias missing_option failure_message

          def initialize: (untyped association_matcher, untyped reflector) -> void

          def matches?: (untyped _subject) -> untyped

          def join_table_option_correct?: () -> (true | false | true)

          def join_table_exists?: () -> (true | false)

          def join_table_has_correct_columns?: () -> (true | false)

          attr_reader association_matcher: untyped

          attr_reader reflector: untyped

          private

          def missing_columns: () -> untyped

          def expected_join_table_columns: () -> ::Array[untyped]

          def actual_join_table_columns: () -> untyped

          def missing_table_message: () -> ::String

          def missing_columns_message: () -> ::String

          def column_label: () -> ("columns" | "column")
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class OrderMatcher
          attr_accessor missing_option: untyped

          def initialize: (untyped order, untyped name) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> untyped

          attr_accessor subject: untyped

          attr_accessor order: untyped

          attr_accessor name: untyped

          def option_verifier: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class ThroughMatcher
          attr_accessor missing_option: untyped

          def initialize: (untyped through, untyped name) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> untyped

          def association_set_properly?: () -> untyped

          def through_association_exists?: () -> (true | false)

          def through_reflection: () -> untyped

          def through_association_correct?: () -> (true | false)

          attr_accessor through: untyped

          attr_accessor name: untyped

          attr_accessor subject: untyped

          def option_verifier: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class ModelReflection < SimpleDelegator
          def initialize: (untyped reflection) -> void

          def associated_class: () -> untyped

          def polymorphic?: () -> untyped

          def through?: () -> untyped

          def join_table_name: () -> untyped

          def association_relation: (untyped related_instance) -> untyped

          def foreign_key: () -> untyped

          def association_foreign_key: () -> untyped

          def validate_inverse_of_through_association!: () -> (untyped | nil)

          def has_and_belongs_to_many_name: () -> untyped

          attr_reader reflection: untyped

          attr_reader subject: untyped

          private

          def has_and_belongs_to_many_name_table_name: () -> untyped

          def has_and_belongs_to_many_reflection: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class RequiredMatcher
          attr_reader missing_option: untyped

          def initialize: (untyped attribute_name, untyped required) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> (true | false)

          private

          attr_reader attribute_name: untyped

          attr_reader required: untyped

          attr_reader submatcher: untyped

          def submatcher_passes?: (untyped subject) -> untyped

          def validation_message_key: () -> :required
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      module AssociationMatchers
        # @private
        class SourceMatcher
          attr_accessor missing_option: untyped

          def initialize: (untyped source, untyped name) -> void

          def description: () -> ::String

          def matches?: (untyped subject) -> untyped

          attr_accessor subject: untyped

          attr_accessor source: untyped

          attr_accessor name: untyped

          def option_verifier: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # @private
      module Uniqueness
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `have_db_index` matcher tests that the table that backs your model
      # has a specific index.
      #
      # You can specify one column:
      #
      #     class CreateBlogs < ActiveRecord::Migration
      #       def change
      #         create_table :blogs do |t|
      #           t.integer :user_id
      #         end
      #
      #         add_index :blogs, :user_id
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Blog, type: :model do
      #       it { should have_db_index(:user_id) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class BlogTest < ActiveSupport::TestCase
      #       should have_db_index(:user_id)
      #     end
      #
      # Or you can specify a group of columns:
      #
      #     class CreateBlogs < ActiveRecord::Migration
      #       def change
      #         create_table :blogs do |t|
      #           t.integer :user_id
      #           t.string :name
      #         end
      #
      #         add_index :blogs, :user_id, :name
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Blog, type: :model do
      #       it { should have_db_index([:user_id, :name]) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class BlogTest < ActiveSupport::TestCase
      #       should have_db_index([:user_id, :name])
      #     end
      #
      # Finally, if you're using Rails 5 and PostgreSQL, you can also specify an
      # expression:
      #
      #     class CreateLoggedErrors < ActiveRecord::Migration
      #       def change
      #         create_table :logged_errors do |t|
      #           t.string :code
      #           t.jsonb :content
      #         end
      #
      #         add_index :logged_errors, 'lower(code)::text'
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe LoggedError, type: :model do
      #       it { should have_db_index('lower(code)::text') }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class LoggedErrorTest < ActiveSupport::TestCase
      #       should have_db_index('lower(code)::text')
      #     end
      #
      # #### Qualifiers
      #
      # ##### unique
      #
      # Use `unique` to assert that the index is either unique or non-unique:
      #
      #     class CreateBlogs < ActiveRecord::Migration
      #       def change
      #         create_table :blogs do |t|
      #           t.string :domain
      #           t.integer :user_id
      #         end
      #
      #         add_index :blogs, :domain, unique: true
      #         add_index :blogs, :user_id
      #       end
      #     end
      #
      #     # RSpec
      #     RSpec.describe Blog, type: :model do
      #       it { should have_db_index(:name).unique }
      #       it { should have_db_index(:name).unique(true) }   # if you want to be explicit
      #       it { should have_db_index(:user_id).unique(false) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class BlogTest < ActiveSupport::TestCase
      #       should have_db_index(:name).unique
      #       should have_db_index(:name).unique(true)   # if you want to be explicit
      #       should have_db_index(:user_id).unique(false)
      #     end
      #
      # @return [HaveDbIndexMatcher]
      #
      def have_db_index: (untyped columns) -> untyped

      # @private
      class HaveDbIndexMatcher
        def initialize: (untyped columns) -> void

        def unique: (?bool unique) -> self

        def matches?: (untyped subject) -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> untyped

        def description: () -> untyped

        private

        attr_reader expected_columns: untyped

        attr_reader qualifiers: untyped

        attr_reader subject: untyped

        attr_reader reason: untyped

        def normalize_columns_to_array: (untyped columns) -> untyped

        def index_exists?: () -> untyped

        def correct_unique?: () -> (false | false | true | true)

        def matched_index: () -> untyped

        def actual_indexes: () -> untyped

        def described_table_name: () -> (::String | "a table")

        def table_name: () -> untyped

        def positive_expectation: () -> untyped

        def negative_expectation: () -> untyped

        def inspected_expected_columns: () -> untyped

        def index_type: () -> ("unique" | "non-unique")

        def formatted_expected_columns: () -> untyped

        def model: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `have_one_attached` matcher tests usage of the
      # `has_one_attached` macro.
      #
      # #### Example
      #
      #     class User < ApplicationRecord
      #       has_one_attached :avatar
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should have_one_attached(:avatar) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should have_one_attached(:avatar)
      #     end
      #
      # @return [HaveAttachedMatcher]
      #
      def have_one_attached: (untyped name) -> untyped

      # The `have_many_attached` matcher tests usage of the
      # `has_many_attached` macro.
      #
      # #### Example
      #
      #     class Message < ApplicationRecord
      #       has_many_attached :images
      #     end
      #
      #     # RSpec
      #     RSpec.describe Message, type: :model do
      #       it { should have_many_attached(:images) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class MessageTest < ActiveSupport::TestCase
      #       should have_many_attached(:images)
      #     end
      #
      # @return [HaveAttachedMatcher]
      #
      def have_many_attached: (untyped name) -> untyped

      # @private
      class HaveAttachedMatcher
        attr_reader name: untyped

        def initialize: (untyped macro, untyped name) -> void

        def description: () -> ::String

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def expectation: () -> ::String

        def matches?: (untyped subject) -> untyped

        private

        attr_reader subject: untyped

        attr_reader macro: untyped

        def reader_attribute_exists?: () -> (true | false)

        def writer_attribute_exists?: () -> (true | false)

        def attachments_association_exists?: () -> (true | false)

        def attachments_association_matcher: () -> untyped

        def attachments_association_name: () -> untyped

        def blobs_association_exists?: () -> (true | false)

        def blobs_association_matcher: () -> untyped

        def blobs_association_name: () -> untyped

        def eager_loading_scope_exists?: () -> (true | false)

        def model_class: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `have_secure_token` matcher tests usage of the
      # `has_secure_token` macro.
      #
      #     class User < ActiveRecord
      #       has_secure_token
      #       has_secure_token :auth_token
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should have_secure_token }
      #       it { should have_secure_token(:auth_token) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should have_secure_token
      #       should have_secure_token(:auth_token)
      #     end
      #
      # #### Qualifiers
      #
      # ##### ignoring_check_for_db_index
      #
      # By default, this matcher tests that an index is defined on your token
      # column. Use `ignoring_check_for_db_index` if this is not the case.
      #
      #     class User < ActiveRecord
      #       has_secure_token :auth_token
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should have_secure_token(:auth_token).ignoring_check_for_db_index }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should have_secure_token(:auth_token).ignoring_check_for_db_index
      #     end
      #
      # @return [HaveSecureToken]
      #
      def have_secure_token: (?::Symbol token_attribute) -> untyped

      # @private
      class HaveSecureTokenMatcher
        attr_reader token_attribute: untyped

        def initialize: (untyped token_attribute) -> void

        def description: () -> ::String

        def failure_message: () -> (nil | ::String)

        def failure_message_when_negated: () -> (nil | ::String)

        def matches?: (untyped subject) -> untyped

        def ignoring_check_for_db_index: () -> self

        private

        def run_checks: () -> untyped

        def has_expected_instance_methods?: () -> untyped

        def has_expected_db_column?: () -> untyped

        def has_expected_db_index?: () -> untyped

        def table_and_column: () -> ::String

        def table_name: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `define_enum_for` matcher is used to test that the `enum` macro has
      # been used to decorate an attribute with enum capabilities.
      #
      #     class Process < ActiveRecord::Base
      #       enum status: [:running, :stopped, :suspended]
      #
      #       alias_attribute :kind, :SomeLegacyField
      #
      #       enum kind: [:foo, :bar]
      #     end
      #
      #     # RSpec
      #     RSpec.describe Process, type: :model do
      #       it { should define_enum_for(:status) }
      #       it { should define_enum_for(:kind) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProcessTest < ActiveSupport::TestCase
      #       should define_enum_for(:status)
      #       should define_enum_for(:kind)
      #     end
      #
      # #### Qualifiers
      #
      # ##### with_values
      #
      # Use `with_values` to test that the attribute can only receive a certain
      # set of possible values.
      #
      #     class Process < ActiveRecord::Base
      #       enum status: [:running, :stopped, :suspended]
      #     end
      #
      #     # RSpec
      #     RSpec.describe Process, type: :model do
      #       it do
      #         should define_enum_for(:status).
      #           with_values([:running, :stopped, :suspended])
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProcessTest < ActiveSupport::TestCase
      #       should define_enum_for(:status).
      #         with_values([:running, :stopped, :suspended])
      #     end
      #
      # If the values backing your enum attribute are arbitrary instead of a
      # series of integers starting from 0, pass a hash to `with_values` instead
      # of an array:
      #
      #     class Process < ActiveRecord::Base
      #       enum status: {
      #         running: 0,
      #         stopped: 1,
      #         suspended: 3,
      #         other: 99
      #       }
      #     end
      #
      #     # RSpec
      #     RSpec.describe Process, type: :model do
      #       it do
      #         should define_enum_for(:status).
      #           with_values(running: 0, stopped: 1, suspended: 3, other: 99)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProcessTest < ActiveSupport::TestCase
      #       should define_enum_for(:status).
      #         with_values(running: 0, stopped: 1, suspended: 3, other: 99)
      #     end
      #
      # ##### backed_by_column_of_type
      #
      # Use `backed_by_column_of_type` when the column backing your column type
      # is a string instead of an integer:
      #
      #     class LoanApplication < ActiveRecord::Base
      #       enum status: {
      #         active: "active",
      #         pending: "pending",
      #         rejected: "rejected"
      #       }
      #     end
      #
      #     # RSpec
      #     RSpec.describe LoanApplication, type: :model do
      #       it do
      #         should define_enum_for(:status).
      #           with_values(
      #             active: "active",
      #             pending: "pending",
      #             rejected: "rejected"
      #           ).
      #           backed_by_column_of_type(:string)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class LoanApplicationTest < ActiveSupport::TestCase
      #       should define_enum_for(:status).
      #         with_values(
      #           active: "active",
      #           pending: "pending",
      #           rejected: "rejected"
      #         ).
      #         backed_by_column_of_type(:string)
      #     end
      #
      #  ##### with_prefix
      #
      # Use `with_prefix` to test that the enum is defined with a `_prefix`
      # option (Rails 6+ only). Can take either a boolean or a symbol:
      #
      #     class Issue < ActiveRecord::Base
      #       enum status: [:open, :closed], _prefix: :old
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should define_enum_for(:status).
      #           with_values([:open, :closed]).
      #           with_prefix(:old)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProcessTest < ActiveSupport::TestCase
      #       should define_enum_for(:status).
      #         with_values([:open, :closed]).
      #         with_prefix(:old)
      #     end
      #
      # ##### with_suffix
      #
      # Use `with_suffix` to test that the enum is defined with a `_suffix`
      # option (Rails 5 only). Can take either a boolean or a symbol:
      #
      #     class Issue < ActiveRecord::Base
      #       enum status: [:open, :closed], _suffix: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should define_enum_for(:status).
      #           with_values([:open, :closed]).
      #           with_suffix
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProcessTest < ActiveSupport::TestCase
      #       should define_enum_for(:status).
      #         with_values([:open, :closed]).
      #         with_suffix
      #     end
      #
      # ##### without_scopes
      #
      # Use `without_scopes` to test that the enum is defined with
      # '_scopes: false' option (Rails 5 only). Can take either a boolean or a
      # symbol:
      #
      #     class Issue < ActiveRecord::Base
      #       enum status: [:open, :closed], _scopes: false
      #     end
      #
      #     # RSpec
      #     RSpec.describe Issue, type: :model do
      #       it do
      #         should define_enum_for(:status).
      #           without_scopes
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class ProcessTest < ActiveSupport::TestCase
      #       should define_enum_for(:status).
      #         without_scopes
      #     end
      #
      # @return [DefineEnumForMatcher]
      #
      def define_enum_for: (untyped attribute_name) -> untyped

      # @private
      class DefineEnumForMatcher
        def initialize: (untyped attribute_name) -> void

        def description: () -> untyped

        def with_values: (untyped expected_enum_values) -> self

        def with: (untyped expected_enum_values) -> untyped

        def with_prefix: (?bool expected_prefix) -> self

        def with_suffix: (?bool expected_suffix) -> self

        def backed_by_column_of_type: (untyped expected_column_type) -> self

        def without_scopes: () -> self

        def matches?: (untyped subject) -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> untyped

        private

        attr_reader attribute_name: untyped

        attr_reader options: untyped

        attr_reader record: untyped

        attr_reader failure_message_continuation: untyped

        def expectation: () -> untyped

        def simple_description: () -> ::String

        def presented_enum_mapping: (untyped enum_values) -> untyped

        def normalized_expected_enum_values: () -> untyped

        def expected_enum_value_names: () -> untyped

        def expected_enum_values: () -> untyped

        def normalized_actual_enum_values: () -> untyped

        def actual_enum_values: () -> untyped

        def enum_defined?: () -> (true | false)

        def enum_values_match?: () -> untyped

        def column_type_matches?: () -> (true | false)

        def expected_column_type: () -> untyped

        def column: () -> untyped

        def model: () -> untyped

        def enum_value_methods_exist?: () -> (true | false)

        def scope_presence_matches?: () -> (false | true | true | false)

        def missing_methods_message: () -> untyped

        def singleton_methods_exist?: () -> untyped

        def instance_methods_exist?: () -> untyped

        def expected_singleton_methods: () -> untyped

        def expected_instance_methods: () -> untyped

        def expected_prefix: () -> (untyped | nil)

        def expected_suffix: () -> (untyped | nil)

        def exclude_scopes?: () -> untyped

        def to_hash: (untyped value) -> untyped

        def to_array: (untyped value) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `accept_nested_attributes_for` matcher tests usage of the
      # `accepts_nested_attributes_for` macro.
      #
      #     class Car < ActiveRecord::Base
      #       accepts_nested_attributes_for :doors
      #     end
      #
      #     # RSpec
      #     RSpec.describe Car, type: :model do
      #       it { should accept_nested_attributes_for(:doors) }
      #     end
      #
      #     # Minitest (Shoulda) (using Shoulda)
      #     class CarTest < ActiveSupport::TestCase
      #       should accept_nested_attributes_for(:doors)
      #     end
      #
      # #### Qualifiers
      #
      # ##### allow_destroy
      #
      # Use `allow_destroy` to assert that the `:allow_destroy` option was
      # specified.
      #
      #     class Car < ActiveRecord::Base
      #       accepts_nested_attributes_for :mirrors, allow_destroy: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Car, type: :model do
      #       it do
      #         should accept_nested_attributes_for(:mirrors).
      #           allow_destroy(true)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class CarTest < ActiveSupport::TestCase
      #       should accept_nested_attributes_for(:mirrors).
      #         allow_destroy(true)
      #     end
      #
      # ##### limit
      #
      # Use `limit` to assert that the `:limit` option was specified.
      #
      #     class Car < ActiveRecord::Base
      #       accepts_nested_attributes_for :windows, limit: 3
      #     end
      #
      #     # RSpec
      #     RSpec.describe Car, type: :model do
      #       it do
      #         should accept_nested_attributes_for(:windows).
      #           limit(3)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class CarTest < ActiveSupport::TestCase
      #       should accept_nested_attributes_for(:windows).
      #         limit(3)
      #     end
      #
      # ##### update_only
      #
      # Use `update_only` to assert that the `:update_only` option was
      # specified.
      #
      #     class Car < ActiveRecord::Base
      #       accepts_nested_attributes_for :engine, update_only: true
      #     end
      #
      #     # RSpec
      #     RSpec.describe Car, type: :model do
      #       it do
      #         should accept_nested_attributes_for(:engine).
      #           update_only(true)
      #       end
      #     end
      #
      #     # Minitest (Shoulda)
      #     class CarTest < ActiveSupport::TestCase
      #       should accept_nested_attributes_for(:engine).
      #         update_only(true)
      #     end
      #
      # @return [AcceptNestedAttributesForMatcher]
      #
      def accept_nested_attributes_for: (untyped name) -> untyped

      # @private
      class AcceptNestedAttributesForMatcher
        def initialize: (untyped name) -> void

        def allow_destroy: (untyped allow_destroy) -> self

        def limit: (untyped limit) -> self

        def update_only: (untyped update_only) -> self

        def matches?: (untyped subject) -> untyped

        def failure_message: () -> ::String

        def failure_message_when_negated: () -> ::String

        def description: () -> untyped

        def exists?: () -> (true | false)

        def allow_destroy_correct?: () -> untyped

        def limit_correct?: () -> untyped

        def update_only_correct?: () -> untyped

        def verify_option_is_correct: (untyped option, untyped failure_message) -> (true | false | true)

        def config: () -> untyped

        def model_config: () -> untyped

        def model_class: () -> untyped

        def expectation: () -> ::String

        def should_or_should_not: (untyped value) -> ("should" | "should not")
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      def have_implicit_order_column: (untyped column_name) -> untyped

      # @private
      class HaveImplicitOrderColumnMatcher
        attr_reader failure_message: untyped

        def initialize: (untyped column_name) -> void

        def matches?: (untyped subject) -> untyped

        def failure_message_when_negated: () -> untyped

        def description: () -> untyped

        private

        attr_reader column_name: untyped

        attr_reader subject: untyped

        def check_column_exists!: () -> untyped

        def check_implicit_order_column_matches!: () -> (untyped | nil)

        def model: () -> untyped

        def expectation: () -> ::String

        class SecondaryCheckFailedError < StandardError
        end

        class PrimaryCheckFailedError < StandardError
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # @private
      module Uniqueness
        # @private
        class Namespace
          def initialize: (untyped constant) -> void

          def has?: (untyped name) -> untyped

          def set: (untyped name, untyped value) -> untyped

          def clear: () -> untyped

          def to_s: () -> untyped

          attr_reader constant: untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # @private
      module Uniqueness
        # @private
        module TestModels
          def self.create: (untyped model_name) -> untyped

          def self.remove_all: () -> untyped

          def self.root_namespace: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # @private
      module Uniqueness
        # @private
        class Model
          def self.next_unique_copy_of: (untyped model_name, untyped namespace) -> untyped

          def initialize: (untyped name, untyped namespace) -> void

          def already_exists?: () -> untyped

          def next: () -> untyped

          def symlink_to: (untyped parent) -> untyped

          def to_s: () -> untyped

          attr_reader name: untyped

          attr_reader namespace: untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # @private
      module Uniqueness
        # @private
        class TestModelCreator
          def self.create: (untyped model_name, untyped namespace) -> untyped

          def initialize: (untyped model_name, untyped namespace) -> void

          def create: () -> untyped

          attr_reader model_name: untyped

          attr_reader namespace: untyped

          private

          def model_name_without_namespace: () -> untyped

          def new_model: () -> untyped

          def existing_model: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module ActiveRecord
      # The `have_readonly_attribute` matcher tests usage of the
      # `attr_readonly` macro.
      #
      #     class User < ActiveRecord::Base
      #       attr_readonly :password
      #     end
      #
      #     # RSpec
      #     RSpec.describe User, type: :model do
      #       it { should have_readonly_attribute(:password) }
      #     end
      #
      #     # Minitest (Shoulda)
      #     class UserTest < ActiveSupport::TestCase
      #       should have_readonly_attribute(:password)
      #     end
      #
      # @return [HaveReadonlyAttributeMatcher]
      #
      def have_readonly_attribute: (untyped value) -> untyped

      # @private
      class HaveReadonlyAttributeMatcher
        def initialize: (untyped attribute) -> void

        attr_reader failure_message: untyped

        attr_reader failure_message_when_negated: untyped

        def matches?: (untyped subject) -> untyped

        def description: () -> ::String

        private

        def readonly_attributes: () -> untyped

        def class_name: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    # This module provides matchers that are used to test behavior outside of
    # Rails-specific classes.
    module Independent
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      module Inclusion
        def include_into: (untyped mod, *untyped other_mods) ?{ () -> untyped } -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      module Rails
        def rails?: () -> true
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      class ConfigurationError < StandardError
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module Libraries
        # @private
        class ActionController
          include Integrations::Inclusion

          include Integrations::Rails

          def integrate_with: (untyped test_framework) -> untyped

          private

          def matchers_module: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module Libraries
        # @private
        class ActiveModel
          include Integrations::Inclusion

          include Integrations::Rails

          def integrate_with: (untyped test_framework) -> untyped

          private

          def matchers_module: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module Libraries
        # @private
        class Routing
          include Integrations::Inclusion

          include Integrations::Rails

          def integrate_with: (untyped test_framework) -> untyped

          private

          def matchers_module: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module Libraries
        # @private
        class Rails
          include Integrations::Rails

          SUB_LIBRARIES: ::Array[:active_model | :active_record | :action_controller | :routing]

          def integrate_with: (untyped test_framework) -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module Libraries
        # @private
        class MissingLibrary
          def integrate_with: (untyped test_framework) -> nil

          def rails?: () -> false
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module Libraries
        # @private
        class ActiveRecord
          include Integrations::Inclusion

          include Integrations::Rails

          def integrate_with: (untyped test_framework) -> untyped

          private

          def matchers_module: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      module TestFrameworks
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      module Libraries
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      class Registry
        def register: (untyped klass, untyped name) -> untyped

        def find!: (untyped name) -> untyped

        private

        def registry: () -> untyped

        def find_class!: (untyped name) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      # @private
      class Configuration
        def self.apply: () ?{ () -> untyped } -> untyped

        attr_reader test_frameworks: untyped

        def initialize: () ?{ () -> untyped } -> void

        def test_framework: (untyped name) -> untyped

        def library: (untyped name) -> untyped

        def apply: () -> self

        private

        def clear_default_test_framework: () -> untyped

        def no_test_frameworks_added?: () -> untyped

        def no_libraries_added?: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module TestFrameworks
        # @private
        class ActiveSupportTestCase
          def validate!: () -> nil

          def include: (*untyped modules, **untyped _options) -> untyped

          def n_unit?: () -> true

          def present?: () -> true

          attr_reader configuration: untyped

          private

          def test_case_class: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module TestFrameworks
        # @private
        class TestUnit
          def validate!: () -> nil

          def include: (*untyped modules, **untyped _options) -> untyped

          def n_unit?: () -> true

          def present?: () -> true

          private

          def test_case_class: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module TestFrameworks
        # @private
        class Rspec
          def validate!: () -> nil

          def include: (*untyped modules, **untyped options) -> untyped

          def n_unit?: () -> false

          def present?: () -> true
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module TestFrameworks
        # @private
        class Minitest4
          def validate!: () -> nil

          def include: (*untyped modules, **untyped _options) -> untyped

          def n_unit?: () -> true

          def present?: () -> true

          private

          def test_case_class: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module TestFrameworks
        # @private
        class Minitest5
          def validate!: () -> nil

          def include: (*untyped modules, **untyped _options) -> untyped

          def n_unit?: () -> true

          def present?: () -> true

          private

          def test_case_class: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Integrations
      module TestFrameworks
        # @private
        class MissingTestFramework
          def validate!: () -> untyped

          def include: (*untyped modules, **untyped options) -> nil

          def n_unit?: () -> false

          def present?: () -> false
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    module Independent
      # The `delegate_method` matcher tests that an object forwards messages
      # to other, internal objects by way of delegation.
      #
      # In this example, we test that Courier forwards a call to #deliver onto
      # its PostOffice instance:
      #
      #     require 'forwardable'
      #
      #     class Courier
      #       extend Forwardable
      #
      #       attr_reader :post_office
      #
      #       def_delegators :post_office, :deliver
      #
      #       def initialize
      #         @post_office = PostOffice.new
      #       end
      #     end
      #
      #     # RSpec
      #     describe Courier do
      #       it { should delegate_method(:deliver).to(:post_office) }
      #     end
      #
      #     # Minitest
      #     class CourierTest < Minitest::Test
      #       should delegate_method(:deliver).to(:post_office)
      #     end
      #
      # You can also use `delegate_method` with Rails's `delegate` macro:
      #
      #     class Courier
      #       attr_reader :post_office
      #       delegate :deliver, to: :post_office
      #
      #       def initialize
      #         @post_office = PostOffice.new
      #       end
      #     end
      #
      #     describe Courier do
      #       it { should delegate_method(:deliver).to(:post_office) }
      #     end
      #
      # To employ some terminology, we would say that Courier's #deliver method
      # is the *delegating method*, PostOffice is the *delegate object*, and
      # PostOffice#deliver is the *delegate method*.
      #
      # #### Qualifiers
      #
      # ##### as
      #
      # Use `as` if the name of the delegate method is different from the name
      # of the delegating method.
      #
      # Here, Courier has a #deliver method, but instead of calling #deliver on
      # the PostOffice, it calls #ship:
      #
      #     class Courier
      #       attr_reader :post_office
      #
      #       def initialize
      #         @post_office = PostOffice.new
      #       end
      #
      #       def deliver(package)
      #         post_office.ship(package)
      #       end
      #     end
      #
      #     # RSpec
      #     describe Courier do
      #       it { should delegate_method(:deliver).to(:post_office).as(:ship) }
      #     end
      #
      #     # Minitest
      #     class CourierTest < Minitest::Test
      #       should delegate_method(:deliver).to(:post_office).as(:ship)
      #     end
      #
      # ##### with_prefix
      #
      # Use `with_prefix` when using Rails's `delegate` helper along with the
      # `:prefix` option.
      #
      #     class Page < ActiveRecord::Base
      #       belongs_to :site
      #       delegate :name, to: :site, prefix: true
      #       delegate :title, to: :site, prefix: :root
      #     end
      #
      #     # RSpec
      #     describe Page do
      #       it { should delegate_method(:name).to(:site).with_prefix }
      #       it { should delegate_method(:name).to(:site).with_prefix(true) }
      #       it { should delegate_method(:title).to(:site).with_prefix(:root) }
      #     end
      #
      #     # Minitest
      #     class PageTest < Minitest::Test
      #       should delegate_method(:name).to(:site).with_prefix
      #       should delegate_method(:name).to(:site).with_prefix(true)
      #       should delegate_method(:title).to(:site).with_prefix(:root)
      #     end
      #
      # ##### with_arguments
      #
      # Use `with_arguments` to assert that the delegate method is called with
      # certain arguments. Note that this qualifier can only be used when the
      # delegating method takes no arguments; it does not support delegating
      # or delegate methods that take arbitrary arguments.
      #
      # Here, when Courier#deliver_package calls PostOffice#deliver_package, it
      # adds an options hash:
      #
      #     class Courier
      #       attr_reader :post_office
      #
      #       def initialize
      #         @post_office = PostOffice.new
      #       end
      #
      #       def deliver_package
      #         post_office.deliver_package(expedited: true)
      #       end
      #     end
      #
      #     # RSpec
      #     describe Courier do
      #       it do
      #         should delegate_method(:deliver_package).
      #           to(:post_office).
      #           with_arguments(expedited: true)
      #       end
      #     end
      #
      #     # Minitest
      #     class CourierTest < Minitest::Test
      #       should delegate_method(:deliver_package).
      #         to(:post_office).
      #         with_arguments(expedited: true)
      #     end
      #
      # ##### allow_nil
      #
      # Use `allow_nil` if the delegation accounts for the fact that your
      # delegate object could be nil. (This is mostly intended as an analogue to
      # the `allow_nil` option that Rails' `delegate` helper takes.)
      #
      #     class Account
      #       delegate :plan, to: :subscription, allow_nil: true
      #     end
      #
      #     # RSpec
      #     describe Account do
      #       it { should delegate_method(:plan).to(:subscription).allow_nil }
      #     end
      #
      #     # Minitest
      #     class PageTest < Minitest::Test
      #       should delegate_method(:plan).to(:subscription).allow_nil
      #     end
      #
      # @return [DelegateMethodMatcher]
      #
      def delegate_method: (untyped delegating_method) -> untyped

      # @private
      class DelegateMethodMatcher
        def initialize: (untyped delegating_method) -> void

        def in_context: (untyped context) -> self

        def matches?: (untyped subject) -> untyped

        def description: () -> untyped

        def to: (untyped delegate_object_reader_method) -> self

        def as: (untyped delegate_method) -> self

        def with_arguments: (*untyped arguments) -> self

        def with_prefix: (?untyped? prefix) -> self

        def allow_nil: () -> self

        def build_delegating_method_prefix: (untyped prefix) -> untyped

        def failure_message: () -> untyped

        def failure_message_when_negated: () -> ::String

        attr_reader context: untyped

        attr_reader delegated_arguments: untyped

        attr_reader delegating_method: untyped

        attr_reader method: untyped

        attr_reader delegate_method: untyped

        attr_reader delegate_object: untyped

        attr_reader delegate_object_reader_method: untyped

        def subject: () -> untyped

        def subject_is_a_class?: () -> untyped

        def class_under_test: () -> untyped

        def expects_to_allow_nil_delegate_object?: () -> untyped

        def formatted_delegate_method: (?::Hash[untyped, untyped] options) -> untyped

        def formatted_delegating_method_name: (?::Hash[untyped, untyped] options) -> untyped

        def formatted_delegate_object_reader_method_name: (?::Hash[untyped, untyped] options) -> untyped

        def formatted_method_name_for: (untyped method_name, untyped options) -> untyped

        def possible_class_under_test: (untyped options) -> (untyped | "")

        def class_or_instance_method_indicator: () -> ("." | "#")

        def delegate_object_received_call?: () -> untyped

        def delegate_object_received_call_with_delegated_arguments?: () -> untyped

        def subject_has_delegating_method?: () -> untyped

        def subject_has_delegate_object_reader_method?: () -> untyped

        def ensure_delegate_object_has_been_specified!: () -> (untyped | nil)

        def subject_delegates_to_delegate_object_correctly?: () -> untyped

        def subject_handles_nil_delegate_object?: () -> untyped

        def failed_to_allow_nil_delegate_object?: () -> untyped

        def call_delegating_method_with_delegate_method_returning: (untyped value) -> untyped

        def register_subject_double_collection_to: (untyped returned_value) -> untyped

        def calls_to_delegate_method: () -> untyped

        def calls_on_delegate_object: () -> untyped

        def formatted_calls_on_delegate_object: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Independent
      class DelegateMethodMatcher
        # @private
        class DelegateObjectNotSpecified < StandardError
          def message: () -> untyped
        end
      end
    end
  end
end

module Shoulda
  module Matchers
    # @private
    TERMINAL_MAX_WIDTH: 72

    # @private
    def self.warn: (untyped message) -> untyped

    # @private
    def self.warn_about_deprecated_method: (untyped old_method, untyped new_method) -> untyped
  end
end

module Shoulda
  module Matchers
    # @private
    module Doublespeak
      # extend Forwardable

      def self.world: () -> untyped

      def self.debugging_enabled?: () -> untyped

      def self.debug: () ?{ () -> untyped } -> (untyped | nil)
    end
  end
end

module Shoulda
  module Matchers
    # @private
    module Util
      MAXIMUM_LENGTH_OF_VALUE_TO_DISPLAY: 500

      def self.deconstantize: (untyped path) -> untyped

      def self.safe_constantize: (untyped camel_cased_word) -> untyped

      def self.indent: (untyped string, untyped width) -> (nil | untyped)

      def self.a_or_an: (untyped next_word) -> ::String

      def self.inspect_value: (untyped value) -> untyped

      def self.inspect_values: (untyped values) -> untyped

      def self.inspect_range: (untyped range) -> ::String

      def self.inspect_hash: (untyped hash) -> untyped

      def self.dummy_value_for: (untyped column_type, ?array: bool) -> (::Array[untyped] | untyped)
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class MethodCall
        attr_accessor return_value: untyped

        attr_reader method_name: untyped

        attr_reader args: untyped

        attr_reader caller: untyped

        attr_reader block: untyped

        attr_reader object: untyped

        attr_reader double: untyped

        def initialize: (untyped args) -> void

        def with_return_value: (untyped return_value) -> untyped

        def ==: (untyped other) -> untyped

        def to_hash: () -> { method_name: untyped, args: untyped }

        def inspect: () -> ::String
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class Double
        attr_reader calls: untyped

        def initialize: (untyped world, untyped klass, untyped method_name, untyped implementation) -> void

        def activated?: () -> untyped

        def to_return: (?untyped? value) ?{ () -> untyped } -> untyped

        def activate: () -> (untyped | nil)

        def deactivate: () -> (untyped | nil)

        def record_call: (untyped call) -> untyped

        def call_original_method: (untyped call) -> untyped

        attr_reader world: untyped

        attr_reader klass: untyped

        attr_reader method_name: untyped

        attr_reader implementation: untyped

        attr_reader original_method: untyped

        def store_original_method: () -> untyped

        def replace_method_with_double: () -> untyped

        def restore_original_method: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class DoubleCollection
        def initialize: (untyped world, untyped klass) -> void

        def register_stub: (untyped method_name) -> untyped

        def register_proxy: (untyped method_name) -> untyped

        def activate: () -> untyped

        def deactivate: () -> untyped

        def calls_by_method_name: () -> untyped

        def calls_to: (untyped method_name) -> untyped

        attr_reader world: untyped

        attr_reader klass: untyped

        attr_reader doubles_by_method_name: untyped

        def register_double: (untyped method_name, untyped implementation_type) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class ProxyImplementation
        # extend Forwardable

        def self.create: () -> untyped

        def initialize: (untyped stub_implementation) -> void

        def call: (untyped call) -> untyped

        attr_reader stub_implementation: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class ObjectDouble < BasicObject
        attr_reader calls: untyped

        def initialize: () -> void

        def calls_to: (untyped method_name) -> untyped

        def respond_to?: (untyped _name, ?untyped? _include_private) -> true

        def respond_to_missing?: (untyped _name, untyped _include_all) -> true

        def method_missing: (untyped method_name, *untyped args) ?{ () -> untyped } -> nil

        attr_reader calls_by_method_name: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class StubImplementation
        def self.create: () -> untyped

        def initialize: () -> void

        def returns: (?untyped? value) ?{ () -> untyped } -> untyped

        def call: (untyped call) -> untyped

        attr_reader implementation: untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      module DoubleImplementationRegistry
        def self.find: (untyped `type`) -> untyped

        def self.register: (untyped klass, untyped `type`) -> untyped

        private

        def self.find_class!: (untyped `type`) -> untyped

        def self.registry: () -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    module Doublespeak
      # @private
      class World
        def initialize: () -> void

        def double_collection_for: (untyped klass) -> untyped

        def store_original_method_for: (untyped klass, untyped method_name) -> untyped

        def original_method_for: (untyped klass, untyped method_name) -> (untyped | nil)

        def with_doubles_activated: () { () -> untyped } -> untyped

        def doubles_activated?: () -> untyped

        private

        def activate: () -> untyped

        def deactivate: () -> untyped

        def double_collections_by_class: () -> untyped

        def original_methods_by_class: () -> untyped

        def original_methods_for_class: (untyped klass) -> untyped
      end
    end
  end
end

module Shoulda
  module Matchers
    # This module provides matchers that are used to test behavior within
    # ActiveRecord classes.
    module ActiveRecord
    end
  end
end

module Shoulda
  module Matchers
    # @private
    VERSION: "5.1.0"
  end
end

module Shoulda
  module Matchers
    # @private
    class Error < StandardError
      def self.create: (untyped attributes) -> untyped

      def initialize: (*untyped args) -> void

      def message: () -> ""

      def inspect: () -> ::String
    end
  end
end

module Shoulda
  module Matchers
    # @private
    class MatcherContext
      def initialize: (untyped context) -> void

      def subject_is_a_class?: () -> untyped

      attr_reader context: untyped

      private

      def inside_a_shoulda_context_project?: () -> untyped

      def outside_a_should_block?: () -> untyped

      def assume_that_subject_is_not_a_class: () -> false
    end
  end
end

module Shoulda
  module Matchers
    # @private
    def self.configure: () { (untyped) -> untyped } -> untyped

    # @private
    def self.integrations: () -> untyped

    # @private
    def self.configuration: () -> untyped

    # @private
    class Configuration
      attr_reader integrations: untyped

      def initialize: () -> void

      def integrate: () ?{ () -> untyped } -> untyped
    end
  end
end

