
module RSpec
  module Core
    # This module is included in {ExampleGroup}, making the methods
    # available to be called from within example blocks.
    #
    # @see ClassMethods
    module MemoizedHelpers
      # @note `subject` was contributed by Joe Ferris to support the one-liner
      #   syntax embraced by shoulda matchers:
      #
      #       RSpec.describe Widget do
      #         it { is_expected.to validate_presence_of(:name) }
      #         # or
      #         it { should validate_presence_of(:name) }
      #       end
      #
      #   While the examples below demonstrate how to use `subject`
      #   explicitly in examples, we recommend that you define a method with
      #   an intention revealing name instead.
      #
      # @example
      #
      #   # Explicit declaration of subject.
      #   RSpec.describe Person do
      #     subject { Person.new(:birthdate => 19.years.ago) }
      #     it "should be eligible to vote" do
      #       subject.should be_eligible_to_vote
      #       # ^ ^ explicit reference to subject not recommended
      #     end
      #   end
      #
      #   # Implicit subject => { Person.new }.
      #   RSpec.describe Person do
      #     it "should be eligible to vote" do
      #       subject.should be_eligible_to_vote
      #       # ^ ^ explicit reference to subject not recommended
      #     end
      #   end
      #
      #   # One-liner syntax - expectation is set on the subject.
      #   RSpec.describe Person do
      #     it { is_expected.to be_eligible_to_vote }
      #     # or
      #     it { should be_eligible_to_vote }
      #   end
      #
      # @note Because `subject` is designed to create state that is reset
      #   between each example, and `before(:context)` is designed to setup
      #   state that is shared across _all_ examples in an example group,
      #   `subject` is _not_ intended to be used in a `before(:context)` hook.
      #
      # @see #should
      # @see #should_not
      # @see #is_expected
      def subject: () -> untyped

      # When `should` is called with no explicit receiver, the call is
      # delegated to the object returned by `subject`. Combined with an
      # implicit subject this supports very concise expressions.
      #
      # @example
      #
      #   RSpec.describe Person do
      #     it { should be_eligible_to_vote }
      #   end
      #
      # @see #subject
      # @see #is_expected
      #
      # @note This only works if you are using rspec-expectations.
      # @note If you are using RSpec's newer expect-based syntax you may
      #       want to use `is_expected.to` instead of `should`.
      def should: (?untyped? matcher, ?untyped? message) -> untyped

      # Just like `should`, `should_not` delegates to the subject (implicit or
      # explicit) of the example group.
      #
      # @example
      #
      #   RSpec.describe Person do
      #     it { should_not be_eligible_to_vote }
      #   end
      #
      # @see #subject
      # @see #is_expected
      #
      # @note This only works if you are using rspec-expectations.
      # @note If you are using RSpec's newer expect-based syntax you may
      #       want to use `is_expected.to_not` instead of `should_not`.
      def should_not: (?untyped? matcher, ?untyped? message) -> untyped

      # Wraps the `subject` in `expect` to make it the target of an expectation.
      # Designed to read nicely for one-liners.
      #
      # @example
      #
      #   describe [1, 2, 3] do
      #     it { is_expected.to be_an Array }
      #     it { is_expected.not_to include 4 }
      #   end
      #
      # @see #subject
      # @see #should
      # @see #should_not
      #
      # @note This only works if you are using rspec-expectations.
      def is_expected: () -> untyped

      private

      # @private
      # should just be placed in private section,
      # but Ruby issues warnings on private attributes.
      # and expanding it to the equivalent method upsets Rubocop,
      # b/c it should obviously be a reader
      attr_reader __memoized: untyped

      # @private
      def initialize: () -> void

      # @private
      def __init_memoized: () -> untyped

      # @private
      def enforce_value_expectation: (untyped matcher, untyped method_name) -> (nil | untyped)

      def matcher_supports_value_expectations?: (untyped matcher) -> untyped

      # @private
      class ThreadsafeMemoized
        def initialize: () -> void

        def fetch_or_store: (untyped key) { () -> untyped } -> untyped
      end

      # @private
      class NonThreadSafeMemoized
        def initialize: () -> void

        def fetch_or_store: (untyped key) { () -> untyped } -> untyped
      end

      # Used internally to customize the behavior of the
      # memoized hash when used in a `before(:context)` hook.
      #
      # @private
      class ContextHookMemoized
        def self.isolate_for_context_hook: (untyped example_group_instance) { () -> untyped } -> untyped

        def self.fetch_or_store: (untyped key) { () -> untyped } -> untyped

        # @private
        class Before # < 
          def self.hook_expression: () -> "`before(:context)`"

          def self.article: () -> "a"

          def self.hook_intention: () -> "define state that is shared across examples in an example group"
        end

        # @private
        class After # < 
          def self.hook_expression: () -> "`after(:context)`"

          def self.article: () -> "an"

          def self.hook_intention: () -> "cleanup state that is shared across examples in an example group"
        end
      end

      # This module is extended onto {ExampleGroup}, making the methods
      # available to be called from within example group blocks.
      # You can think of them as being analagous to class macros.
      module ClassMethods
        # Generates a method whose return value is memoized after the first
        # call. Useful for reducing duplication between examples that assign
        # values to the same local variable.
        #
        # @note `let` _can_ enhance readability when used sparingly (1,2, or
        #   maybe 3 declarations) in any given example group, but that can
        #   quickly degrade with overuse. YMMV.
        #
        # @note `let` can be configured to be threadsafe or not.
        #   If it is threadsafe, it will take longer to access the value.
        #   If it is not threadsafe, it may behave in surprising ways in examples
        #   that spawn separate threads. Specify this on `RSpec.configure`
        #
        # @note Because `let` is designed to create state that is reset between
        #   each example, and `before(:context)` is designed to setup state that
        #   is shared across _all_ examples in an example group, `let` is _not_
        #   intended to be used in a `before(:context)` hook.
        #
        # @example
        #
        #   RSpec.describe Thing do
        #     let(:thing) { Thing.new }
        #
        #     it "does something" do
        #       # First invocation, executes block, memoizes and returns result.
        #       thing.do_something
        #
        #       # Second invocation, returns the memoized value.
        #       thing.should be_something
        #     end
        #   end
        def let: (untyped name) { () -> untyped } -> untyped

        # Just like `let`, except the block is invoked by an implicit `before`
        # hook. This serves a dual purpose of setting up state and providing a
        # memoized reference to that state.
        #
        # @example
        #
        #   class Thing
        #     def self.count
        #       @count ||= 0
        #     end
        #
        #     def self.count=(val)
        #       @count += val
        #     end
        #
        #     def self.reset_count
        #       @count = 0
        #     end
        #
        #     def initialize
        #       self.class.count += 1
        #     end
        #   end
        #
        #   RSpec.describe Thing do
        #     after(:example) { Thing.reset_count }
        #
        #     context "using let" do
        #       let(:thing) { Thing.new }
        #
        #       it "is not invoked implicitly" do
        #         Thing.count.should eq(0)
        #       end
        #
        #       it "can be invoked explicitly" do
        #         thing
        #         Thing.count.should eq(1)
        #       end
        #     end
        #
        #     context "using let!" do
        #       let!(:thing) { Thing.new }
        #
        #       it "is invoked implicitly" do
        #         Thing.count.should eq(1)
        #       end
        #
        #       it "returns memoized version on first invocation" do
        #         thing
        #         Thing.count.should eq(1)
        #       end
        #     end
        #   end
        def let!: (untyped name) { () -> untyped } -> untyped

        # Declares a `subject` for an example group which can then be wrapped
        # with `expect` using `is_expected` to make it the target of an
        # expectation in a concise, one-line example.
        #
        # Given a `name`, defines a method with that name which returns the
        # `subject`. This lets you declare the subject once and access it
        # implicitly in one-liners and explicitly using an intention revealing
        # name.
        #
        # When given a `name`, calling `super` in the block is not supported.
        #
        # @note `subject` can be configured to be threadsafe or not.
        #   If it is threadsafe, it will take longer to access the value.
        #   If it is not threadsafe, it may behave in surprising ways in examples
        #   that spawn separate threads. Specify this on `RSpec.configure`
        #
        # @param name [String,Symbol] used to define an accessor with an
        #   intention revealing name
        # @param block defines the value to be returned by `subject` in examples
        #
        # @example
        #
        #   RSpec.describe CheckingAccount, "with $50" do
        #     subject { CheckingAccount.new(Money.new(50, :USD)) }
        #     it { is_expected.to have_a_balance_of(Money.new(50, :USD)) }
        #     it { is_expected.not_to be_overdrawn }
        #   end
        #
        #   RSpec.describe CheckingAccount, "with a non-zero starting balance" do
        #     subject(:account) { CheckingAccount.new(Money.new(50, :USD)) }
        #     it { is_expected.not_to be_overdrawn }
        #     it "has a balance equal to the starting balance" do
        #       account.balance.should eq(Money.new(50, :USD))
        #     end
        #   end
        #
        # @see MemoizedHelpers#should
        # @see MemoizedHelpers#should_not
        # @see MemoizedHelpers#is_expected
        def subject: (?untyped? name) { () -> untyped } -> untyped

        # Just like `subject`, except the block is invoked by an implicit
        # `before` hook. This serves a dual purpose of setting up state and
        # providing a memoized reference to that state.
        #
        # @example
        #
        #   class Thing
        #     def self.count
        #       @count ||= 0
        #     end
        #
        #     def self.count=(val)
        #       @count += val
        #     end
        #
        #     def self.reset_count
        #       @count = 0
        #     end
        #
        #     def initialize
        #       self.class.count += 1
        #     end
        #   end
        #
        #   RSpec.describe Thing do
        #     after(:example) { Thing.reset_count }
        #
        #     context "using subject" do
        #       subject { Thing.new }
        #
        #       it "is not invoked implicitly" do
        #         Thing.count.should eq(0)
        #       end
        #
        #       it "can be invoked explicitly" do
        #         subject
        #         Thing.count.should eq(1)
        #       end
        #     end
        #
        #     context "using subject!" do
        #       subject!(:thing) { Thing.new }
        #
        #       it "is invoked implicitly" do
        #         Thing.count.should eq(1)
        #       end
        #
        #       it "returns memoized version on first invocation" do
        #         subject
        #         Thing.count.should eq(1)
        #       end
        #     end
        #   end
        def subject!: (?untyped? name) { () -> untyped } -> untyped
      end

      # @private
      #
      # Gets the LetDefinitions module. The module is mixed into
      # the example group and is used to hold all let definitions.
      # This is done so that the block passed to `let` can be
      # forwarded directly on to `define_method`, so that all method
      # constructs (including `super` and `return`) can be used in
      # a `let` block.
      #
      # The memoization is provided by a method definition on the
      # example group that supers to the LetDefinitions definition
      # in order to get the value to memoize.
      def self.module_for: (untyped example_group) -> untyped

      # @private
      def self.define_helpers_on: (untyped example_group) -> untyped

      # for 1.8
      # @private
      #
      # Gets the named constant or yields.
      # On 1.8, const_defined? / const_get do not take into
      # account the inheritance hierarchy.
      # :nocov:
      def self.get_constant_or_yield: (untyped example_group, untyped name) { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    class BacktraceFormatter
      # @private
      attr_accessor exclusion_patterns: untyped

      # @private
      attr_accessor inclusion_patterns: untyped

      def initialize: () -> void

      attr_writer full_backtrace: untyped

      def full_backtrace?: () -> untyped

      def filter_gem: (untyped gem_name) -> untyped

      def format_backtrace: (untyped backtrace, ?::Hash[untyped, untyped] options) -> (::Array[untyped] | untyped)

      def backtrace_line: (untyped line) -> untyped

      def exclude?: (untyped line) -> (false | untyped)

      private

      def matches?: (untyped patterns, untyped line) -> untyped
    end
  end
end

# Minitest: untyped

module RSpec
  module Core
    # @private
    module MinitestAssertionsAdapter
      include ::Minitest::Assertions

      # Need to forcefully include Pending after Minitest::Assertions
      # to make sure our own #skip method beats Minitest's.
      include ::RSpec::Core::Pending

      # Minitest 5.x requires this accessor to be available. See
      # https://github.com/seattlerb/minitest/blob/38f0a5fcbd9c37c3f80a3eaad4ba84d3fc9947a0/lib/minitest/assertions.rb#L8
      #
      # It is not required for other extension libraries, and RSpec does not
      # report or make this information available to formatters.
      attr_writer assertions: untyped

      def assertions: () -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    class OutputWrapper
      # @private
      attr_accessor output: untyped

      # @private
      def initialize: (untyped output) -> void

      def respond_to?: (untyped name, ?bool priv) -> untyped

      def method_missing: (untyped name, *untyped args) { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    # RSpec rake task
    #
    # @see Rakefile
    class RakeTask # < ::Rake::TaskLib
      # include ::Rake::DSL

      include RSpec::Core::ShellEscape

      # Default path to the RSpec executable.
      DEFAULT_RSPEC_PATH: untyped

      # Default pattern for spec files.
      DEFAULT_PATTERN: "spec/**{,/*/**}/*_spec.rb"

      # Name of task. Defaults to `:spec`.
      attr_accessor name: untyped

      # Files matching this pattern will be loaded.
      # Defaults to `'spec/**{,/*/**}/*_spec.rb'`.
      attr_accessor pattern: untyped

      # Files matching this pattern will be excluded.
      # Defaults to `nil`.
      attr_accessor exclude_pattern: untyped

      # Whether or not to fail Rake when an error occurs (typically when
      # examples fail). Defaults to `true`.
      attr_accessor fail_on_error: untyped

      # A message to print to stderr when there are failures.
      attr_accessor failure_message: untyped

      # Run RSpec with a clean (empty) environment is not supported
      # def with_clean_environment=: (untyped _value) -> untyped

      # Run RSpec with a clean (empty) environment is not supported
      # def with_clean_environment: () -> false

      # Run RSpec with a clean (empty) environment.
      attr_accessor with_clean_environment: untyped

      # Use verbose output. If this is set to true, the task will print the
      # executed spec command to stdout. Defaults to `true`.
      attr_accessor verbose: untyped

      # Command line options to pass to ruby. Defaults to `nil`.
      attr_accessor ruby_opts: untyped

      # Path to RSpec. Defaults to the absolute path to the
      # rspec binary from the loaded rspec-core gem.
      attr_accessor rspec_path: untyped

      # Command line options to pass to RSpec. Defaults to `nil`.
      attr_accessor rspec_opts: untyped

      def initialize: (*untyped args) { () -> untyped } -> void

      # @private
      def run_task: (untyped verbose) -> (nil | untyped)

      private

      # @private
      def define: (untyped args) { () -> untyped } -> untyped

      def file_inclusion_specification: () -> untyped

      def file_exclusion_specification: () -> untyped

      def spec_command: () -> untyped

      def blank: () -> untyped

      def rspec_load_path: () -> untyped
    end
  end
end

module RSpec::Core
  # @private
  class Parser
    def self.parse: (untyped args, ?untyped? source) -> untyped

    attr_reader original_args: untyped

    def initialize: (untyped original_args) -> void

    def parse: (?untyped? source) -> ({ files_or_directories_to_run: ::Array[untyped] } | untyped)

    private

    # rubocop:disable Metrics/AbcSize
    # rubocop:disable Metrics/MethodLength
    # rubocop:disable Metrics/CyclomaticComplexity
    # rubocop:disable Metrics/PerceivedComplexity
    def parser: (untyped options) -> untyped

    def add_tag_filter: (untyped options, untyped filter_type, untyped tag_name, ?bool value) -> untyped

    def set_fail_fast: (untyped options, untyped value) -> untyped

    def configure_only_failures: (untyped options) -> untyped
  end
end

module RSpec
  module Core
    # @private
    class Profiler
      NOTIFICATIONS: ::Array[:example_group_started | :example_group_finished | :example_started]

      def initialize: () -> void

      attr_reader example_groups: untyped

      def example_group_started: (untyped notification) -> (nil | untyped)

      def example_group_finished: (untyped notification) -> (nil | untyped)

      def example_started: (untyped notification) -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    #
    # We use this to replace `::Set` so we can have the advantage of
    # constant time key lookups for unique arrays but without the
    # potential to pollute a developers environment with an extra
    # piece of the stdlib. This helps to prevent false positive
    # builds.
    #
    class Set
      # include Enumerable[untyped]

      def initialize: (?untyped array) -> void

      def empty?: () -> untyped

      def <<: (untyped key) -> untyped

      def delete: (untyped key) -> untyped

      def each: () { () -> untyped } -> untyped

      def include?: (untyped key) -> untyped

      def merge: (untyped values) -> untyped

      def clear: () -> untyped
    end
  end
end

module RSpec
  module Core
    module MockingAdapters
      # @private
      module Flexmock
        # include ::FlexMock::MockContainer

        def self.framework_name: () -> :flexmock

        def setup_mocks_for_rspec: () -> nil

        def verify_mocks_for_rspec: () -> untyped

        def teardown_mocks_for_rspec: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module MockingAdapters
      # @private
      module Mocha
        def self.framework_name: () -> :mocha

        # include ::Mocha::API

        # include ::Mocha::Standalone

        def setup_mocks_for_rspec: () -> untyped

        def verify_mocks_for_rspec: () -> untyped

        def teardown_mocks_for_rspec: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    # @private
    module MockingAdapters
      # @private
      module RR
        def self.framework_name: () -> :rr

        # include ::RR::Extensions::InstanceMethods

        def setup_mocks_for_rspec: () -> untyped

        def verify_mocks_for_rspec: () -> untyped

        def teardown_mocks_for_rspec: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module MockingAdapters
      # @private
      module RSpec
        include ::RSpec::Mocks::ExampleMethods

        def self.framework_name: () -> :rspec

        def self.configuration: () -> untyped

        def setup_mocks_for_rspec: () -> untyped

        def verify_mocks_for_rspec: () -> untyped

        def teardown_mocks_for_rspec: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module MockingAdapters
      # @private
      module Null
        def setup_mocks_for_rspec: () -> nil

        def verify_mocks_for_rspec: () -> nil

        def teardown_mocks_for_rspec: () -> nil
      end
    end
  end
end

module RSpec
  module Core
    # @private
    module TestUnitAssertionsAdapter
      # include ::Test::Unit::Assertions

      include ::RSpec::Core::MinitestAssertionsAdapter
    end
  end
end

module RSpec
  module Core
    # @private
    class FilterManager
      attr_reader exclusions: untyped

      attr_reader inclusions: untyped

      def initialize: () -> void

      # @api private
      #
      # @param file_path [String]
      # @param line_numbers [Array]
      def add_location: (untyped file_path, untyped line_numbers) -> untyped

      def add_ids: (untyped rerun_path, untyped scoped_ids) -> untyped

      def empty?: () -> untyped

      def prune: (untyped examples) -> untyped

      def exclude: (*untyped args) -> untyped

      def exclude_only: (*untyped args) -> untyped

      def exclude_with_low_priority: (*untyped args) -> untyped

      def include: (*untyped args) -> untyped

      def include_only: (*untyped args) -> untyped

      def include_with_low_priority: (*untyped args) -> untyped

      private

      def add_path_to_arrays_filter: (untyped filter_key, untyped path, untyped values) -> untyped

      def prune_conditionally_filtered_examples: (untyped examples) -> untyped

      # When a user specifies a particular spec location, that takes priority
      # over any exclusion filters (such as if the spec is tagged with `:slow`
      # and there is a `:slow => true` exclusion filter), but only for specs
      # defined in the same file as the location filters. Excluded specs in
      # other files should still be excluded.
      def file_scoped_include?: (untyped ex_metadata, untyped ids, untyped locations) { () -> untyped } -> untyped
    end

    # @private
    class FilterRules
      PROC_HEX_NUMBER: ::Regexp

      PROJECT_DIR: untyped

      attr_accessor opposite: untyped

      attr_reader rules: untyped

      def self.build: () -> ::Array[untyped]

      def initialize: (?::Hash[untyped, untyped] rules) -> void

      def add: (untyped updated) -> untyped

      def add_with_low_priority: (untyped updated) -> untyped

      def use_only: (untyped updated) -> untyped

      def clear: () -> untyped

      def delete: (untyped key) -> untyped

      def fetch: (*untyped args) { () -> untyped } -> untyped

      def []: (untyped key) -> untyped

      def empty?: () -> untyped

      def each_pair: () { () -> untyped } -> untyped

      def description: () -> untyped

      def include_example?: (untyped example) -> untyped
    end

    # @private
    ExclusionRules: untyped

    # @private
    class InclusionRules < FilterRules
      def add: (*untyped args) -> untyped

      def add_with_low_priority: (*untyped args) -> untyped

      def include_example?: (untyped example) -> untyped

      def standalone?: () -> untyped

      def split_file_scoped_rules: () -> untyped

      private

      def apply_standalone_filter: (untyped updated) -> (true | nil)

      def replace_filters: (untyped new_rules) -> untyped

      def is_standalone_filter?: (untyped rules) -> untyped
    end
  end
end

module RSpec
  module Core
    # Exposes {ExampleGroup}-level methods to a module, so you can include that
    # module in an {ExampleGroup}.
    #
    # @example
    #
    #     module LoggedInAsAdmin
    #       extend RSpec::Core::SharedContext
    #       before(:example) do
    #         log_in_as :admin
    #       end
    #     end
    #
    #     describe "admin section" do
    #       include LoggedInAsAdmin
    #       # ...
    #     end
    module SharedContext
      # @private
      def included: (untyped group) -> untyped

      # @private
      def __shared_context_recordings: () -> untyped

      # @private
      Recording: untyped

      # @private
      def self.record: (untyped methods) -> untyped
    end
  end

  # @private
  SharedContext: untyped
end

module RSpec
  module Core
    module Bisect
      # @private
      ExampleSetDescriptor: untyped

      # @private
      class BisectFailedError < StandardError
        def self.for_failed_spec_run: (untyped spec_output) -> untyped
      end

      # Wraps a `formatter` providing a simple means to notify it in place
      # of an `RSpec::Core::Reporter`, without involving configuration in
      # any way.
      # @private
      class Notifier
        def initialize: (untyped formatter) -> void

        def publish: (untyped event, *untyped args) -> (nil | untyped)
      end

      # Wraps a pipe to support sending objects between a child and
      # parent process. Where supported, encoding is explicitly
      # set to ensure binary data is able to pass from child to
      # parent.
      # @private
      class Channel
        MARSHAL_DUMP_ENCODING: untyped

        def initialize: () -> void

        def send: (untyped message) -> untyped

        # rubocop:disable Security/MarshalLoad
        def receive: () -> untyped

        def close: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Bisect
      # Provides an API to run the suite for a set of locations, using
      # the given bisect server to capture the results.
      #
      # Sets of specs are run by shelling out.
      # @private
      class ShellRunner
        def self.start: (untyped shell_command, untyped _spec_runner) { (untyped) -> untyped } -> untyped

        def self.name: () -> :shell

        def initialize: (untyped server, untyped shell_command) -> void

        def run: (untyped locations) -> untyped

        def original_results: () -> untyped

        private

        def run_locations: (*untyped capture_args) -> untyped

        def run_command: (untyped cmd) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Bisect
      # @private
      # Contains the core bisect logic. Searches for examples we can ignore by
      # repeatedly running different subsets of the suite.
      class ExampleMinimizer
        attr_reader shell_command: untyped

        attr_reader runner: untyped

        attr_reader all_example_ids: untyped

        attr_reader failed_example_ids: untyped

        attr_accessor remaining_ids: untyped

        def initialize: (untyped shell_command, untyped runner, untyped notifier) -> void

        def find_minimal_repro: () -> untyped

        def bisect: (untyped candidate_ids) -> (nil | untyped)

        def bisect_over: (untyped candidate_ids) -> (nil | untyped)

        def currently_needed_ids: () -> untyped

        def repro_command_for_currently_needed_ids: () -> (untyped | "(Not yet enough information to provide any repro command)")

        # @private
        # Convenience class for describing a subset of the candidate examples
        ExampleRange: untyped

        private

        def example_range: (untyped ids) -> untyped

        def prep: () -> untyped

        def non_failing_example_ids: () -> untyped

        def get_expected_failures_for?: (untyped ids) -> untyped

        def track_duration: () { () -> untyped } -> ::Array[untyped]

        def abort_if_ordering_inconsistent: (untyped results) -> (nil | untyped)

        def notify: (*untyped args) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Bisect
      # A Bisect runner that runs requested subsets of the suite by forking
      # sub-processes. The main process bootstraps RSpec and the application
      # environment (including preloading files specified via `--require`) so
      # that the individual spec runs do not have to re-pay that cost.  Each
      # spec run happens in a forked process, ensuring that the spec files are
      # not loaded in the main process.
      #
      # For most projects, bisections that use `ForkRunner` instead of
      # `ShellRunner` will finish significantly faster, because the `ShellRunner`
      # pays the cost of booting RSpec and the app environment on _every_ run of
      # a subset. In contrast, `ForkRunner` pays that cost only once.
      #
      # However, not all projects can use `ForkRunner`. Obviously, on platforms
      # that do not support forking (e.g. Windows), it cannot be used. In addition,
      # it can cause problems for some projects that put side-effectful spec
      # bootstrapping logic that should run on every spec run directly at the top
      # level in a file loaded by `--require`, rather than in a `before(:suite)`
      # hook. For example, consider a project that relies on some top-level logic
      # in `spec_helper` to boot a Redis server for the test suite, intending the
      # Redis bootstrapping to happen on every spec run. With `ShellRunner`, the
      # bootstrapping logic will happen for each run of any subset of the suite,
      # but for `ForkRunner`, such logic will only get run once, when the
      # `RunDispatcher` boots the application environment. This might cause
      # problems. The solution is for users to move the bootstrapping logic into
      # a `before(:suite)` hook, or use the slower `ShellRunner`.
      #
      # @private
      class ForkRunner
        def self.start: (untyped shell_command, untyped spec_runner) { (untyped) -> untyped } -> untyped

        def self.name: () -> :fork

        def initialize: (untyped shell_command, untyped spec_runner) -> void

        def run: (untyped locations) -> untyped

        def original_results: () -> untyped

        def shutdown: () -> untyped

        private

        def dispatch_run: (untyped run_descriptor) -> untyped

        # @private
        class RunDispatcher
          def initialize: (untyped runner, untyped channel) -> void

          def dispatch_specs: (untyped run_descriptor) -> untyped

          private

          def run_specs: (untyped run_descriptor) -> untyped
        end

        class CaptureFormatter < Formatters::BaseBisectFormatter
          attr_accessor results: untyped

          alias notify_results results=
        end
      end
    end
  end
end

module RSpec
  module Core
    module Bisect
      # Provides an API to generate shell commands to run the suite for a
      # set of locations, using the given bisect server to capture the results.
      # @private
      class ShellCommand
        attr_reader original_cli_args: untyped

        def initialize: (untyped original_cli_args) -> void

        def command_for: (untyped locations, untyped server) -> untyped

        def repro_command_from: (untyped locations) -> untyped

        def original_locations: () -> untyped

        def bisect_environment_hash: () -> untyped

        def spec_opts_without_bisect: () -> untyped

        private

        include RSpec::Core::ShellEscape

        # :nocov:
        # alias open3_safe_escape quote

        alias open3_safe_escape escape

        def environment_repro_parts: () -> untyped

        def reusable_cli_options: () -> untyped

        def original_cli_args_without_locations: () -> untyped

        def parsed_original_cli_options: () -> untyped

        def load_path: () -> untyped

        # Path to the currently running Ruby executable, borrowed from Rake:
        # https://github.com/ruby/rake/blob/v10.4.2/lib/rake/file_utils.rb#L8-L12
        # Note that we skip `ENV['RUBY']` because we don't have to deal with running
        # RSpec from within a MRI source repository:
        # https://github.com/ruby/rake/commit/968682759b3b65e42748cd2befb2ff3e982272d9
        RUBY: untyped
      end
    end
  end
end

module RSpec
  module Core
    # @private
    module Bisect
      # @private
      # A DRb server that receives run results from a separate RSpec process
      # started by the bisect process.
      class Server
        def self.run: () { (untyped) -> untyped } -> untyped

        def capture_run_results: (?untyped files_or_directories_to_run, ?untyped expected_failures) { () -> untyped } -> untyped

        def start: () -> untyped

        def stop: () -> untyped

        def drb_port: () -> untyped

        # Fetched via DRb by the BisectDRbFormatter to determine when to abort.
        attr_accessor expected_failures: untyped

        # Set via DRb by the BisectDRbFormatter with the results of the run.
        attr_accessor latest_run_results: untyped

        # Fetched via DRb to tell clients which files to run
        attr_accessor files_or_directories_to_run: untyped
      end
    end
  end
end

module RSpec
  module Core
    module Bisect
      # The main entry point into the bisect logic. Coordinates among:
      #   - Bisect::ShellCommand: Generates shell commands to run spec subsets
      #   - Bisect::ExampleMinimizer: Contains the core bisect logic.
      #   - A bisect runner: runs a set of examples and returns the results.
      #   - A bisect formatter: provides progress updates to the user.
      # @private
      class Coordinator
        def self.bisect_with: (untyped spec_runner, untyped original_cli_args, untyped formatter) -> untyped

        def initialize: (untyped spec_runner, untyped original_cli_args, untyped formatter) -> void

        def bisect: () -> untyped

        private

        def start_bisect_runner: () { () -> untyped } -> untyped

        def gracefully_abort_on_sigint: (untyped minimizer) -> untyped
      end
    end
  end
end

module RSpec::Core
  # Notifications are value objects passed to formatters to provide them
  # with information about a particular event of interest.
  module Notifications
    # @private
    module NullColorizer
      def self?.wrap: (untyped line, untyped _code_or_symbol) -> untyped
    end

    # The `StartNotification` represents a notification sent by the reporter
    # when the suite is started. It contains the expected amount of examples
    # to be executed, and the load time of RSpec.
    #
    # @attr count [Fixnum] the number counted
    # @attr load_time [Float] the number of seconds taken to boot RSpec
    #                         and load the spec files
    StartNotification: untyped

    # The `ExampleNotification` represents notifications sent by the reporter
    # which contain information about the current (or soon to be) example.
    # It is used by formatters to access information about that example.
    #
    # @example
    #   def example_started(notification)
    #     puts "Hey I started #{notification.example.description}"
    #   end
    #
    # @attr example [RSpec::Core::Example] the current example
    # ExampleNotification: untyped

    class ExampleNotification
      # @private
      def self.for: (untyped example) -> untyped
    end

    # The `ExamplesNotification` represents notifications sent by the reporter
    # which contain information about the suites examples.
    #
    # @example
    #   def stop(notification)
    #     puts "Hey I ran #{notification.examples.size}"
    #   end
    #
    class ExamplesNotification
      def initialize: (untyped reporter) -> void

      # @return [Array<RSpec::Core::Example>] list of examples
      def examples: () -> untyped

      # @return [Array<RSpec::Core::Example>] list of failed examples
      def failed_examples: () -> untyped

      # @return [Array<RSpec::Core::Example>] list of pending examples
      def pending_examples: () -> untyped

      # @return [Array<RSpec::Core::Notifications::ExampleNotification>]
      #         returns examples as notifications
      def notifications: () -> untyped

      # @return [Array<RSpec::Core::Notifications::FailedExampleNotification>]
      #         returns failed examples as notifications
      def failure_notifications: () -> untyped

      # @return [Array<RSpec::Core::Notifications::SkippedExampleNotification,
      #                 RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification>]
      #         returns pending examples as notifications
      def pending_notifications: () -> untyped

      # @return [String] The list of failed examples, fully formatted in the way
      #   that RSpec's built-in formatters emit.
      def fully_formatted_failed_examples: (?untyped colorizer) -> untyped

      # @return [String] The list of pending examples, fully formatted in the
      #   way that RSpec's built-in formatters emit.
      def fully_formatted_pending_examples: (?untyped colorizer) -> untyped

      private

      def format_examples: (untyped examples) -> untyped
    end

    # The `FailedExampleNotification` extends `ExampleNotification` with
    # things useful for examples that have failure info -- typically a
    # failed or pending spec.
    #
    # @example
    #   def example_failed(notification)
    #     puts "Hey I failed :("
    #     puts "Here's my stack trace"
    #     puts notification.exception.backtrace.join("\n")
    #   end
    #
    # @attr [RSpec::Core::Example] example the current example
    # @see ExampleNotification
    class FailedExampleNotification < ExampleNotification
      # @return [Exception] The example failure
      def exception: () -> untyped

      # @return [String] The example description
      def description: () -> untyped

      # Returns the message generated for this failure line by line.
      #
      # @return [Array<String>] The example failure message
      def message_lines: () -> untyped

      # Returns the message generated for this failure colorized line by line.
      #
      # @param colorizer [#wrap] An object to colorize the message_lines by
      # @return [Array<String>] The example failure message colorized
      def colorized_message_lines: (?untyped colorizer) -> untyped

      # Returns the failures formatted backtrace.
      #
      # @return [Array<String>] the examples backtrace lines
      def formatted_backtrace: () -> untyped

      # Returns the failures colorized formatted backtrace.
      #
      # @param colorizer [#wrap] An object to colorize the message_lines by
      # @return [Array<String>] the examples colorized backtrace lines
      def colorized_formatted_backtrace: (?untyped colorizer) -> untyped

      # @return [String] The failure information fully formatted in the way that
      #   RSpec's built-in formatters emit.
      def fully_formatted: (untyped failure_number, ?untyped colorizer) -> untyped

      # @return [Array<string>] The failure information fully formatted in the way that
      #   RSpec's built-in formatters emit, split by line.
      def fully_formatted_lines: (untyped failure_number, ?untyped colorizer) -> untyped

      private

      def initialize: (untyped example, ?untyped exception_presenter) -> void
    end

    # @deprecated Use {FailedExampleNotification} instead.
    class PendingExampleFixedNotification < FailedExampleNotification
    end

    # @deprecated Use {FailedExampleNotification} instead.
    class PendingExampleFailedAsExpectedNotification < FailedExampleNotification
    end

    # The `SkippedExampleNotification` extends `ExampleNotification` with
    # things useful for specs that are skipped.
    #
    # @attr [RSpec::Core::Example] example the current example
    # @see ExampleNotification
    class SkippedExampleNotification < ExampleNotification
      # @return [String] The pending detail fully formatted in the way that
      #   RSpec's built-in formatters emit.
      def fully_formatted: (untyped pending_number, ?untyped colorizer) -> untyped
    end

    # The `GroupNotification` represents notifications sent by the reporter
    # which contain information about the currently running (or soon to be)
    # example group. It is used by formatters to access information about that
    # group.
    #
    # @example
    #   def example_group_started(notification)
    #     puts "Hey I started #{notification.group.description}"
    #   end
    # @attr group [RSpec::Core::ExampleGroup] the current group
    GroupNotification: untyped

    # The `MessageNotification` encapsulates generic messages that the reporter
    # sends to formatters.
    #
    # @attr message [String] the message
    MessageNotification: untyped

    # The `SeedNotification` holds the seed used to randomize examples and
    # whether that seed has been used or not.
    #
    # @attr seed [Fixnum] the seed used to randomize ordering
    # @attr used [Boolean] whether the seed has been used or not
    # SeedNotification: untyped

    class SeedNotification
      # @api
      # @return [Boolean] has the seed been used?
      def seed_used?: () -> untyped

      # @return [String] The seed information fully formatted in the way that
      #   RSpec's built-in formatters emit.
      def fully_formatted: () -> ::String
    end

    # The `SummaryNotification` holds information about the results of running
    # a test suite. It is used by formatters to provide information at the end
    # of the test run.
    #
    # @attr duration [Float] the time taken (in seconds) to run the suite
    # @attr examples [Array<RSpec::Core::Example>] the examples run
    # @attr failed_examples [Array<RSpec::Core::Example>] the failed examples
    # @attr pending_examples [Array<RSpec::Core::Example>] the pending examples
    # @attr load_time [Float] the number of seconds taken to boot RSpec
    #                         and load the spec files
    # @attr errors_outside_of_examples_count [Integer] the number of errors that
    #                                                  have occurred processing
    #                                                  the spec suite
    # SummaryNotification: untyped

    class SummaryNotification
      # @api
      # @return [Fixnum] the number of examples run
      def example_count: () -> untyped

      # @api
      # @return [Fixnum] the number of failed examples
      def failure_count: () -> untyped

      # @api
      # @return [Fixnum] the number of pending examples
      def pending_count: () -> untyped

      # @api
      # @return [String] A line summarising the result totals of the spec run.
      def totals_line: () -> untyped

      # @api public
      #
      # Wraps the results line with colors based on the configured
      # colors for failure, pending, and success. Defaults to red,
      # yellow, green accordingly.
      #
      # @param colorizer [#wrap] An object which supports wrapping text with
      #                          specific colors.
      # @return [String] A colorized results line.
      def colorized_totals_line: (?untyped colorizer) -> untyped

      # @api public
      #
      # Formats failures into a rerunable command format.
      #
      # @param colorizer [#wrap] An object which supports wrapping text with
      #                          specific colors.
      # @return [String] A colorized summary line.
      def colorized_rerun_commands: (?untyped colorizer) -> untyped

      # @return [String] a formatted version of the time it took to run the
      #   suite
      def formatted_duration: () -> untyped

      # @return [String] a formatted version of the time it took to boot RSpec
      #   and load the spec files
      def formatted_load_time: () -> untyped

      # @return [String] The summary information fully formatted in the way that
      #   RSpec's built-in formatters emit.
      def fully_formatted: (?untyped colorizer) -> untyped

      private

      include RSpec::Core::ShellEscape

      def rerun_argument_for: (untyped example) -> untyped

      def duplicate_rerun_locations: () -> untyped
    end

    # The `ProfileNotification` holds information about the results of running a
    # test suite when profiling is enabled. It is used by formatters to provide
    # information at the end of the test run for profiling information.
    #
    # @attr duration [Float] the time taken (in seconds) to run the suite
    # @attr examples [Array<RSpec::Core::Example>] the examples run
    # @attr number_of_examples [Fixnum] the number of examples to profile
    # @attr example_groups [Array<RSpec::Core::Profiler>] example groups run
    class ProfileNotification
      def initialize: (untyped duration, untyped examples, untyped number_of_examples, untyped example_groups) -> void

      attr_reader duration: untyped

      attr_reader examples: untyped

      attr_reader number_of_examples: untyped

      # @return [Array<RSpec::Core::Example>] the slowest examples
      def slowest_examples: () -> untyped

      # @return [Float] the time taken (in seconds) to run the slowest examples
      def slow_duration: () -> untyped

      # @return [String] the percentage of total time taken
      def percentage: () -> untyped

      # @return [Array<RSpec::Core::Example>] the slowest example groups
      def slowest_groups: () -> untyped

      private

      def calculate_slowest_groups: () -> (::Hash[untyped, untyped] | untyped)
    end

    # The `DeprecationNotification` is issued by the reporter when a deprecated
    # part of RSpec is encountered. It represents information about the
    # deprecated call site.
    #
    # @attr message [String] A custom message about the deprecation
    # @attr deprecated [String] A custom message about the deprecation (alias of
    #   message)
    # @attr replacement [String] An optional replacement for the deprecation
    # @attr call_site [String] An optional call site from which the deprecation
    #   was issued
    # DeprecationNotification: untyped

    class DeprecationNotification
      # @api
      # Convenience way to initialize the notification
      def self.from_hash: (untyped data) -> untyped
    end

    # `NullNotification` represents a placeholder value for notifications that
    # currently require no information, but we may wish to extend in future.
    class NullNotification
    end

    # `CustomNotification` is used when sending custom events to formatters /
    # other registered listeners, it creates attributes based on supplied hash
    # of options.
    class CustomNotification < Struct[untyped]
      # @param options [Hash] A hash of method / value pairs to create on this notification
      # @return [CustomNotification]
      #
      # Build a custom notification based on the supplied option key / values.
      def self.for: (?::Hash[untyped, untyped] options) -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    # Deals with the fact that `shellwords` only works on POSIX systems.
    module ShellEscape
      def self?.quote: (untyped argument) -> ::String

      # :nocov:
      # alias escape quote

      def self?.escape: (untyped shell_command) -> untyped

      # Known shells that require quoting: zsh, csh, tcsh.
      #
      # Feel free to add other shells to this list that are known to
      # allow `rspec ./some_spec.rb[1:1]` syntax without quoting the id.
      #
      # @private
      SHELLS_ALLOWING_UNQUOTED_IDS: ::Array["bash" | "ksh" | "fish"]

      def self?.conditionally_quote: (untyped id) -> untyped

      def self?.shell_allows_unquoted_ids?: () -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    # Wrapper around Ruby's `DidYouMean::SpellChecker` when available to provide file name suggestions.
    class DidYouMean
      attr_reader relative_file_name: untyped

      def initialize: (untyped relative_file_name) -> void

      # provide probable suggestions
      # def call: () -> (::String | untyped)

      # return a hint if API for ::DidYouMean::SpellChecker not supported
      def call: () -> ::String

      private

      def formats: (untyped probables) -> untyped

      def top_and_tail: (untyped rspec_format) -> untyped

      def red_font: (untyped mytext) -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    module Ordering
      # @private
      # The default global ordering (defined order).
      class Identity
        def order: (untyped items) -> untyped
      end

      # @private
      # Orders items randomly.
      class Random
        def initialize: (untyped configuration) -> void

        def used?: () -> untyped

        def order: (untyped items) -> untyped

        private

        # http://en.wikipedia.org/wiki/Jenkins_hash_function
        # Jenkins provides a good distribution and is simpler than MD5.
        # It's a bit slower than MD5 (primarily because `Digest::MD5` is
        # implemented in C) but has the advantage of not requiring us
        # to load another part of stdlib, which we try to minimize.
        def jenkins_hash_digest: (untyped string) -> untyped

        MAX_32_BIT: 4294967295
      end

      # @private
      # Orders items by modification time (most recent modified first).
      class RecentlyModified
        def order: (untyped list) -> untyped
      end

      # @private
      # Orders items based on a custom block.
      class Custom
        def initialize: (untyped callable) -> void

        def order: (untyped list) -> untyped
      end

      # @private
      # Stores the different ordering strategies.
      class Registry
        def initialize: (untyped configuration) -> void

        def fetch: (untyped name) { () -> untyped } -> untyped

        def register: (untyped sym, untyped strategy) -> untyped

        def used_random_seed?: () -> untyped
      end

      # @private
      # Manages ordering configuration.
      #
      # @note This is not intended to be used externally. Use
      #       the APIs provided by `RSpec::Core::Configuration` instead.
      class ConfigurationManager
        attr_reader seed: untyped

        attr_reader ordering_registry: untyped

        def initialize: () -> void

        def seed_used?: () -> untyped

        def seed=: (untyped seed) -> (nil | untyped)

        def order=: (untyped `type`) -> untyped

        def force: (untyped hash) -> untyped

        def register_ordering: (untyped name, ?untyped strategy) -> (nil | untyped)
      end
    end
  end
end

module RSpec
  module Core
    # A sandbox isolates the enclosed code into an environment that looks 'new'
    # meaning globally accessed objects are reset for the duration of the
    # sandbox.
    #
    # @note This module is not normally available. You must require
    #   `rspec/core/sandbox` to load it.
    module Sandbox
      # Execute a provided block with RSpec global objects (configuration,
      # world) reset.  This is used to test RSpec with RSpec.
      #
      # When calling this the configuration is passed into the provided block.
      # Use this to set custom configs for your sandboxed examples.
      #
      # ```
      # Sandbox.sandboxed do |config|
      #   config.before(:context) { RSpec.current_example = nil }
      # end
      # ```
      def self.sandboxed: () { (untyped) -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class HtmlFormatter < BaseFormatter
        def initialize: (untyped output) -> void

        def start: (untyped notification) -> untyped

        def example_group_started: (untyped notification) -> untyped

        def start_dump: (untyped _notification) -> untyped

        def example_started: (untyped _notification) -> untyped

        def example_passed: (untyped passed) -> untyped

        def example_failed: (untyped failure) -> untyped

        def example_pending: (untyped pending) -> untyped

        def dump_summary: (untyped summary) -> untyped

        private

        # The number of the currently running example_group.
        def example_group_number: () -> untyped

        # The number of the currently running example (a global counter).
        def example_number: () -> untyped

        def percent_done: () -> untyped

        # Override this method if you wish to output extra HTML for a failed
        # spec. For example, you could output links to images or other files
        # produced during the specs.
        def extra_failure_content: (untyped failure) -> ::String
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # Formatters helpers.
      module Helpers
        # @private
        SUB_SECOND_PRECISION: 5

        # @private
        DEFAULT_PRECISION: 2

        # @api private
        #
        # Formats seconds into a human-readable string.
        #
        # @param duration [Float, Fixnum] in seconds
        # @return [String] human-readable time
        #
        # @example
        #    format_duration(1) #=>  "1 minute 1 second"
        #    format_duration(135.14) #=> "2 minutes 15.14 seconds"
        def self.format_duration: (untyped duration) -> untyped

        # @api private
        #
        # Formats seconds to have 5 digits of precision with trailing zeros
        # removed if the number is less than 1 or with 2 digits of precision if
        # the number is greater than zero.
        #
        # @param float [Float]
        # @return [String] formatted float
        #
        # @example
        #    format_seconds(0.000006) #=> "0.00001"
        #    format_seconds(0.020000) #=> "0.02"
        #    format_seconds(1.00000000001) #=> "1"
        #
        # The precision used is set in {Helpers::SUB_SECOND_PRECISION} and
        # {Helpers::DEFAULT_PRECISION}.
        #
        # @see #strip_trailing_zeroes
        def self.format_seconds: (untyped float, ?untyped? precision) -> ("0" | untyped)

        # @api private
        #
        # Remove trailing zeros from a string.
        #
        # Only remove trailing zeros after a decimal place.
        # see: http://rubular.com/r/ojtTydOgpn
        #
        # @param string [String] string with trailing zeros
        # @return [String] string with trailing zeros removed
        def self.strip_trailing_zeroes: (untyped string) -> untyped

        # @api private
        #
        # Pluralize a word based on a count.
        #
        # @param count [Fixnum] number of objects
        # @param string [String] word to be pluralized
        # @return [String] pluralized word
        def self.pluralize: (untyped count, untyped string) -> ::String

        # @api private
        # Given a list of example ids, organizes them into a compact, ordered list.
        def self.organize_ids: (untyped ids) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # Contains common logic for formatters used by `--bisect` to communicate results
      # back to the bisect runner.
      #
      # Subclasses must define a `notify_results(all_example_ids, failed_example_ids)`
      # method.
      # @private
      class BaseBisectFormatter
        def self.inherited: (untyped formatter) -> untyped

        def initialize: (untyped expected_failures) -> void

        def example_failed: (untyped notification) -> untyped

        def example_finished: (untyped notification) -> (nil | untyped)

        def start_dump: (untyped _notification) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @api private
      # Formatter for providing profile output.
      class ProfileFormatter
        def initialize: (untyped output) -> void

        # @private
        attr_reader output: untyped

        # @api public
        #
        # This method is invoked after the dumping the summary if profiling is
        # enabled.
        #
        # @param profile [ProfileNotification] containing duration,
        #   slowest_examples and slowest_example_groups
        def dump_profile: (untyped profile) -> untyped

        private

        def dump_profile_slowest_examples: (untyped profile) -> untyped

        def dump_profile_slowest_example_groups: (untyped profile) -> (nil | untyped)

        def format_caller: (untyped caller_info) -> untyped

        def bold: (untyped text) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # RSpec's built-in formatters are all subclasses of
      # RSpec::Core::Formatters::BaseFormatter.
      #
      # @see RSpec::Core::Formatters::BaseTextFormatter
      # @see RSpec::Core::Reporter
      # @see RSpec::Core::Formatters::Protocol
      class BaseFormatter
        attr_accessor example_group: untyped

        attr_reader output: untyped

        # @api public
        # @param output [IO] the formatter output
        # @see RSpec::Core::Formatters::Protocol#initialize
        def initialize: (untyped output) -> void

        # @api public
        #
        # @param notification [StartNotification]
        # @see RSpec::Core::Formatters::Protocol#start
        def start: (untyped notification) -> untyped

        # @api public
        #
        # @param notification [GroupNotification] containing example_group
        #   subclass of `RSpec::Core::ExampleGroup`
        # @see RSpec::Core::Formatters::Protocol#example_group_started
        def example_group_started: (untyped notification) -> untyped

        # @api public
        #
        # @param _notification [NullNotification] (Ignored)
        # @see RSpec::Core::Formatters::Protocol#close
        def close: (untyped _notification) -> untyped

        private

        def start_sync_output: () -> untyped

        def restore_sync_output: () -> untyped

        def output_supports_sync: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # Base for all of RSpec's built-in formatters. See
      # RSpec::Core::Formatters::BaseFormatter to learn more about all of the
      # methods called by the reporter.
      #
      # @see RSpec::Core::Formatters::BaseFormatter
      # @see RSpec::Core::Reporter
      class BaseTextFormatter < BaseFormatter
        # @api public
        #
        # Used by the reporter to send messages to the output stream.
        #
        # @param notification [MessageNotification] containing message
        def message: (untyped notification) -> untyped

        # @api public
        #
        # Dumps detailed information about each example failure.
        #
        # @param notification [NullNotification]
        def dump_failures: (untyped notification) -> (nil | untyped)

        # @api public
        #
        # This method is invoked after the dumping of examples and failures.
        # Each parameter is assigned to a corresponding attribute.
        #
        # @param summary [SummaryNotification] containing duration,
        #   example_count, failure_count and pending_count
        def dump_summary: (untyped summary) -> untyped

        # @private
        def dump_pending: (untyped notification) -> (nil | untyped)

        # @private
        def seed: (untyped notification) -> (nil | untyped)

        # @api public
        #
        # Invoked at the end of a suite run. Allows the formatter to do any
        # tidying up, but be aware that formatter output streams may be used
        # elsewhere so don't actually close them.
        #
        # @param _notification [NullNotification] (Ignored)
        def close: (untyped _notification) -> (nil | untyped)
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @api private
      # Formatter for providing message output as a fallback when no other
      # profiler implements #message
      class FallbackMessageFormatter
        def initialize: (untyped output) -> void

        # @private
        attr_reader output: untyped

        # @api public
        #
        # Used by the reporter to send messages to the output stream.
        #
        # @param notification [MessageNotification] containing message
        def message: (untyped notification) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # ConsoleCodes provides helpers for formatting console output
      # with ANSI codes, e.g. color's and bold.
      module ConsoleCodes
        # @private
        VT100_CODES: { black: 30, red: 31, green: 32, yellow: 33, blue: 34, magenta: 35, cyan: 36, white: 37, bold_black: "1;30", bold_red: "1;31", bold_green: "1;32", bold_yellow: "1;33", bold_blue: "1;34", bold_magenta: "1;35", bold_cyan: "1;36", bold_white: "1;37", bold: 1 }

        # @private
        VT100_CODE_VALUES: untyped

        # @private
        def self?.config_colors_to_methods: () -> untyped

        # Fetches the correct code for the supplied symbol, or checks
        # that a code is valid. Defaults to white (37).
        #
        # @param code_or_symbol [Symbol, Fixnum] Symbol or code to check
        # @return [Fixnum] a console code
        def self?.console_code_for: (untyped code_or_symbol) -> untyped

        # Wraps a piece of text in ANSI codes with the supplied code. Will
        # only apply the control code if `RSpec.configuration.color_enabled?`
        # returns true.
        #
        # @param text [String] the text to wrap
        # @param code_or_symbol [Symbol, Fixnum] the desired control code
        # @return [String] the wrapped text
        def self?.wrap: (untyped text, untyped code_or_symbol) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class ProgressFormatter < BaseTextFormatter
        def example_passed: (untyped _notification) -> untyped

        def example_pending: (untyped _notification) -> untyped

        def example_failed: (untyped _notification) -> untyped

        def start_dump: (untyped _notification) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # Used by `--bisect`. When it shells out and runs a portion of the suite, it uses
      # this formatter as a means to have the status reported back to it, via DRb.
      #
      # Note that since DRb calls carry considerable overhead compared to normal
      # method calls, we try to minimize the number of DRb calls for perf reasons,
      # opting to communicate only at the start and the end of the run, rather than
      # after each example.
      # @private
      class BisectDRbFormatter < BaseBisectFormatter
        def initialize: (untyped _output) -> void

        def notify_results: (untyped results) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      # Provides terminal syntax highlighting of code snippets
      # when coderay is available.
      class SyntaxHighlighter
        def initialize: (untyped configuration) -> void

        def highlight: (untyped lines) -> untyped

        # rubocop:disable Lint/RescueException
        # rubocop:disable Lint/HandleExceptions
        def self.attempt_to_add_rspec_terms_to_coderay_keywords: () -> untyped

        private

        # :nocov:
        def implementation: () -> untyped

        def color_enabled_implementation: () -> untyped

        # @private
        module CodeRayImplementation
          RESET_CODE: ::String

          def self.highlight_syntax: (untyped lines) -> untyped
        end

        # @private
        module NoSyntaxHighlightingImplementation
          def self.highlight_syntax: (untyped lines) -> untyped
        end

        # @private
        # Not sure why, but our code above (and/or coderay itself) does not work
        # on Windows, so we disable the feature on Windows.
        WindowsImplementation: untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class DocumentationFormatter < BaseTextFormatter
        def initialize: (untyped output) -> void

        def example_started: (untyped _notification) -> untyped

        def example_group_started: (untyped notification) -> untyped

        def example_group_finished: (untyped _notification) -> untyped

        def example_passed: (untyped passed) -> untyped

        def example_pending: (untyped pending) -> untyped

        def example_failed: (untyped failure) -> untyped

        def message: (untyped notification) -> untyped

        private

        def flush_messages: () -> untyped

        def passed_output: (untyped example) -> untyped

        def pending_output: (untyped example, untyped message) -> untyped

        def failure_output: (untyped example) -> untyped

        def next_failure_index: () -> untyped

        def current_indentation: (?::Integer offset) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class SnippetExtractor
        NoSuchFileError: untyped

        NoSuchLineError: untyped

        def self.extract_line_at: (untyped file_path, untyped line_number) -> untyped

        def self.source_from_file: (untyped path) -> untyped

        NoExpressionAtLineError: untyped

        attr_reader source: untyped

        attr_reader beginning_line_number: untyped

        attr_reader max_line_count: untyped

        # def self.extract_expression_lines_at: (untyped file_path, untyped beginning_line_number, ?untyped? max_line_count) -> untyped

        def initialize: (untyped source, untyped beginning_line_number, ?untyped? max_line_count) -> void

        def expression_lines: () -> untyped

        private

        def line_range_of_expression: () -> untyped

        def unclosed_tokens_in_line_range: (untyped line_range) -> untyped

        def line_range_of_location_nodes_in_expression: () -> ::Range[untyped]

        def expression_node: () -> untyped

        def expression_outmost_node?: (untyped node) -> (true | false | untyped)

        def location_nodes_at_beginning_line: () -> untyped

        # :nocov:
        def self.extract_expression_lines_at: (untyped file_path, untyped beginning_line_number) -> ::Array[untyped]

        def self.least_indentation_from: (untyped lines) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      # Produces progress output while bisecting.
      class BisectProgressFormatter < BaseTextFormatter
        def initialize: (untyped output, untyped bisect_runner) -> void

        def bisect_starting: (untyped notification) -> untyped

        def bisect_original_run_complete: (untyped notification) -> untyped

        def bisect_dependency_check_started: (untyped _notification) -> untyped

        def bisect_dependency_check_passed: (untyped _notification) -> untyped

        def bisect_dependency_check_failed: (untyped _notification) -> untyped

        def bisect_round_started: (untyped notification, ?bool include_trailing_space) -> untyped

        def bisect_round_ignoring_ids: (untyped notification) -> untyped

        def bisect_round_detected_multiple_culprits: (untyped notification) -> untyped

        def bisect_individual_run_complete: (untyped _) -> untyped

        def bisect_complete: (untyped notification) -> untyped

        def bisect_repro_command: (untyped notification) -> untyped

        def bisect_failed: (untyped notification) -> untyped

        def bisect_aborted: (untyped notification) -> untyped

        private

        def bisect_started_message: (untyped notification) -> ::String
      end

      # @private
      # Produces detailed debug output while bisecting. Used when bisect is
      # performed with `--bisect=verbose`. Designed to provide details for
      # us when we need to troubleshoot bisect bugs.
      class BisectDebugFormatter < BisectProgressFormatter
        def bisect_original_run_complete: (untyped notification) -> untyped

        def bisect_individual_run_start: (untyped notification) -> untyped

        def bisect_individual_run_complete: (untyped notification) -> untyped

        def bisect_dependency_check_passed: (untyped _notification) -> untyped

        def bisect_dependency_check_failed: (untyped _notification) -> untyped

        def bisect_round_started: (untyped notification) -> untyped

        def bisect_round_ignoring_ids: (untyped notification) -> untyped

        def bisect_round_detected_multiple_culprits: (untyped _notification) -> untyped

        private

        def describe_ids: (untyped description, untyped ids) -> ::String

        def bisect_started_message: (untyped notification) -> ::String
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class DeprecationFormatter
        attr_reader count: untyped

        attr_reader deprecation_stream: untyped

        attr_reader summary_stream: untyped

        def initialize: (untyped deprecation_stream, untyped summary_stream) -> void

        alias output deprecation_stream

        def printer: () -> untyped

        def deprecation: (untyped notification) -> (nil | untyped)

        def deprecation_summary: (untyped _notification) -> untyped

        def deprecation_message_for: (untyped data) -> untyped

        RAISE_ERROR_CONFIG_NOTICE: untyped

        DEPRECATION_STREAM_NOTICE: "Pass `--deprecation-out` or set `config.deprecation_stream` to a file for full output."

        TOO_MANY_WARNINGS_NOTICE: ::String

        # @private
        SpecifiedDeprecationMessage: untyped

        # @private
        GeneratedDeprecationMessage: untyped

        # @private
        class ImmediatePrinter
          attr_reader deprecation_stream: untyped

          attr_reader summary_stream: untyped

          attr_reader deprecation_formatter: untyped

          def initialize: (untyped deprecation_stream, untyped summary_stream, untyped deprecation_formatter) -> void

          def print_deprecation_message: (untyped data) -> untyped

          def deprecation_summary: () -> (nil | untyped)
        end

        # @private
        class DelayedPrinter
          TOO_MANY_USES_LIMIT: 4

          attr_reader deprecation_stream: untyped

          attr_reader summary_stream: untyped

          attr_reader deprecation_formatter: untyped

          def initialize: (untyped deprecation_stream, untyped summary_stream, untyped deprecation_formatter) -> void

          def print_deprecation_message: (untyped data) -> untyped

          def stash_deprecation_message: (untyped deprecation_message) -> untyped

          def deprecation_summary: () -> (nil | untyped)

          def print_deferred_deprecation_warnings: () -> untyped
        end

        # @private
        # Not really a stream, but is usable in place of one.
        class RaiseErrorStream
          def puts: (untyped message) -> untyped

          def summarize: (untyped summary_stream, untyped deprecation_count) -> untyped
        end

        # @private
        # Wraps a File object and provides file-specific operations.
        class FileStream
          def initialize: (untyped file) -> void

          def puts: (*untyped args) -> untyped

          def summarize: (untyped summary_stream, untyped deprecation_count) -> untyped
        end
      end
    end

    # Deprecation Error.
    DeprecationError: untyped
  end
end

module RSpec
  module Core
    module Formatters
      # This class isn't loaded at runtime but serves to document all of the
      # notifications implemented as part of the standard interface. The
      # reporter will issue these during a normal test suite run, but a
      # formatter will only receive those notifications it has registered
      # itself to receive. To register a formatter call:
      #
      # `::RSpec::Core::Formatters.register class, :list, :of, :notifications`
      #
      # e.g.
      #
      # `::RSpec::Core::Formatters.register self, :start, :example_started`
      #
      # @see RSpec::Core::Formatters::BaseFormatter
      # @see RSpec::Core::Formatters::BaseTextFormatter
      # @see RSpec::Core::Reporter
      class Protocol
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class HtmlPrinter
        include ERB::Util

        # For the #h method.
        def initialize: (untyped output) -> void

        def print_html_start: () -> untyped

        def print_example_group_end: () -> untyped

        def print_example_group_start: (untyped group_id, untyped description, untyped number_of_parents) -> untyped

        def print_example_passed: (untyped description, untyped run_time) -> untyped

        def print_example_failed: (untyped pending_fixed, untyped description, untyped run_time, untyped failure_id, untyped exception, untyped extra_content) -> untyped

        def print_example_pending: (untyped description, untyped pending_message) -> untyped

        def print_summary: (untyped duration, untyped example_count, untyped failure_count, untyped pending_count) -> untyped

        def flush: () -> untyped

        def move_progress: (untyped percent_done) -> untyped

        def make_header_red: () -> untyped

        def make_header_yellow: () -> untyped

        def make_example_group_header_red: (untyped group_id) -> untyped

        def make_example_group_header_yellow: (untyped group_id) -> untyped

        private

        def indentation_style: (untyped number_of_parents) -> ::String

        REPORT_HEADER: ::String

        GLOBAL_SCRIPTS: ::String

        GLOBAL_STYLES: ::String

        HTML_HEADER: ::String
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class FailureListFormatter < BaseFormatter
        def example_failed: (untyped failure) -> untyped

        # Discard profile and messages
        #
        # These outputs are not really relevant in the context of this failure
        # list formatter.
        def dump_profile: (untyped _profile) -> nil

        def message: (untyped _message) -> nil
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class ExceptionPresenter
        attr_reader exception: untyped

        attr_reader example: untyped

        attr_reader description: untyped

        private

        attr_reader message_color: untyped

        attr_reader detail_formatter: untyped

        attr_reader extra_detail_formatter: untyped

        attr_reader backtrace_formatter: untyped

        public

        def initialize: (untyped exception, untyped example, ?::Hash[untyped, untyped] options) -> void

        def message_lines: () -> untyped

        def colorized_message_lines: (?untyped colorizer) -> untyped

        def formatted_backtrace: (?untyped exception) -> untyped

        # def formatted_cause: (untyped exception) -> untyped

        # :nocov:
        def formatted_cause: (untyped _) -> ::Array[untyped]

        def colorized_formatted_backtrace: (?untyped colorizer) -> untyped

        def fully_formatted: (untyped failure_number, ?untyped colorizer) -> untyped

        def fully_formatted_lines: (untyped failure_number, untyped colorizer) -> untyped

        private

        def final_exception: (untyped exception, ?untyped previous) -> untyped

        # def encoding_of: (untyped string) -> untyped

        def encoded_string: (untyped string) -> untyped

        # for 1.8.7
        # :nocov:
        def encoding_of: (untyped _string) -> nil

        def indent_lines: (untyped lines, untyped failure_number) -> untyped

        def exception_class_name: (?untyped exception) -> untyped

        def failure_lines: () -> untyped

        def failure_slash_error_lines: () -> untyped

        # rubocop:disable Lint/RescueException
        def exception_message_string: (untyped exception) -> untyped

        def exception_lines: () -> untyped

        def extra_failure_lines: () -> untyped

        def add_shared_group_lines: (untyped lines, untyped colorizer) -> untyped

        def read_failed_lines: () -> untyped

        def find_failed_line: () -> untyped

        def formatted_message_and_backtrace: (untyped colorizer) -> untyped

        # def encoded_description: (untyped description) -> (nil | untyped)

        # for 1.8.7
        def encoded_description: (untyped description) -> untyped

        def exception_backtrace: () -> untyped

        # @private
        # Configuring the `ExceptionPresenter` with the right set of options to handle
        # pending vs failed vs skipped and aggregated (or not) failures is not simple.
        # This class takes care of building an appropriate `ExceptionPresenter` for the
        # provided example.
        class Factory
          def build: () -> untyped

          private

          def initialize: (untyped example) -> void

          def options: () -> untyped

          def pending_options: () -> untyped

          def with_multiple_error_options_as_needed: (untyped exception, untyped options) -> untyped

          def multiple_exceptions_error?: (untyped exception) -> untyped

          def multiple_exception_summarizer: (untyped exception, untyped prior_detail_formatter, untyped color) -> untyped

          def sub_failure_list_formatter: (untyped exception, untyped message_color) -> untyped

          # @private
          # Used to prevent a confusing backtrace from showing up from the `aggregate_failures`
          # block declared for `:aggregate_failures` metadata.
          module EmptyBacktraceFormatter
            def self.format_backtrace: () -> ::Array[untyped]
          end

          # @private
          class CommonBacktraceTruncater
            def initialize: (untyped parent) -> void

            def with_truncated_backtrace: (untyped child) -> untyped
          end
        end

        # @private
        PENDING_DETAIL_FORMATTER: untyped
      end
    end

    # Provides a single exception instance that provides access to
    # multiple sub-exceptions. This is used in situations where a single
    # individual spec has multiple exceptions, such as one in the `it` block
    # and one in an `after` block.
    class MultipleExceptionError < StandardError
      # @private
      # Used so there is a common module in the ancestor chain of this class
      # and `RSpec::Expectations::MultipleExpectationsNotMetError`, which allows
      # code to detect exceptions that are instances of either, without first
      # checking to see if rspec-expectations is loaded.
      module InterfaceTag
        # Appends the provided exception to the list.
        # @param exception [Exception] Exception to append to the list.
        # @private
        def add: (untyped exception) -> (nil | untyped)

        # Provides a way to force `ex` to be something that satisfies the multiple
        # exception error interface. If it already satisfies it, it will be returned;
        # otherwise it will wrap it in a `MultipleExceptionError`.
        # @private
        def self.for: (untyped ex) -> untyped
      end

      include InterfaceTag

      # @return [Array<Exception>] The list of failures.
      attr_reader failures: untyped

      # @return [Array<Exception>] The list of other errors.
      attr_reader other_errors: untyped

      # @return [Array<Exception>] The list of failures and other exceptions, combined.
      attr_reader all_exceptions: untyped

      # @return [Hash] Metadata used by RSpec for formatting purposes.
      attr_reader aggregation_metadata: untyped

      # @return [nil] Provided only for interface compatibility with
      #   `RSpec::Expectations::MultipleExpectationsNotMetError`.
      attr_reader aggregation_block_label: untyped

      # @param exceptions [Array<Exception>] The initial list of exceptions.
      def initialize: (*untyped exceptions) -> void

      # @return [String] Combines all the exception messages into a single string.
      # @note RSpec does not actually use this -- instead it formats each exception
      #   individually.
      def message: () -> untyped

      # @return [String] A summary of the failure, including the block label and a count of failures.
      def summary: () -> ::String

      # return [String] A description of the failure/error counts.
      def exception_count_description: () -> (untyped | ::String)
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @private
      class JsonFormatter < BaseFormatter
        attr_reader output_hash: untyped

        def initialize: (untyped output) -> void

        def message: (untyped notification) -> untyped

        def dump_summary: (untyped summary) -> untyped

        def stop: (untyped notification) -> untyped

        def seed: (untyped notification) -> (nil | untyped)

        def close: (untyped _notification) -> untyped

        def dump_profile: (untyped profile) -> untyped

        # @api private
        def dump_profile_slowest_examples: (untyped profile) -> untyped

        # @api private
        def dump_profile_slowest_example_groups: (untyped profile) -> untyped

        private

        def format_example: (untyped example) -> { id: untyped, description: untyped, full_description: untyped, status: untyped, file_path: untyped, line_number: untyped, run_time: untyped, pending_message: untyped }
      end
    end
  end
end

module RSpec
  module Core
    module Formatters
      # @api private
      #
      # Extracts code snippets by looking at the backtrace of the passed error
      # and applies synax highlighting and line numbers using html.
      class HtmlSnippetExtractor
        # @private
        module NullConverter
          def self.convert: (untyped code) -> ::String
        end

        # @private
        module CoderayConverter
          def self.convert: (untyped code) -> untyped
        end

        # @api private
        #
        # Extract lines of code corresponding to  a backtrace.
        #
        # @param backtrace [String] the backtrace from a test failure
        # @return [String] highlighted code snippet indicating where the test
        #   failure occured
        #
        # @see #post_process
        def snippet: (untyped backtrace) -> untyped

        # @api private
        #
        # Create a snippet from a line of code.
        #
        # @param error_line [String] file name with line number (i.e.
        #   'foo_spec.rb:12')
        # @return [String] lines around the target line within the file
        #
        # @see #lines_around
        def snippet_for: (untyped error_line) -> untyped

        # @api private
        #
        # Extract lines of code centered around a particular line within a
        # source file.
        #
        # @param file [String] filename
        # @param line [Fixnum] line number
        # @return [String] lines around the target line within the file (2 above
        #   and 1 below).
        def lines_around: (untyped file, untyped line) -> untyped

        # @api private
        #
        # Adds line numbers to all lines and highlights the line where the
        # failure occurred using html `span` tags.
        #
        # @param highlighted [String] syntax-highlighted snippet surrounding the
        #   offending line of code
        # @param offending_line [Fixnum] line where failure occured
        # @return [String] completed snippet
        def post_process: (untyped highlighted, untyped offending_line) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    # @private
    module FlatMap
      def self?.flat_map: (untyped array) { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    # Wrapper for an instance of a subclass of {ExampleGroup}. An instance of
    # `RSpec::Core::Example` is returned by example definition methods
    # such as {ExampleGroup.it it} and is yielded to the {ExampleGroup.it it},
    # {Hooks#before before}, {Hooks#after after}, {Hooks#around around},
    # {MemoizedHelpers::ClassMethods#let let} and
    # {MemoizedHelpers::ClassMethods#subject subject} blocks.
    #
    # This allows us to provide rich metadata about each individual
    # example without adding tons of methods directly to the ExampleGroup
    # that users may inadvertently redefine.
    #
    # Useful for configuring logging and/or taking some action based
    # on the state of an example's metadata.
    #
    # @example
    #
    #     RSpec.configure do |config|
    #       config.before do |example|
    #         log example.description
    #       end
    #
    #       config.after do |example|
    #         log example.description
    #       end
    #
    #       config.around do |example|
    #         log example.description
    #         example.run
    #       end
    #     end
    #
    #     shared_examples "auditable" do
    #       it "does something" do
    #         log "#{example.full_description}: #{auditable.inspect}"
    #         auditable.should do_something
    #       end
    #     end
    #
    # @see ExampleGroup
    # @note Example blocks are evaluated in the context of an instance
    #   of an `ExampleGroup`, not in the context of an instance of `Example`.
    class Example
      # @private
      #
      # Used to define methods that delegate to this example's metadata.
      def self.delegate_to_metadata: (untyped key) -> untyped

      # Returns the string submitted to `example` or its aliases (e.g.
      # `specify`, `it`, etc). If no string is submitted (e.g.
      # `it { is_expected.to do_something }`) it returns the message generated
      # by the matcher if there is one, otherwise returns a message including
      # the location of the example.
      def description: () -> untyped

      # Returns a description of the example that always includes the location.
      def inspect_output: () -> untyped

      # Returns the location-based argument that can be passed to the `rspec` command to rerun this example.
      def location_rerun_argument: () -> untyped

      # Returns the location-based argument that can be passed to the `rspec` command to rerun this example.
      #
      # @deprecated Use {#location_rerun_argument} instead.
      # @note If there are multiple examples identified by this location, they will use {#id}
      #   to rerun instead, but this method will still return the location (that's why it is deprecated!).
      def rerun_argument: () -> untyped

      # @return [String] the unique id of this example. Pass
      #   this at the command line to re-run this exact example.
      def id: () -> untyped

      # @private
      def self.parse_id: (untyped id) -> untyped

      # Duplicates the example and overrides metadata with the provided
      # hash.
      #
      # @param metadata_overrides [Hash] the hash to override the example metadata
      # @return [Example] a duplicate of the example with modified metadata
      def duplicate_with: (?::Hash[untyped, untyped] metadata_overrides) -> untyped

      # @private
      def update_inherited_metadata: (untyped updates) -> untyped

      # @attr_reader
      #
      # Returns the first exception raised in the context of running this
      # example (nil if no exception is raised).
      attr_reader exception: untyped

      # @attr_reader
      #
      # Returns the metadata object associated with this example.
      attr_reader metadata: untyped

      # @attr_reader
      # @private
      #
      # Returns the example_group_instance that provides the context for
      # running this example.
      attr_reader example_group_instance: untyped

      # @attr
      # @private
      attr_accessor clock: untyped

      # Creates a new instance of Example.
      # @param example_group_class [Class] the subclass of ExampleGroup in which
      #   this Example is declared
      # @param description [String] the String passed to the `it` method (or
      #   alias)
      # @param user_metadata [Hash] additional args passed to `it` to be used as
      #   metadata
      # @param example_block [Proc] the block of code that represents the
      #   example
      # @api private
      def initialize: (untyped example_group_class, untyped description, untyped user_metadata, ?untyped? example_block) -> void

      # Provide a human-readable representation of this class
      def inspect: () -> ::String

      alias to_s inspect

      # @return [RSpec::Core::Reporter] the current reporter for the example
      attr_reader reporter: untyped

      # Returns the example group class that provides the context for running
      # this example.
      def example_group: () -> untyped

      def pending?: () -> untyped

      def skipped?: () -> untyped

      # @api private
      # instance_execs the block passed to the constructor in the context of
      # the instance of {ExampleGroup}.
      # @param example_group_instance the instance of an ExampleGroup subclass
      def run: (untyped example_group_instance, untyped reporter) -> untyped

      # :nocov:
      # For some reason, rescuing `Support::AllExceptionsExceptOnesWeMustNotRescue`
      # in place of `Exception` above can cause the exit status to be the wrong
      # thing. I have no idea why. See:
      # https://github.com/rspec/rspec-core/pull/2063#discussion_r38284978
      # @private
      # AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt: untyped

      # @private
      AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt: untyped

      # Wraps both a `Proc` and an {Example} for use in {Hooks#around
      # around} hooks. In around hooks we need to yield this special
      # kind of object (rather than the raw {Example}) because when
      # there are multiple `around` hooks we have to wrap them recursively.
      #
      # @example
      #
      #     RSpec.configure do |c|
      #       c.around do |ex| # Procsy which wraps the example
      #         if ex.metadata[:key] == :some_value && some_global_condition
      #           raise "some message"
      #         end
      #         ex.run         # run delegates to ex.call.
      #       end
      #     end
      #
      # @note This class also exposes the instance methods of {Example},
      #   proxying them through to the wrapped {Example} instance.
      class Procsy
        # The {Example} instance.
        attr_reader example: untyped

        # Calls the proc and notes that the example has been executed.
        def call: (*untyped args) { () -> untyped } -> untyped

        alias run call

        # Provides a wrapped proc that will update our `executed?` state when
        # executed.
        def to_proc: () -> untyped

        def initialize: (untyped example) { () -> untyped } -> void

        # @private
        def wrap: () { () -> untyped } -> untyped

        # Indicates whether or not the around hook has executed the example.
        def executed?: () -> untyped

        # @private
        def inspect: () -> untyped
      end

      # @private
      #
      # The exception that will be displayed to the user -- either the failure of
      # the example or the `pending_exception` if the example is pending.
      def display_exception: () -> untyped

      # @private
      #
      # Assigns the exception that will be displayed to the user -- either the failure of
      # the example or the `pending_exception` if the example is pending.
      def display_exception=: (untyped ex) -> untyped

      # @private
      #
      # Used internally to set an exception in an after hook, which
      # captures the exception but doesn't raise it.
      def set_exception: (untyped exception) -> untyped

      # @private
      #
      # Used to set the exception when `aggregate_failures` fails.
      def set_aggregate_failures_exception: (untyped exception) -> untyped

      # @private
      #
      # Used internally to set an exception and fail without actually executing
      # the example when an exception is raised in before(:context).
      def fail_with_exception: (untyped reporter, untyped exception) -> untyped

      # @private
      #
      # Used internally to skip without actually executing the example when
      # skip is used in before(:context).
      def skip_with_exception: (untyped reporter, untyped exception) -> untyped

      # @private
      def instance_exec: (*untyped args) { () -> untyped } -> untyped

      private

      def hooks: () -> untyped

      def with_around_example_hooks: () { () -> untyped } -> untyped

      def start: (untyped reporter) -> untyped

      def finish: (untyped reporter) -> untyped

      def record_finished: (untyped status, untyped reporter) -> untyped

      def run_before_example: () -> untyped

      def with_around_and_singleton_context_hooks: () { () -> untyped } -> untyped

      def run_after_example: () -> untyped

      def verify_mocks: () -> untyped

      def mocks_need_verification?: () -> untyped

      def assign_generated_description: () -> untyped

      def generate_description: () -> untyped

      def location_description: () -> ::String

      # Represents the result of executing an example.
      # Behaves like a hash for backwards compatibility.
      class ExecutionResult
        include HashImitatable

        # @return [Symbol] `:passed`, `:failed` or `:pending`.
        attr_accessor status: untyped

        # @return [Exception, nil] The failure, if there was one.
        attr_accessor exception: untyped

        # @return [Time] When the example started.
        attr_accessor started_at: untyped

        # @return [Time] When the example finished.
        attr_accessor finished_at: untyped

        # @return [Float] How long the example took in seconds.
        attr_accessor run_time: untyped

        # @return [String, nil] The reason the example was pending,
        #   or nil if the example was not pending.
        attr_accessor pending_message: untyped

        # @return [Exception, nil] The exception triggered while
        #   executing the pending example. If no exception was triggered
        #   it would no longer get a status of `:pending` unless it was
        #   tagged with `:skip`.
        attr_accessor pending_exception: untyped

        # @return [Boolean] For examples tagged with `:pending`,
        #   this indicates whether or not it now passes.
        attr_accessor pending_fixed: untyped

        def pending_fixed?: () -> untyped

        # @return [Boolean] Indicates if the example was completely skipped
        #   (typically done via `:skip` metadata or the `skip` method). Skipped examples
        #   will have a `:pending` result. A `:pending` result can also come from examples
        #   that were marked as `:pending`, which causes them to be run, and produces a
        #   `:failed` result if the example passes.
        def example_skipped?: () -> untyped

        # @api private
        # Records the finished status of the example.
        def record_finished: (untyped status, untyped finished_at) -> untyped

        # @api private
        # Populates finished_at and run_time if it has not yet been set
        def ensure_timing_set: (untyped clock) -> untyped

        private

        def calculate_run_time: (untyped finished_at) -> untyped

        # For backwards compatibility we present `status` as a string
        # when presenting the legacy hash interface.
        def hash_for_delegation: () -> untyped

        def set_value: (untyped name, untyped value) -> untyped

        def get_value: (untyped name) -> untyped

        def issue_deprecation: (untyped _method_name, *untyped _args) -> untyped
      end
    end

    # @private
    # Provides an execution context for before/after :suite hooks.
    class SuiteHookContext < Example
      def initialize: (untyped hook_description, untyped reporter) -> void

      # rubocop:disable Naming/AccessorMethodName
      def set_exception: (untyped exception) -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    # Generates conventional files for an RSpec project.
    class ProjectInitializer
      attr_reader destination: untyped

      attr_reader stream: untyped

      attr_reader template_path: untyped

      DOT_RSPEC_FILE: ".rspec"

      SPEC_HELPER_FILE: "spec/spec_helper.rb"

      def initialize: (?::Hash[untyped, untyped] opts) -> void

      def run: () -> untyped

      private

      def copy_template: (untyped file) -> untyped

      def report_exists: (untyped file) -> untyped

      def report_creating: (untyped file) -> untyped
    end
  end
end

module RSpec
  module Core
    # Provides methods to mark examples as pending. These methods are available
    # to be called from within any example or hook.
    module Pending
      # Raised in the middle of an example to indicate that it should be marked
      # as skipped.
      class SkipDeclaredInExample < StandardError
        attr_reader argument: untyped

        def initialize: (untyped argument) -> void
      end

      class PendingExampleFixedError # < Test::Unit::AssertionFailedError
      end

      class PendingExampleFixedError < StandardError
      end

      # @private
      NO_REASON_GIVEN: "No reason given"

      # @private
      NOT_YET_IMPLEMENTED: "Not yet implemented"

      # @overload pending()
      # @overload pending(message)
      #
      # Marks an example as pending. The rest of the example will still be
      # executed, and if it passes the example will fail to indicate that the
      # pending can be removed.
      #
      # @param message [String] optional message to add to the summary report.
      #
      # @example
      #     describe "some behaviour" do
      #       # reported as "Pending: no reason given"
      #       it "is pending with no message" do
      #         pending
      #         raise "broken"
      #       end
      #
      #       # reported as "Pending: something else getting finished"
      #       it "is pending with a custom message" do
      #         pending("something else getting finished")
      #         raise "broken"
      #       end
      #     end
      #
      # @note When using `pending` inside an example body using this method
      #   hooks, such as `before(:example)`, have already be run. This means that
      #   a failure from the code in the `before` hook will prevent the example
      #   from being considered pending, as the example body would not be
      #   executed. If you need to consider hooks as pending as well you can use
      #   the pending metadata as an alternative, e.g.
      #   `it "does something", pending: "message"`.
      def pending: (?untyped? message) -> untyped

      # @overload skip()
      # @overload skip(message)
      #
      # Marks an example as pending and skips execution.
      #
      # @param message [String] optional message to add to the summary report.
      #
      # @example
      #     describe "an example" do
      #       # reported as "Pending: no reason given"
      #       it "is skipped with no message" do
      #         skip
      #       end
      #
      #       # reported as "Pending: something else getting finished"
      #       it "is skipped with a custom message" do
      #         skip "something else getting finished"
      #       end
      #     end
      def skip: (?untyped? message) -> untyped

      # @private
      #
      # Mark example as skipped.
      #
      # @param example [RSpec::Core::Example] the example to mark as skipped
      # @param message_or_bool [Boolean, String] the message to use, or true
      def self.mark_skipped!: (untyped example, untyped message_or_bool) -> untyped

      # @private
      #
      # Mark example as pending.
      #
      # @param example [RSpec::Core::Example] the example to mark as pending
      # @param message_or_bool [Boolean, String] the message to use, or true
      def self.mark_pending!: (untyped example, untyped message_or_bool) -> untyped

      # @private
      #
      # Mark example as fixed.
      #
      # @param example [RSpec::Core::Example] the example to mark as fixed
      def self.mark_fixed!: (untyped example) -> untyped
    end
  end
end

module RSpec
  module Core
    # Persists example ids and their statuses so that we can filter
    # to just the ones that failed the last time they ran.
    # @private
    class ExampleStatusPersister
      def self.load_from: (untyped file_name) -> (::Array[untyped] | untyped)

      def self.persist: (untyped examples, untyped file_name) -> untyped

      def initialize: (untyped examples, untyped file_name) -> void

      def persist: () -> untyped

      private

      def dump_statuses: (untyped unparsed_previous_runs) -> untyped

      def statuses_from_this_run: () -> untyped
    end

    # Merges together a list of example statuses from this run
    # and a list from previous runs (presumably loaded from disk).
    # Each example status object is expected to be a hash with
    # at least an `:example_id` and a `:status` key. Examples that
    # were loaded but not executed (due to filtering, `--fail-fast`
    # or whatever) should have a `:status` of `UNKNOWN_STATUS`.
    #
    # This willl produce a new list that:
    #   - Will be missing examples from previous runs that we know for sure
    #     no longer exist.
    #   - Will have the latest known status for any examples that either
    #     definitively do exist or may still exist.
    #   - Is sorted by file name and example definition order, so that
    #     the saved file is easily scannable if users want to inspect it.
    # @private
    class ExampleStatusMerger
      def self.merge: (untyped this_run, untyped from_previous_runs) -> untyped

      def initialize: (untyped this_run, untyped from_previous_runs) -> void

      def merge: () -> untyped

      private

      def hash_from: (untyped example_list) -> untyped

      def delete_previous_examples_that_no_longer_exist: () -> untyped

      def example_must_no_longer_exist?: (untyped ex_id) -> (false | true | untyped)

      def loaded_spec_files: () -> untyped

      def spec_file_from: (untyped ex_id) -> untyped

      def sort_value_from: (untyped example) -> untyped
    end

    # Dumps a list of hashes in a pretty, human readable format
    # for later parsing. The hashes are expected to have symbol
    # keys and string values, and each hash should have the same
    # set of keys.
    # @private
    class ExampleStatusDumper
      def self.dump: (untyped examples) -> untyped

      def initialize: (untyped examples) -> void

      def dump: () -> (nil | untyped)

      private

      def formatted_header_rows: () -> untyped

      def formatted_value_rows: () -> untyped

      def rows: () -> untyped

      def formatted_row_from: (untyped row_values) -> untyped

      def headers: () -> untyped

      def column_widths: () -> untyped
    end

    # Parses a string that has been previously dumped by ExampleStatusDumper.
    # Note that this parser is a bit naive in that it does a simple split on
    # "\n" and " | ", with no concern for handling escaping. For now, that's
    # OK because the values we plan to persist (example id, status, and perhaps
    # example duration) are highly unlikely to contain "\n" or " | " -- after
    # all, who puts those in file names?
    # @private
    class ExampleStatusParser
      def self.parse: (untyped string) -> untyped

      def initialize: (untyped string) -> void

      def parse: () -> untyped

      private

      def parse_row: (untyped line) -> untyped

      def headers: () -> untyped

      def split_line: (untyped line) -> untyped
    end
  end
end

# This is borrowed (slightly modified) from Scott Taylor's
# project_path project:
#   http://github.com/smtlaissezfaire/project_path
module RSpec
  module Core
    # @private
    module RubyProject
      def self?.add_to_load_path: (*untyped dirs) -> untyped

      def self?.add_dir_to_load_path: (untyped dir) -> untyped

      def self?.root: () -> untyped

      def self?.determine_root: () -> untyped

      def self?.find_first_parent_containing: (untyped dir) -> untyped

      def self?.ascend_until: () { (untyped) -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    # Represents some functionality that is shared with multiple example groups.
    # The functionality is defined by the provided block, which is lazily
    # eval'd when the `SharedExampleGroupModule` instance is included in an example
    # group.
    class SharedExampleGroupModule < Module
      # @private
      attr_reader definition: untyped

      def initialize: (untyped description, untyped definition, untyped metadata) -> void

      # Provides a human-readable representation of this module.
      def inspect: () -> ::String

      alias to_s inspect

      # Ruby callback for when a module is included in another module is class.
      # Our definition evaluates the shared group block in the context of the
      # including example group.
      def included: (untyped klass) -> untyped

      # @private
      def include_in: (untyped klass, untyped inclusion_line, untyped args, untyped customization_block) -> untyped
    end

    # Shared example groups let you define common context and/or common
    # examples that you wish to use in multiple example groups.
    #
    # When defined, the shared group block is stored for later evaluation.
    # It can later be included in an example group either explicitly
    # (using `include_examples`, `include_context` or `it_behaves_like`)
    # or implicitly (via matching metadata).
    #
    # Named shared example groups are scoped based on where they are
    # defined. Shared groups defined in an example group are available
    # for inclusion in that example group or any child example groups,
    # but not in any parent or sibling example groups. Shared example
    # groups defined at the top level can be included from any example group.
    module SharedExampleGroup
      # @overload shared_examples(name, &block)
      #   @param name [String, Symbol, Module] identifer to use when looking up
      #     this shared group
      #   @param block The block to be eval'd
      # @overload shared_examples(name, metadata, &block)
      #   @param name [String, Symbol, Module] identifer to use when looking up
      #     this shared group
      #   @param metadata [Array<Symbol>, Hash] metadata to attach to this
      #     group; any example group or example with matching metadata will
      #     automatically include this shared example group.
      #   @param block The block to be eval'd
      #
      # Stores the block for later use. The block will be evaluated
      # in the context of an example group via `include_examples`,
      # `include_context`, or `it_behaves_like`.
      #
      # @example
      #   shared_examples "auditable" do
      #     it "stores an audit record on save!" do
      #       expect { auditable.save! }.to change(Audit, :count).by(1)
      #     end
      #   end
      #
      #   RSpec.describe Account do
      #     it_behaves_like "auditable" do
      #       let(:auditable) { Account.new }
      #     end
      #   end
      #
      # @see ExampleGroup.it_behaves_like
      # @see ExampleGroup.include_examples
      # @see ExampleGroup.include_context
      def shared_examples: (untyped name, *untyped args) { () -> untyped } -> untyped

      alias shared_context shared_examples

      alias shared_examples_for shared_examples

      # @api private
      #
      # Shared examples top level DSL.
      module TopLevelDSL
        # @private
        def self.definitions: () -> untyped

        # @private
        def self.exposed_globally?: () -> untyped

        # @api private
        #
        # Adds the top level DSL methods to Module and the top level binding.
        def self.expose_globally!: () -> (nil | untyped)

        # @api private
        #
        # Removes the top level DSL methods to Module and the top level binding.
        def self.remove_globally!: () -> (nil | untyped)
      end

      # @private
      class Registry
        def add: (untyped context, untyped name, *untyped metadata_args) { () -> untyped } -> untyped

        def find: (untyped lookup_contexts, untyped name) -> untyped

        private

        # TODO: remove this in RSpec 4. This exists only to support
        # `config.shared_context_metadata_behavior == :trigger_inclusion`,
        # the legacy behavior of shared context metadata, which we do
        # not want to support in RSpec 4.
        def legacy_add: (untyped context, untyped name, *untyped metadata_args) { () -> untyped } -> (nil | untyped)

        def shared_example_groups: () -> untyped

        def valid_name?: (untyped candidate) -> untyped

        def warn_if_key_taken: (untyped context, untyped key, untyped new_block) -> (nil | untyped)

        def formatted_location: (untyped block) -> untyped

        # def ensure_block_has_source_location: (untyped _block) -> nil

        # for 1.8.7
        # :nocov:
        def ensure_block_has_source_location: (untyped block) { () -> untyped } -> untyped
      end
    end
  end
end

module RSpec
  module Core
    # Contains metadata filtering logic. This has been extracted from
    # the metadata classes because it operates ON a metadata hash but
    # does not manage any of the state in the hash. We're moving towards
    # having metadata be a raw hash (not a custom subclass), so externalizing
    # this filtering logic helps us move in that direction.
    module MetadataFilter
      # @private
      def self.apply?: (untyped predicate, untyped filters, untyped metadata) -> untyped

      # @private
      def self.filter_applies?: (untyped key, untyped filter_value, untyped metadata) -> untyped

      # @private
      def self.silence_metadata_example_group_deprecations: () { () -> untyped } -> untyped

      private

      def self.filter_applies_to_any_value?: (untyped key, untyped value, untyped metadata) -> untyped

      def self.id_filter_applies?: (untyped rerun_paths_to_scoped_ids, untyped metadata) -> (false | untyped)

      def self.location_filter_applies?: (untyped locations, untyped metadata) -> untyped

      def self.proc_filter_applies?: (untyped key, untyped proc, untyped metadata) -> untyped

      def self.filters_apply?: (untyped key, untyped value, untyped metadata) -> (false | untyped)
    end

    # Tracks a collection of filterable items (e.g. modules, hooks, etc)
    # and provides an optimized API to get the applicable items for the
    # metadata of an example or example group.
    #
    # There are two implementations, optimized for different uses.
    # @private
    module FilterableItemRepository
      # This implementation is simple, and is optimized for frequent
      # updates but rare queries. `append` and `prepend` do no extra
      # processing, and no internal memoization is done, since this
      # is not optimized for queries.
      #
      # This is ideal for use by a example or example group, which may
      # be updated multiple times with globally configured hooks, etc,
      # but will not be queried frequently by other examples or examle
      # groups.
      # @private
      class UpdateOptimized
        attr_reader items_and_filters: untyped

        def initialize: (untyped applies_predicate) -> void

        def append: (untyped item, untyped metadata) -> untyped

        def prepend: (untyped item, untyped metadata) -> untyped

        def delete: (untyped item, untyped metadata) -> untyped

        def items_for: (untyped request_meta) -> untyped
      end

      # This implementation is much more complex, and is optimized for
      # rare (or hopefully no) updates once the queries start. Updates
      # incur a cost as it has to clear the memoization and keep track
      # of applicable keys. Queries will be O(N) the first time an item
      # is provided with a given set of applicable metadata; subsequent
      # queries with items with the same set of applicable metadata will
      # be O(1) due to internal memoization.
      #
      # This is ideal for use by config, where filterable items (e.g. hooks)
      # are typically added at the start of the process (e.g. in `spec_helper`)
      # and then repeatedly queried as example groups and examples are defined.
      # @private
      class QueryOptimized < UpdateOptimized
        alias find_items_for items_for

        def initialize: (untyped applies_predicate) -> void

        def append: (untyped item, untyped metadata) -> untyped

        def prepend: (untyped item, untyped metadata) -> untyped

        def delete: (untyped item, untyped metadata) -> untyped

        def items_for: (untyped metadata) -> untyped

        private

        def reconstruct_caches: () -> untyped

        def handle_mutation: (untyped metadata) -> untyped

        def applicable_metadata_from: (untyped metadata) -> untyped

        def proc_keys_from: (untyped metadata) -> untyped
      end
    end
  end
end

module RSpec
  module Core
    # @private
    class DRbRunner
      def initialize: (untyped options, ?untyped configuration) -> void

      def drb_port: () -> untyped

      def run: (untyped err, untyped `out`) -> untyped

      def drb_argv: () -> untyped
    end

    # @private
    class DRbOptions
      def initialize: (untyped submitted_options, untyped filter_manager) -> void

      def options: () -> untyped

      def add_failure_exit_code: (untyped argv) -> (nil | untyped)

      def add_error_exit_code: (untyped argv) -> (nil | untyped)

      def add_full_description: (untyped argv) -> (nil | untyped)

      CONDITIONAL_FILTERS: ::Array[:if | :unless]

      def add_filter: (untyped argv, untyped name, untyped hash) -> untyped

      def add_formatters: (untyped argv) -> untyped

      def add_libs: (untyped argv) -> untyped

      def add_requires: (untyped argv) -> untyped
    end
  end
end

module RSpec::Core
  # A reporter will send notifications to listeners, usually formatters for the
  # spec suite run.
  class Reporter
    # @private
    RSPEC_NOTIFICATIONS: untyped

    def initialize: (untyped configuration) -> void

    # @private
    attr_reader examples: untyped

    # @private
    attr_reader failed_examples: untyped

    # @private
    attr_reader pending_examples: untyped

    # Registers a listener to a list of notifications. The reporter will send
    # notification of events to all registered listeners.
    #
    # @param listener [Object] An obect that wishes to be notified of reporter
    #   events
    # @param notifications [Array] Array of symbols represents the events a
    #   listener wishes to subscribe too
    def register_listener: (untyped listener, *untyped notifications) -> true

    # @private
    def prepare_default: (untyped loader, untyped output_stream, untyped deprecation_stream) -> untyped

    # @private
    def registered_listeners: (untyped notification) -> untyped

    # @overload report(count, &block)
    # @overload report(count, &block)
    # @param expected_example_count [Integer] the number of examples being run
    # @yield [Block] block yields itself for further reporting.
    #
    # Initializes the report run and yields itself for further reporting. The
    # block is required, so that the reporter can manage cleaning up after the
    # run.
    #
    # @example
    #
    #     reporter.report(group.examples.size) do |r|
    #       example_groups.map {|g| g.run(r) }
    #     end
    #
    def report: (untyped expected_example_count) { (untyped) -> untyped } -> untyped

    # @param exit_code [Integer] the exit_code to be return by the reporter
    #
    # Reports a run that exited early without having run any examples.
    #
    def exit_early: (untyped exit_code) -> untyped

    # @private
    def start: (untyped expected_example_count, ?untyped time) -> untyped

    # @param message [#to_s] A message object to send to formatters
    #
    # Send a custom message to supporting formatters.
    def message: (untyped message) -> untyped

    # @param event [Symbol] Name of the custom event to trigger on formatters
    # @param options [Hash] Hash of arguments to provide via `CustomNotification`
    #
    # Publish a custom event to supporting registered formatters.
    # @see RSpec::Core::Notifications::CustomNotification
    def publish: (untyped event, ?::Hash[untyped, untyped] options) -> untyped

    # @private
    def example_group_started: (untyped group) -> untyped

    # @private
    def example_group_finished: (untyped group) -> untyped

    # @private
    def example_started: (untyped example) -> untyped

    # @private
    def example_finished: (untyped example) -> untyped

    # @private
    def example_passed: (untyped example) -> untyped

    # @private
    def example_failed: (untyped example) -> untyped

    # @private
    def example_pending: (untyped example) -> untyped

    # @private
    def deprecation: (untyped hash) -> untyped

    # @private
    # Provides a way to notify of an exception that is not tied to any
    # particular example (such as an exception encountered in a :suite hook).
    # Exceptions will be formatted the same way they normally are.
    def notify_non_example_exception: (untyped exception, untyped context_description) -> untyped

    # @private
    def finish: () -> untyped

    # @private
    def close_after: () { () -> untyped } -> untyped

    # @private
    def stop: () -> untyped

    # @private
    def notify: (untyped event, untyped notification) -> untyped

    # @private
    def abort_with: (untyped msg, untyped exit_status) -> untyped

    # @private
    def fail_fast_limit_met?: () -> (false | untyped)

    private

    def ensure_listeners_ready: () -> (nil | untyped)

    def close: () -> untyped

    def mute_profile_output?: () -> untyped

    def seed_used?: () -> untyped
  end

  # @private
  # # Used in place of a {Reporter} for situations where we don't want reporting output.
  class NullReporter
    def self.method_missing: () -> nil
  end
end

module RSpec
  module Core
    # Responsible for utilizing externally provided configuration options,
    # whether via the command line, `.rspec`, `~/.rspec`,
    # `$XDG_CONFIG_HOME/rspec/options`, `.rspec-local` or a custom options
    # file.
    class ConfigurationOptions
      # @param args [Array<String>] command line arguments
      def initialize: (untyped args) -> void

      # Updates the provided {Configuration} instance based on the provided
      # external configuration options.
      #
      # @param config [Configuration] the configuration instance to update
      def configure: (untyped config) -> untyped

      # @api private
      # Updates the provided {FilterManager} based on the filter options.
      # @param filter_manager [FilterManager] instance to update
      def configure_filter_manager: (untyped filter_manager) -> untyped

      # @return [Hash] the final merged options, drawn from all external sources
      attr_reader options: untyped

      # @return [Array<String>] the original command-line arguments
      attr_reader args: untyped

      private

      def organize_options: () -> untyped

      UNFORCED_OPTIONS: untyped

      UNPROCESSABLE_OPTIONS: untyped

      def force?: (untyped key) -> untyped

      def order: (untyped keys) -> untyped

      OPTIONS_ORDER: ::Array[:deprecation_stream | :libs | :default_path | :only_failures | :files_or_directories_to_run | :pattern | :exclude_pattern | :order | :requires]

      def process_options_into: (untyped config) -> untyped

      def load_formatters_into: (untyped config) -> untyped

      def file_options: () -> untyped

      def env_options: () -> (::Hash[untyped, untyped] | untyped)

      def command_line_options: () -> untyped

      def custom_options: () -> untyped

      def local_options: () -> untyped

      def project_options: () -> untyped

      def global_options: () -> untyped

      def options_from: (untyped path) -> untyped

      def parse_args_ignoring_files_or_dirs_to_run: (untyped args, untyped source) -> untyped

      def args_from_options_file: (untyped path) -> (::Array[untyped] | untyped)

      def options_file_as_erb_string: (untyped path) -> untyped

      def custom_options_file: () -> untyped

      def project_options_file: () -> "./.rspec"

      def local_options_file: () -> "./.rspec-local"

      def global_options_file: () -> untyped

      def xdg_options_file_if_exists: () -> untyped

      def home_options_file_path: () -> untyped

      def xdg_options_file_path: () -> untyped

      def resolve_xdg_config_home: () -> untyped
    end
  end
end

module RSpec
  module Core
    # @private
    module Warnings
      # @private
      #
      # Used internally to print deprecation warnings.
      def deprecate: (untyped deprecated, ?::Hash[untyped, untyped] data) -> untyped

      # @private
      #
      # Used internally to print deprecation warnings.
      def warn_deprecation: (untyped message, ?::Hash[untyped, untyped] opts) -> untyped

      # @private
      def warn_with: (untyped message, ?::Hash[untyped, untyped] options) -> untyped
    end
  end
end

module RSpec
  module Core
    # Each ExampleGroup class and Example instance owns an instance of
    # Metadata, which is Hash extended to support lazy evaluation of values
    # associated with keys that may or may not be used by any example or group.
    #
    # In addition to metadata that is used internally, this also stores
    # user-supplied metadata, e.g.
    #
    #     RSpec.describe Something, :type => :ui do
    #       it "does something", :slow => true do
    #         # ...
    #       end
    #     end
    #
    # `:type => :ui` is stored in the Metadata owned by the example group, and
    # `:slow => true` is stored in the Metadata owned by the example. These can
    # then be used to select which examples are run using the `--tag` option on
    # the command line, or several methods on `Configuration` used to filter a
    # run (e.g. `filter_run_including`, `filter_run_excluding`, etc).
    #
    # @see Example#metadata
    # @see ExampleGroup.metadata
    # @see FilterManager
    # @see Configuration#filter_run_including
    # @see Configuration#filter_run_excluding
    module Metadata
      # Matches strings either at the beginning of the input or prefixed with a
      # whitespace, containing the current path, either postfixed with the
      # separator, or at the end of the string. Match groups are the character
      # before and the character after the string if any.
      #
      # http://rubular.com/r/fT0gmX6VJX
      # http://rubular.com/r/duOrD4i3wb
      # http://rubular.com/r/sbAMHFrOx1
      def self.relative_path_regex: () -> untyped

      # @api private
      #
      # @param line [String] current code line
      # @return [String] relative path to line
      def self.relative_path: (untyped line) -> untyped

      # @private
      # Iteratively walks up from the given metadata through all
      # example group ancestors, yielding each metadata hash along the way.
      def self.ascending: (untyped metadata) { (untyped) -> untyped } -> (nil | untyped)

      # @private
      # Returns an enumerator that iteratively walks up the given metadata through all
      # example group ancestors, yielding each metadata hash along the way.
      def self.ascend: (untyped metadata) -> untyped

      # @private
      # Used internally to build a hash from an args array.
      # Symbols are converted into hash keys with a value of `true`.
      # This is done to support simple tagging using a symbol, rather
      # than needing to do `:symbol => true`.
      def self.build_hash_from: (untyped args, ?bool warn_about_example_group_filtering) -> untyped

      # @private
      def self.deep_hash_dup: (untyped object) -> untyped

      # @private
      def self.id_from: (untyped metadata) -> ::String

      # @private
      def self.location_tuple_from: (untyped metadata) -> ::Array[untyped]

      # @private
      # Used internally to populate metadata hashes with computed keys
      # managed by RSpec.
      class HashPopulator
        attr_reader metadata: untyped

        attr_reader user_metadata: untyped

        attr_reader description_args: untyped

        attr_reader block: untyped

        def initialize: (untyped metadata, untyped user_metadata, untyped index_provider, untyped description_args, untyped block) -> void

        def populate: () -> untyped

        private

        def populate_location_attributes: () -> untyped

        def file_path_and_line_number_from: (untyped backtrace) -> untyped

        def description_separator: (untyped parent_part, untyped child_part) -> untyped

        def build_description_from: (?untyped? parent_description, ?untyped? my_description) -> untyped

        def build_scoped_id_for: (untyped file_path) -> (untyped | ::String)

        def ensure_valid_user_keys: () -> untyped
      end

      # @private
      class ExampleHash < HashPopulator
        def self.create: (untyped group_metadata, untyped user_metadata, untyped index_provider, untyped description, untyped block) -> untyped

        private

        def described_class: () -> untyped

        def full_description: () -> untyped
      end

      # @private
      class ExampleGroupHash < HashPopulator
        def self.create: (untyped parent_group_metadata, untyped user_metadata, untyped example_group_index, *untyped args) { () -> untyped } -> untyped

        def self.hash_with_backwards_compatibility_default_proc: () -> untyped

        def self.backwards_compatibility_default_proc: () { () -> untyped } -> untyped

        private

        def described_class: () -> untyped

        def full_description: () -> untyped
      end

      # @private
      RESERVED_KEYS: ::Array[:description | :description_args | :described_class | :example_group | :parent_example_group | :execution_result | :last_run_status | :file_path | :absolute_file_path | :rerun_file_path | :full_description | :line_number | :location | :scoped_id | :block | :shared_group_inclusion_backtrace]
    end

    # Mixin that makes the including class imitate a hash for backwards
    # compatibility. The including class should use `attr_accessor` to
    # declare attributes.
    # @private
    module HashImitatable
      def self.included: (untyped klass) -> untyped

      def to_h: () -> untyped

      def []: (untyped key) -> untyped

      def []=: (untyped key, untyped value) -> untyped

      private

      def extra_hash_attributes: () -> untyped

      def directly_supports_attribute?: (untyped name) -> untyped

      def get_value: (untyped name) -> untyped

      def set_value: (untyped name, untyped value) -> untyped

      def hash_for_delegation: () -> untyped

      def issue_deprecation: (untyped _method_name, *untyped _args) -> nil

      # @private
      module ClassMethods
        def hash_attribute_names: () -> untyped

        def attr_accessor: (*untyped names) -> untyped
      end
    end

    # @private
    # Together with the example group metadata hash default block,
    # provides backwards compatibility for the old `:example_group`
    # key. In RSpec 2.x, the computed keys of a group's metadata
    # were exposed from a nested subhash keyed by `[:example_group]`, and
    # then the parent group's metadata was exposed by sub-subhash
    # keyed by `[:example_group][:example_group]`.
    #
    # In RSpec 3, we reorganized this to that the computed keys are
    # exposed directly of the group metadata hash (no nesting), and
    # `:parent_example_group` returns the parent group's metadata.
    #
    # Maintaining backwards compatibility was difficult: we wanted
    # `:example_group` to return an object that:
    #
    #   * Exposes the top-level metadata keys that used to be nested
    #     under `:example_group`.
    #   * Supports mutation (rspec-rails, for example, assigns
    #     `metadata[:example_group][:described_class]` when you use
    #     anonymous controller specs) such that changes are written
    #     back to the top-level metadata hash.
    #   * Exposes the parent group metadata as
    #     `[:example_group][:example_group]`.
    class LegacyExampleGroupHash
      include HashImitatable

      def initialize: (untyped metadata) -> void

      def to_h: () -> untyped

      private

      def directly_supports_attribute?: (untyped name) -> untyped

      def get_value: (untyped name) -> untyped

      def set_value: (untyped name, untyped value) -> untyped
    end
  end
end

module RSpec
  module Core
    # Version information for RSpec Core.
    module Version
      # Current version of RSpec Core, in semantic versioning format.
      STRING: "3.12.0.pre"
    end
  end
end

module RSpec
  module Core
    # ExampleGroup and {Example} are the main structural elements of
    # rspec-core. Consider this example:
    #
    #     RSpec.describe Thing do
    #       it "does something" do
    #       end
    #     end
    #
    # The object returned by `describe Thing` is a subclass of ExampleGroup.
    # The object returned by `it "does something"` is an instance of Example,
    # which serves as a wrapper for an instance of the ExampleGroup in which it
    # is declared.
    #
    # Example group bodies (e.g. `describe` or `context` blocks) are evaluated
    # in the context of a new subclass of ExampleGroup. Individual examples are
    # evaluated in the context of an instance of the specific ExampleGroup
    # subclass to which they belong.
    #
    # Besides the class methods defined here, there are other interesting macros
    # defined in {Hooks}, {MemoizedHelpers::ClassMethods} and
    # {SharedExampleGroup}. There are additional instance methods available to
    # your examples defined in {MemoizedHelpers} and {Pending}.
    class ExampleGroup
      extend Hooks

      include MemoizedHelpers

      extend MemoizedHelpers::ClassMethods

      include Pending

      extend SharedExampleGroup

      # Define a singleton method for the singleton class (remove the method if
      # it's already been defined).
      # @private
      def self.idempotently_define_singleton_method: (untyped name) { () -> untyped } -> untyped

      # The [Metadata](Metadata) object associated with this group.
      # @see Metadata
      def self.metadata: () -> untyped

      # Temporarily replace the provided metadata.
      # Intended primarily to allow an example group's singleton class
      # to return the metadata of the example that it exists for. This
      # is necessary for shared example group inclusion to work properly
      # with singleton example groups.
      # @private
      def self.with_replaced_metadata: (untyped meta) { () -> untyped } -> untyped

      # @private
      # @return [Metadata] belonging to the parent of a nested {ExampleGroup}
      def self.superclass_metadata: () -> untyped

      # @private
      def self.delegate_to_metadata: (*untyped names) -> untyped

      # @return [String] the current example group description
      def self.description: () -> untyped

      # Returns the class or module passed to the `describe` method (or alias).
      # Returns nil if the subject is not a class or module.
      # @example
      #     RSpec.describe Thing do
      #       it "does something" do
      #         described_class == Thing
      #       end
      #     end
      #
      def described_class: () -> untyped

      # @private
      # @macro [attach] define_example_method
      #   @!scope class
      #   @method $1
      #   @overload $1
      #   @overload $1(&example_implementation)
      #     @param example_implementation [Block] The implementation of the example.
      #   @overload $1(doc_string, *metadata)
      #     @param doc_string [String] The example's doc string.
      #     @param metadata [Array<Symbol>, Hash] Metadata for the example.
      #       Symbols will be transformed into hash entries with `true` values.
      #   @overload $1(doc_string, *metadata, &example_implementation)
      #     @param doc_string [String] The example's doc string.
      #     @param metadata [Array<Symbol>, Hash] Metadata for the example.
      #       Symbols will be transformed into hash entries with `true` values.
      #     @param example_implementation [Block] The implementation of the example.
      #   @yield [Example] the example object
      #   @example
      #     $1 do
      #     end
      #
      #     $1 "does something" do
      #     end
      #
      #     $1 "does something", :slow, :uses_js do
      #     end
      #
      #     $1 "does something", :with => 'additional metadata' do
      #     end
      #
      #     $1 "does something" do |ex|
      #       # ex is the Example object that contains metadata about the example
      #     end
      #
      #  @example
      #     $1 "does something", :slow, :load_factor => 100 do
      #     end
      #
      def self.define_example_method: (untyped name, ?::Hash[untyped, untyped] extra_options) -> untyped

      # @private
      # @macro [attach] define_example_group_method
      #   @!scope class
      #   @overload $1
      #   @overload $1(&example_group_definition)
      #     @param example_group_definition [Block] The definition of the example group.
      #   @overload $1(doc_string, *metadata, &example_implementation)
      #     @param doc_string [String] The group's doc string.
      #     @param metadata [Array<Symbol>, Hash] Metadata for the group.
      #       Symbols will be transformed into hash entries with `true` values.
      #     @param example_group_definition [Block] The definition of the example group.
      #
      #   Generates a subclass of this example group which inherits
      #   everything except the examples themselves.
      #
      #   @example
      #
      #     RSpec.describe "something" do # << This describe method is defined in
      #                                   # << RSpec::Core::DSL, included in the
      #                                   # << global namespace (optional)
      #       before do
      #         do_something_before
      #       end
      #
      #       before(:example, :clean_env) do
      #         env.clear!
      #       end
      #
      #       let(:thing) { Thing.new }
      #
      #       $1 "attribute (of something)" do
      #         # examples in the group get the before hook
      #         # declared above, and can access `thing`
      #       end
      #
      #       $1 "needs additional setup", :clean_env, :implementation => JSON do
      #         # specifies that hooks with matching metadata
      #         # should be be run additionally
      #       end
      #     end
      #
      # @see DSL#describe
      def self.define_example_group_method: (untyped name, ?::Hash[untyped, untyped] metadata) -> untyped

      # @private
      # @macro [attach] define_nested_shared_group_method
      #   @!scope class
      #
      #   @see SharedExampleGroup
      def self.define_nested_shared_group_method: (untyped new_name, ?::String report_label) -> untyped

      # Includes shared content mapped to `name` directly in the group in which
      # it is declared, as opposed to `it_behaves_like`, which creates a nested
      # group. If given a block, that block is also eval'd in the current
      # context.
      #
      # @see SharedExampleGroup
      def self.include_context: (untyped name, *untyped args) { () -> untyped } -> untyped

      # Includes shared content mapped to `name` directly in the group in which
      # it is declared, as opposed to `it_behaves_like`, which creates a nested
      # group. If given a block, that block is also eval'd in the current
      # context.
      #
      # @see SharedExampleGroup
      def self.include_examples: (untyped name, *untyped args) { () -> untyped } -> untyped

      # Clear memoized values when adding/removing examples
      # @private
      def self.reset_memoized: () -> untyped

      # Adds an example to the example group
      def self.add_example: (untyped example) -> untyped

      # Removes an example from the example group
      def self.remove_example: (untyped example) -> untyped

      # @private
      def self.find_and_eval_shared: (untyped label, untyped name, untyped inclusion_location, *untyped args) { () -> untyped } -> untyped

      # @private
      def self.subclass: (untyped parent, untyped description, untyped args, untyped registration_collection) { () -> untyped } -> untyped

      # @private
      def self.set_it_up: (untyped description, untyped args, untyped registration_collection) { () -> untyped } -> untyped

      # @private
      def self.examples: () -> untyped

      # @private
      def self.filtered_examples: () -> untyped

      # @private
      def self.descendant_filtered_examples: () -> untyped

      # @private
      def self.children: () -> untyped

      # @private
      # Traverses the tree of groups, starting with `self`, then the children, recursively.
      # Halts the traversal of a branch of the tree as soon as the passed block returns true.
      # Note that siblings groups and their sub-trees will continue to be explored.
      # This is intended to make it easy to find the top-most group that satisfies some
      # condition.
      def self.traverse_tree_until: () { (untyped) -> untyped } -> (nil | untyped)

      # @private
      def self.next_runnable_index_for: (untyped file) -> untyped

      # @private
      def self.descendants: () -> untyped

      #  @private
      def self.parent_groups: () -> untyped

      # @private
      def self.top_level?: () -> untyped

      # @private
      def self.ensure_example_groups_are_configured: () -> untyped

      # @private
      def self.before_context_ivars: () -> untyped

      # @private
      def self.store_before_context_ivars: (untyped example_group_instance) -> untyped

      # Returns true if a `before(:context)` or `after(:context)`
      # hook is currently executing.
      def self.currently_executing_a_context_hook?: () -> untyped

      # @private
      def self.run_before_context_hooks: (untyped example_group_instance) -> untyped

      # @private
      def self.superclass_before_context_ivars: () -> untyped

      # @private
      def self.run_after_context_hooks: (untyped example_group_instance) -> untyped

      # Runs all the examples in this group.
      def self.run: (?untyped reporter) -> (nil | untyped)

      # @private
      def self.ordering_strategy: () -> untyped

      # @private
      def self.run_examples: (untyped reporter) -> untyped

      # @private
      def self.for_filtered_examples: (untyped reporter) { () -> untyped } -> false

      # @private
      def self.declaration_locations: () -> untyped

      # @return [String] the unique id of this example group. Pass
      #   this at the command line to re-run this exact example group.
      def self.id: () -> untyped

      # @private
      def self.top_level_description: () -> untyped

      # @private
      def self.set_ivars: (untyped `instance`, untyped ivars) -> untyped

      # :nocov:
      # @private
      # INSTANCE_VARIABLE_TO_IGNORE: "@__inspect_output"

      # @private
      INSTANCE_VARIABLE_TO_IGNORE: :@__inspect_output

      # @private
      def self.each_instance_variable_for_example: (untyped group) { (untyped) -> untyped } -> untyped

      # @private
      def initialize: (?untyped? inspect_output) -> void

      # @private
      def inspect: () -> ::String

      # for 1.8.7
      # :nocov:
      # @private
      def singleton_class: () -> untyped

      # @private
      def self.update_inherited_metadata: (untyped updates) -> untyped

      # Raised when an RSpec API is called in the wrong scope, such as `before`
      # being called from within an example rather than from within an example
      # group block.
      WrongScopeError: untyped

      def self.method_missing: (untyped name, *untyped args) -> untyped

      private

      def method_missing: (untyped name, *untyped args) -> untyped
    end

    # @private
    # Unnamed example group used by `SuiteHookContext`.
    class AnonymousExampleGroup < ExampleGroup
      def self.metadata: () -> ::Hash[untyped, untyped]
    end

    # Contains information about the inclusion site of a shared example group.
    class SharedExampleGroupInclusionStackFrame
      # @return [String] the name of the shared example group
      attr_reader shared_group_name: untyped

      # @return [String] the location where the shared example was included
      attr_reader inclusion_location: untyped

      # @private
      def initialize: (untyped shared_group_name, untyped inclusion_location) -> void

      # @return [String] The {#inclusion_location}, formatted for display by a formatter.
      def formatted_inclusion_location: () -> untyped

      # @return [String] Description of this stack frame, in the form used by
      #   RSpec's built-in formatters.
      def description: () -> untyped

      # @private
      def self.current_backtrace: () -> untyped

      # @private
      def self.with_frame: (untyped name, untyped location) { () -> untyped } -> untyped

      # @private
      def self.shared_example_group_inclusions: () -> untyped
    end
  end

  # @private
  #
  # Namespace for the example group subclasses generated by top-level
  # `describe`.
  module ExampleGroups
    # extend Support::RecursiveConstMethods

    def self.assign_const: (untyped group) -> untyped

    def self.constant_scope_for: (untyped group) -> untyped

    def self.remove_all_constants: () -> untyped

    # def self.base_name_for: (untyped group) -> ("Anonymous" | untyped)

    alias self._base_name_for self.base_name_for

    def self.base_name_for: (untyped group) -> untyped

    def self.disambiguate: (untyped name, untyped const_scope) -> untyped
  end
end

class Object
  
  # Defines an example within a group. This is the primary API to define a code example.
  # 
  # https://www.rubydoc.info/gems/rspec-core/RSpec%2FCore%2FExampleGroup.it
  def it: (String doc_string) { () -> void } -> void

  # The describe method creates an example group. Within the block passed to
  # describe you can declare nested groups using the describe or context
  # methods, or you can declare examples using the it or specify methods.

  # Under the hood, an example group is a class in which the block passed to
  # describe or context is evaluated. The blocks passed to it are evaluated
  # in the context of an instance of that class.
  def describe: (untyped) { () -> void } -> void
end

# ## Built-in Formatters
#
# * progress (default) - Prints dots for passing examples, `F` for failures, `*`
#                        for pending.
# * documentation - Prints the docstrings passed to `describe` and `it` methods
#                   (and their aliases).
# * html
# * json - Useful for archiving data for subsequent analysis.
#
# The progress formatter is the default, but you can choose any one or more of
# the other formatters by passing with the `--format` (or `-f` for short)
# command-line option, e.g.
#
#     rspec --format documentation
#
# You can also send the output of multiple formatters to different streams, e.g.
#
#     rspec --format documentation --format html --out results.html
#
# This example sends the output of the documentation formatter to `$stdout`, and
# the output of the html formatter to results.html.
#
# ## Custom Formatters
#
# You can tell RSpec to use a custom formatter by passing its path and name to
# the `rspec` command. For example, if you define MyCustomFormatter in
# path/to/my_custom_formatter.rb, you would type this command:
#
#     rspec --require path/to/my_custom_formatter.rb --format MyCustomFormatter
#
# The reporter calls every formatter with this protocol:
#
# * To start
#   * `start(StartNotification)`
# * Once per example group
#   * `example_group_started(GroupNotification)`
# * Once per example
#   * `example_started(ExampleNotification)`
# * One of these per example, depending on outcome
#   * `example_passed(ExampleNotification)`
#   * `example_failed(FailedExampleNotification)`
#   * `example_pending(ExampleNotification)`
# * Optionally at any time
#   * `message(MessageNotification)`
# * At the end of the suite
#   * `stop(ExamplesNotification)`
#   * `start_dump(NullNotification)`
#   * `dump_pending(ExamplesNotification)`
#   * `dump_failures(ExamplesNotification)`
#   * `dump_summary(SummaryNotification)`
#   * `seed(SeedNotification)`
#   * `close(NullNotification)`
#
# Only the notifications to which you subscribe your formatter will be called
# on your formatter. To subscribe your formatter use:
# `RSpec::Core::Formatters#register` e.g.
#
# `RSpec::Core::Formatters.register FormatterClassName, :example_passed, :example_failed`
#
# We recommend you implement the methods yourself; for simplicity we provide the
# default formatter output via our notification objects but if you prefer you
# can subclass `RSpec::Core::Formatters::BaseTextFormatter` and override the
# methods you wish to enhance.
#
# @see RSpec::Core::Formatters::BaseTextFormatter
# @see RSpec::Core::Reporter
module RSpec::Core::Formatters
  # Register the formatter class
  # @param formatter_class [Class] formatter class to register
  # @param notifications [Array<Symbol>] one or more notifications to be
  #   registered to the specified formatter
  #
  # @see RSpec::Core::Formatters::BaseFormatter
  def self.register: (untyped formatter_class, *untyped notifications) -> untyped

  # @api private
  #
  # `RSpec::Core::Formatters::Loader` is an internal class for
  # managing formatters used by a particular configuration. It is
  # not expected to be used directly, but only through the configuration
  # interface.
  class Loader
    # @api private
    #
    # Internal formatters are stored here when loaded.
    def self.formatters: () -> untyped

    # @api private
    def initialize: (untyped reporter) -> void

    # @return [Array] the loaded formatters
    attr_reader formatters: untyped

    # @return [Reporter] the reporter
    attr_reader reporter: untyped

    # @return [String] the default formatter to setup, defaults to `progress`
    attr_accessor default_formatter: untyped

    # @private
    def prepare_default: (untyped output_stream, untyped deprecation_stream) -> untyped

    # @private
    def setup_default: (untyped output_stream, untyped deprecation_stream) -> (nil | untyped)

    # @private
    def add: (untyped formatter_to_use, *untyped paths) -> (nil | untyped)

    private

    def find_formatter: (untyped formatter_to_use) -> untyped

    def register: (untyped formatter, untyped notifications) -> (nil | untyped)

    def duplicate_formatter_exists?: (untyped new_formatter) -> untyped

    def has_matching_output?: (untyped formatter, untyped new_formatter) -> (true | untyped)

    def existing_formatter_implements?: (untyped notification) -> untyped

    def built_in_formatter: (untyped key) -> untyped

    def notifications_for: (untyped formatter_class) -> untyped

    def custom_formatter: (untyped formatter_ref) -> untyped

    def string_const?: (untyped str) -> untyped

    def path_for: (untyped const_ref) -> untyped

    def underscore_with_fix_for_non_standard_rspec_naming: (untyped string) -> untyped

    # activesupport/lib/active_support/inflector/methods.rb, line 48
    def underscore: (untyped camel_cased_word) -> untyped

    def open_stream: (untyped path_or_wrapper) -> untyped
  end
end

module RSpec
  module Core
    # @private
    module Invocations
      # @private
      class InitializeProject
        def call: (*untyped _args) -> 0
      end

      # @private
      class DRbWithFallback
        def call: (untyped options, untyped err, untyped `out`) -> untyped
      end

      # @private
      class Bisect
        def call: (untyped options, untyped err, untyped `out`) -> untyped

        private

        def bisect_formatter_klass_for: (untyped argument) -> untyped
      end

      # @private
      class PrintVersion
        def call: (untyped _options, untyped _err, untyped `out`) -> 0
      end

      # @private
      PrintHelp: untyped
    end
  end
end

module RSpec
  module Core
    # Stores runtime configuration information.
    #
    # Configuration options are loaded from multiple files and joined together
    # with command-line switches and the `SPEC_OPTS` environment variable.
    #
    # Precedence order (where later entries overwrite earlier entries on
    # conflicts):
    #
    #   * Global (`$XDG_CONFIG_HOME/rspec/options`, or `~/.rspec` if it does
    #     not exist)
    #   * Project-specific (`./.rspec`)
    #   * Local (`./.rspec-local`)
    #   * Command-line options
    #   * `SPEC_OPTS`
    #
    # For example, an option set in the local file will override an option set
    # in your global file.
    #
    # The global, project-specific and local files can all be overridden with a
    # separate custom file using the --options command-line parameter.
    #
    # @example Standard settings
    #     RSpec.configure do |c|
    #       c.drb          = true
    #       c.drb_port     = 1234
    #       c.default_path = 'behavior'
    #     end
    #
    # @example Hooks
    #     RSpec.configure do |c|
    #       c.before(:suite)   { establish_connection }
    #       c.before(:example) { log_in_as :authorized }
    #       c.around(:example) { |ex| Database.transaction(&ex) }
    #     end
    #
    # @see RSpec.configure
    # @see Hooks
    class Configuration
      include RSpec::Core::Hooks

      # Module that holds `attr_reader` declarations. It's in a separate
      # module to allow us to override those methods and use `super`.
      # @private
      Readers: untyped

      # include Readers

      # @private
      class MustBeConfiguredBeforeExampleGroupsError < StandardError
      end

      # @private
      def self.define_reader: (untyped name) -> untyped

      # @private
      def self.define_alias: (untyped name, untyped alias_name) -> untyped

      # @private
      def self.define_predicate: (untyped name) -> untyped

      # @private
      #
      # Invoked by the `add_setting` instance method. Use that method on a
      # `Configuration` instance rather than this class method.
      def self.add_setting: (untyped name, ?::Hash[untyped, untyped] opts) -> untyped

      # @private
      #
      # As `add_setting` but only add the reader.
      def self.add_read_only_setting: (untyped name, ?::Hash[untyped, untyped] opts) -> untyped

      def default_path=: (untyped path) -> untyped

      # Indicates if the DSL has been exposed off of modules and `main`.
      # Default: true
      # @return [Boolean]
      def expose_dsl_globally?: () -> untyped

      # Use this to expose the core RSpec DSL via `Module` and the `main`
      # object. It will be set automatically but you can override it to
      # remove the DSL.
      # Default: true
      def expose_dsl_globally=: (untyped value) -> untyped

      # Determines where deprecation warnings are printed.
      # @param value [IO, String] IO to write to or filename to write to
      def deprecation_stream=: (untyped value) -> untyped

      # Sets the file path to use for persisting example statuses. Necessary for the
      # `--only-failures` and `--next-failure` CLI options.
      def example_status_persistence_file_path=: (untyped value) -> untyped

      # alias only_failures? only_failures

      # @private
      def only_failures_but_not_configured?: () -> untyped

      # @see fail_fast
      def fail_fast=: (untyped value) -> untyped

      # Set the output stream for reporter.
      # @attr value [IO, String] IO to write to or filename to write to, defaults to $stdout
      def output_stream=: (untyped value) -> untyped

      # Set pattern to match files to load.
      # @attr value [String] the filename pattern to filter spec files by
      def pattern=: (untyped value) -> untyped

      # Set pattern to match files to exclude.
      # @attr value [String] the filename pattern to exclude spec files by
      def exclude_pattern=: (untyped value) -> untyped

      # @macro add_setting
      # Report the times for the slowest examples (default: `false`).
      # Use this to specify the number of examples to include in the profile.
      # @return [Boolean]
      attr_writer profile_examples: untyped

      # @deprecated This config option was added in RSpec 2 to pave the way
      #   for this being the default behavior in RSpec 3. Now this option is
      #   a no-op.
      def treat_symbols_as_metadata_keys_with_true_values=: (untyped _value) -> untyped

      # @see shared_context_metadata_behavior
      def shared_context_metadata_behavior=: (untyped value) -> untyped

      # Determines which bisect runner implementation gets used to run subsets
      # of the suite during a bisection. Your choices are:
      #
      #   - `:shell`: Performs a spec run by shelling out, booting RSpec and your
      #     application environment each time. This runner is the most widely
      #     compatible runner, but is not as fast. On platforms that do not
      #     support forking, this is the default.
      #   - `:fork`: Pre-boots RSpec and your application environment in a parent
      #     process, and then forks a child process for each spec run. This runner
      #     tends to be significantly faster than the `:shell` runner but cannot
      #     be used in some situations. On platforms that support forking, this
      #     is the default. If you use this runner, you should ensure that all
      #     of your one-time setup logic goes in a `before(:suite)` hook instead
      #     of getting run at the top-level of a file loaded by `--require`.
      #
      # @note This option will only be used by `--bisect` if you set it in a file
      #   loaded via `--require`.
      #
      # @return [Symbol]
      attr_reader bisect_runner: untyped

      def bisect_runner=: (untyped value) -> untyped

      # @private
      attr_writer files_to_run: untyped

      # @private
      attr_accessor filter_manager: untyped

      # @private
      attr_accessor world: untyped

      # @private
      attr_accessor static_config_filter_manager: untyped

      # @private
      attr_reader backtrace_formatter: untyped

      # @private
      attr_reader ordering_manager: untyped

      # @private
      attr_reader loaded_spec_files: untyped

      # Build an object to store runtime configuration options and set defaults
      def initialize: () -> void

      # @private
      #
      # Used to set higher priority option values from the command line.
      def force: (untyped hash) -> (nil | untyped)

      # @private
      def reset: () -> untyped

      # @private
      def reset_reporter: () -> untyped

      # @private
      def reset_filters: () -> untyped

      # @overload add_setting(name)
      # @overload add_setting(name, opts)
      # @option opts [Symbol] :default
      #
      #   Set a default value for the generated getter and predicate methods:
      #
      #       add_setting(:foo, :default => "default value")
      #
      # @option opts [Symbol] :alias_with
      #
      #   Use `:alias_with` to alias the setter, getter, and predicate to
      #   another name, or names:
      #
      #       add_setting(:foo, :alias_with => :bar)
      #       add_setting(:foo, :alias_with => [:bar, :baz])
      #
      # Adds a custom setting to the RSpec.configuration object.
      #
      #     RSpec.configuration.add_setting :foo
      #
      # Used internally and by extension frameworks like rspec-rails, so they
      # can add config settings that are domain specific. For example:
      #
      #     RSpec.configure do |c|
      #       c.add_setting :use_transactional_fixtures,
      #         :default => true,
      #         :alias_with => :use_transactional_examples
      #     end
      #
      # `add_setting` creates three methods on the configuration object, a
      # setter, a getter, and a predicate:
      #
      #     RSpec.configuration.foo=(value)
      #     RSpec.configuration.foo
      #     RSpec.configuration.foo? # Returns true if foo returns anything but nil or false.
      def add_setting: (untyped name, ?::Hash[untyped, untyped] opts) -> untyped

      # Returns the configured mock framework adapter module.
      # @return [Symbol]
      def mock_framework: () -> untyped

      # Delegates to mock_framework=(framework).
      def mock_framework=: (untyped framework) -> untyped

      # Regexps used to exclude lines from backtraces.
      #
      # Excludes lines from ruby (and jruby) source, installed gems, anything
      # in any "bin" directory, and any of the RSpec libs (outside gem
      # installs) by default.
      #
      # You can modify the list via the getter, or replace it with the setter.
      #
      # To override this behaviour and display a full backtrace, use
      # `--backtrace` on the command line, in a `.rspec` file, or in the
      # `rspec_options` attribute of RSpec's rake task.
      # @return [Array<Regexp>]
      def backtrace_exclusion_patterns: () -> untyped

      # Set regular expressions used to exclude lines in backtrace.
      # @param patterns [Array<Regexp>] set backtrace_formatter exlusion_patterns
      def backtrace_exclusion_patterns=: (untyped patterns) -> untyped

      # Regexps used to include lines in backtraces.
      #
      # Defaults to [Regexp.new Dir.getwd].
      #
      # Lines that match an exclusion _and_ an inclusion pattern
      # will be included.
      #
      # You can modify the list via the getter, or replace it with the setter.
      # @return [Array<Regexp>]
      def backtrace_inclusion_patterns: () -> untyped

      # Set regular expressions used to include lines in backtrace.
      # @attr patterns [Array<Regexp>] set backtrace_formatter inclusion_patterns
      def backtrace_inclusion_patterns=: (untyped patterns) -> untyped

      # Adds {#backtrace_exclusion_patterns} that will filter lines from
      # the named gems from backtraces.
      #
      # @param gem_names [Array<String>] Names of the gems to filter
      #
      # @example
      #   RSpec.configure do |config|
      #     config.filter_gems_from_backtrace "rack", "rake"
      #   end
      #
      # @note The patterns this adds will match the named gems in their common
      #   locations (e.g. system gems, vendored with bundler, installed as a
      #   :git dependency with bundler, etc) but is not guaranteed to work for
      #   all possible gem locations. For example, if you have the gem source
      #   in a directory with a completely unrelated name, and use bundler's
      #   :path option, this will not filter it.
      def filter_gems_from_backtrace: (*untyped gem_names) -> untyped

      # @private
      MOCKING_ADAPTERS: { rspec: :RSpec, flexmock: :Flexmock, rr: :RR, mocha: :Mocha, nothing: :Null }

      # Sets the mock framework adapter module.
      #
      # `framework` can be a Symbol or a Module.
      #
      # Given any of `:rspec`, `:mocha`, `:flexmock`, or `:rr`, configures the
      # named framework.
      #
      # Given `:nothing`, configures no framework. Use this if you don't use
      # any mocking framework to save a little bit of overhead.
      #
      # Given a Module, includes that module in every example group. The module
      # should adhere to RSpec's mock framework adapter API:
      #
      #     setup_mocks_for_rspec
      #       - called before each example
      #
      #     verify_mocks_for_rspec
      #       - called after each example if the example hasn't yet failed.
      #         Framework should raise an exception when expectations fail
      #
      #     teardown_mocks_for_rspec
      #       - called after verify_mocks_for_rspec (even if there are errors)
      #
      # If the module responds to `configuration` and `mock_with` receives a
      # block, it will yield the configuration object to the block e.g.
      #
      #     config.mock_with OtherMockFrameworkAdapter do |mod_config|
      #       mod_config.custom_setting = true
      #     end
      def mock_with: (untyped framework) { (untyped) -> untyped } -> untyped

      # Returns the configured expectation framework adapter module(s)
      def expectation_frameworks: () -> untyped

      # Delegates to expect_with(framework).
      def expectation_framework=: (untyped framework) -> untyped

      # Sets the expectation framework module(s) to be included in each example
      # group.
      #
      # `frameworks` can be `:rspec`, `:test_unit`, `:minitest`, a custom
      # module, or any combination thereof:
      #
      #     config.expect_with :rspec
      #     config.expect_with :test_unit
      #     config.expect_with :minitest
      #     config.expect_with :rspec, :minitest
      #     config.expect_with OtherExpectationFramework
      #
      # RSpec will translate `:rspec`, `:minitest`, and `:test_unit` into the
      # appropriate modules.
      #
      # ## Configuration
      #
      # If the module responds to `configuration`, `expect_with` will
      # yield the `configuration` object if given a block:
      #
      #     config.expect_with OtherExpectationFramework do |custom_config|
      #       custom_config.custom_setting = true
      #     end
      def expect_with: (*untyped frameworks) { (untyped) -> untyped } -> untyped

      # Check if full backtrace is enabled.
      # @return [Boolean] is full backtrace enabled
      def full_backtrace?: () -> untyped

      # Toggle full backtrace.
      # @attr true_or_false [Boolean] toggle full backtrace display
      def full_backtrace=: (untyped true_or_false) -> untyped

      # Enables color output if the output is a TTY.  As of RSpec 3.6, this is
      # the default behavior and this option is retained only for backwards
      # compatibility.
      #
      # @deprecated No longer recommended because of complex behavior. Instead,
      #   rely on the fact that TTYs will display color by default, or set
      #   {#color_mode} to :on to display color on a non-TTY output.
      # @see color_mode
      # @see color_enabled?
      # @return [Boolean]
      def color: () -> untyped

      # The mode for determining whether to display output in color. One of:
      #
      # - :automatic - the output will be in color if the output is a TTY (the
      #   default)
      # - :on - the output will be in color, whether or not the output is a TTY
      # - :off - the output will not be in color
      #
      # @see color_enabled?
      # @return [Boolean]
      def color_mode: () -> untyped

      # Check if color is enabled for a particular output.
      # @param output [IO] an output stream to use, defaults to the current
      #        `output_stream`
      # @return [Boolean]
      def color_enabled?: (?untyped output) -> untyped

      # Set the color mode.
      attr_writer color_mode: untyped

      # Toggle output color.
      #
      # @deprecated No longer recommended because of complex behavior. Instead,
      #   rely on the fact that TTYs will display color by default, or set
      #   {:color_mode} to :on to display color on a non-TTY output.
      attr_writer color: untyped

      # @private
      def libs=: (untyped libs) -> untyped

      # Run examples matching on `description` in all files to run.
      # @param description [String, Regexp] the pattern to filter on
      def full_description=: (untyped description) -> untyped

      # @return [Array] full description filter
      def full_description: () -> untyped

      # @overload add_formatter(formatter)
      # @overload add_formatter(formatter, output)
      #
      # @param formatter [Class, String, Object] formatter to use. Can be any of the
      #   string values supported from the CLI (`p`/`progress`,
      #   `d`/`doc`/`documentation`, `h`/`html`, or `j`/`json`), any
      #   class that implements the formatter protocol and has registered
      #   itself with RSpec as a formatter, or a formatter instance.
      # @param output [String, IO] where the formatter will write its output.
      #   Can be an IO object or a string path to a file. If not provided,
      #   the configured `output_stream` (`$stdout`, by default) will be used.
      #
      # Adds a formatter to the set RSpec will use for this run.
      #
      # @see RSpec::Core::Formatters::Protocol
      def add_formatter: (untyped formatter, ?untyped output) -> untyped

      alias formatter= add_formatter

      # The formatter that will be used if no formatter has been set.
      # Defaults to 'progress'.
      def default_formatter: () -> untyped

      # Sets a fallback formatter to use if none other has been set.
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.default_formatter = 'doc'
      #   end
      def default_formatter=: (untyped value) -> untyped

      # Returns a duplicate of the formatters currently loaded in
      # the `FormatterLoader` for introspection.
      #
      # Note as this is a duplicate, any mutations will be disregarded.
      #
      # @return [Array] the formatters currently loaded
      def formatters: () -> untyped

      # @private
      def formatter_loader: () -> untyped

      # @private
      #
      # This buffer is used to capture all messages sent to the reporter during
      # reporter initialization. It can then replay those messages after the
      # formatter is correctly initialized. Otherwise, deprecation warnings
      # during formatter initialization can cause an infinite loop.
      class DeprecationReporterBuffer
        def initialize: () -> void

        def deprecation: (*untyped args) -> untyped

        def play_onto: (untyped reporter) -> untyped
      end

      # @return [RSpec::Core::Reporter] the currently configured reporter
      def reporter: () -> untyped

      # @api private
      #
      # Defaults `profile_examples` to 10 examples when `@profile_examples` is
      # `true`.
      def profile_examples: () -> untyped

      # @private
      def files_or_directories_to_run=: (*untyped files) -> untyped

      # The spec files RSpec will run.
      # @return [Array] specified files about to run
      def files_to_run: () -> untyped

      # @private
      def last_run_statuses: () -> untyped

      # @private
      UNKNOWN_STATUS: "unknown"

      # @private
      FAILED_STATUS: "failed"

      # @private
      PASSED_STATUS: "passed"

      # @private
      PENDING_STATUS: "pending"

      # @private
      VALID_STATUSES: ::Array[untyped]

      # @private
      def spec_files_with_failures: () -> untyped

      # Creates a method that delegates to `example` including the submitted
      # `args`. Used internally to add variants of `example` like `pending`:
      # @param name [String] example name alias
      # @param args [Array<Symbol>, Hash] metadata for the generated example
      #
      # @note The specific example alias below (`pending`) is already
      #   defined for you.
      # @note Use with caution. This extends the language used in your
      #   specs, but does not add any additional documentation. We use this
      #   in RSpec to define methods like `focus` and `xit`, but we also add
      #   docs for those methods.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.alias_example_to :pending, :pending => true
      #   end
      #
      #   # This lets you do this:
      #
      #   RSpec.describe Thing do
      #     pending "does something" do
      #       thing = Thing.new
      #     end
      #   end
      #
      #   # ... which is the equivalent of
      #
      #   RSpec.describe Thing do
      #     it "does something", :pending => true do
      #       thing = Thing.new
      #     end
      #   end
      def alias_example_to: (untyped name, *untyped args) -> untyped

      # Creates a method that defines an example group with the provided
      # metadata. Can be used to define example group/metadata shortcuts.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.alias_example_group_to :describe_model, :type => :model
      #   end
      #
      #   shared_context_for "model tests", :type => :model do
      #     # define common model test helper methods, `let` declarations, etc
      #   end
      #
      #   # This lets you do this:
      #
      #   RSpec.describe_model User do
      #   end
      #
      #   # ... which is the equivalent of
      #
      #   RSpec.describe User, :type => :model do
      #   end
      #
      # @note The defined aliased will also be added to the top level
      #       (e.g. `main` and from within modules) if
      #       `expose_dsl_globally` is set to true.
      # @see #alias_example_to
      # @see #expose_dsl_globally=
      def alias_example_group_to: (untyped new_name, *untyped args) -> untyped

      # Define an alias for it_should_behave_like that allows different
      # language (like "it_has_behavior" or "it_behaves_like") to be
      # employed when including shared examples.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.alias_it_behaves_like_to(:it_has_behavior, 'has behavior:')
      #   end
      #
      #   # allows the user to include a shared example group like:
      #
      #   RSpec.describe Entity do
      #     it_has_behavior 'sortability' do
      #       let(:sortable) { Entity.new }
      #     end
      #   end
      #
      #   # which is reported in the output as:
      #   # Entity
      #   #   has behavior: sortability
      #   #     ...sortability examples here
      #
      # @note Use with caution. This extends the language used in your
      #   specs, but does not add any additional documentation. We use this
      #   in RSpec to define `it_should_behave_like` (for backward
      #   compatibility), but we also add docs for that method.
      def alias_it_behaves_like_to: (untyped new_name, ?::String report_label) -> untyped

      alias alias_it_should_behave_like_to alias_it_behaves_like_to

      # Adds key/value pairs to the `inclusion_filter`. If `args`
      # includes any symbols that are not part of the hash, each symbol
      # is treated as a key in the hash with the value `true`.
      #
      # ### Note
      #
      # Filters set using this method can be overridden from the command line
      # or config files (e.g. `.rspec`).
      #
      # @example
      #     # Given this declaration.
      #     describe "something", :foo => 'bar' do
      #       # ...
      #     end
      #
      #     # Any of the following will include that group.
      #     config.filter_run_including :foo => 'bar'
      #     config.filter_run_including :foo => /^ba/
      #     config.filter_run_including :foo => lambda {|v| v == 'bar'}
      #     config.filter_run_including :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     # Given a proc with an arity of 1, the lambda is passed the value
      #     # related to the key, e.g.
      #     config.filter_run_including :foo => lambda {|v| v == 'bar'}
      #
      #     # Given a proc with an arity of 2, the lambda is passed the value
      #     # related to the key, and the metadata itself e.g.
      #     config.filter_run_including :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     filter_run_including :foo # same as filter_run_including :foo => true
      def filter_run_including: (*untyped args) -> untyped

      alias filter_run filter_run_including

      # Applies the provided filter only if any of examples match, in constrast
      # to {#filter_run}, which always applies even if no examples match, in
      # which case no examples will be run. This allows you to leave configured
      # filters in place that are intended only for temporary use. The most common
      # example is focus filtering: `config.filter_run_when_matching :focus`.
      # With that configured, you can temporarily focus an example or group
      # by tagging it with `:focus` metadata, or prefixing it with an `f`
      # (as in `fdescribe`, `fcontext` and `fit`) since those are aliases for
      # `describe`/`context`/`it` with `:focus` metadata.
      def filter_run_when_matching: (*untyped args) -> untyped

      # Clears and reassigns the `inclusion_filter`. Set to `nil` if you don't
      # want any inclusion filter at all.
      #
      # ### Warning
      #
      # This overrides any inclusion filters/tags set on the command line or in
      # configuration files.
      def inclusion_filter=: (untyped filter) -> untyped

      alias filter= inclusion_filter=

      # Returns the `inclusion_filter`. If none has been set, returns an empty
      # hash.
      def inclusion_filter: () -> untyped

      alias filter inclusion_filter

      # Adds key/value pairs to the `exclusion_filter`. If `args`
      # includes any symbols that are not part of the hash, each symbol
      # is treated as a key in the hash with the value `true`.
      #
      # ### Note
      #
      # Filters set using this method can be overridden from the command line
      # or config files (e.g. `.rspec`).
      #
      # @example
      #     # Given this declaration.
      #     describe "something", :foo => 'bar' do
      #       # ...
      #     end
      #
      #     # Any of the following will exclude that group.
      #     config.filter_run_excluding :foo => 'bar'
      #     config.filter_run_excluding :foo => /^ba/
      #     config.filter_run_excluding :foo => lambda {|v| v == 'bar'}
      #     config.filter_run_excluding :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     # Given a proc with an arity of 1, the lambda is passed the value
      #     # related to the key, e.g.
      #     config.filter_run_excluding :foo => lambda {|v| v == 'bar'}
      #
      #     # Given a proc with an arity of 2, the lambda is passed the value
      #     # related to the key, and the metadata itself e.g.
      #     config.filter_run_excluding :foo => lambda {|v,m| m[:foo] == 'bar'}
      #
      #     filter_run_excluding :foo # same as filter_run_excluding :foo => true
      def filter_run_excluding: (*untyped args) -> untyped

      # Clears and reassigns the `exclusion_filter`. Set to `nil` if you don't
      # want any exclusion filter at all.
      #
      # ### Warning
      #
      # This overrides any exclusion filters/tags set on the command line or in
      # configuration files.
      def exclusion_filter=: (untyped filter) -> untyped

      # Returns the `exclusion_filter`. If none has been set, returns an empty
      # hash.
      def exclusion_filter: () -> untyped

      # Tells RSpec to include `mod` in example groups. Methods defined in
      # `mod` are exposed to examples (not example groups). Use `filters` to
      # constrain the groups or examples in which to include the module.
      #
      # @example
      #
      #     module AuthenticationHelpers
      #       def login_as(user)
      #         # ...
      #       end
      #     end
      #
      #     module PreferencesHelpers
      #       def preferences(user, preferences = {})
      #         # ...
      #       end
      #     end
      #
      #     module UserHelpers
      #       def users(username)
      #         # ...
      #       end
      #     end
      #
      #     RSpec.configure do |config|
      #       config.include(UserHelpers) # included in all groups
      #
      #       # included in examples with `:preferences` metadata
      #       config.include(PreferenceHelpers, :preferences)
      #
      #       # included in examples with `:type => :request` metadata
      #       config.include(AuthenticationHelpers, :type => :request)
      #     end
      #
      #     describe "edit profile", :preferences, :type => :request do
      #       it "can be viewed by owning user" do
      #         login_as preferences(users(:jdoe), :lang => 'es')
      #         get "/profiles/jdoe"
      #         assert_select ".username", :text => 'jdoe'
      #       end
      #     end
      #
      # @note Filtered module inclusions can also be applied to
      #   individual examples that have matching metadata. Just like
      #   Ruby's object model is that every object has a singleton class
      #   which has only a single instance, RSpec's model is that every
      #   example has a singleton example group containing just the one
      #   example.
      #
      # @see #include_context
      # @see #extend
      # @see #prepend
      def include: (untyped mod, *untyped filters) -> untyped

      # Tells RSpec to include the named shared example group in example groups.
      # Use `filters` to constrain the groups or examples in which to include
      # the example group.
      #
      # @example
      #
      #     RSpec.shared_context "example admin user" do
      #       let(:admin_user) { create_user(:admin) }
      #     end
      #
      #     RSpec.shared_context "example guest user" do
      #       let(:guest_user) { create_user(:guest) }
      #     end
      #
      #     RSpec.configure do |config|
      #       config.include_context "example guest user", :type => :request
      #       config.include_context "example admin user", :admin, :type => :request
      #     end
      #
      #     RSpec.describe "The admin page", :type => :request do
      #       it "can be viewed by admins", :admin do
      #         login_with admin_user
      #         get "/admin"
      #         expect(response).to be_ok
      #       end
      #
      #       it "cannot be viewed by guests" do
      #         login_with guest_user
      #         get "/admin"
      #         expect(response).to be_forbidden
      #       end
      #     end
      #
      # @note Filtered context inclusions can also be applied to
      #   individual examples that have matching metadata. Just like
      #   Ruby's object model is that every object has a singleton class
      #   which has only a single instance, RSpec's model is that every
      #   example has a singleton example group containing just the one
      #   example.
      #
      # @see #include
      def include_context: (untyped shared_group_name, *untyped filters) -> untyped

      # Tells RSpec to extend example groups with `mod`. Methods defined in
      # `mod` are exposed to example groups (not examples). Use `filters` to
      # constrain the groups to extend.
      #
      # Similar to `include`, but behavior is added to example groups, which
      # are classes, rather than the examples, which are instances of those
      # classes.
      #
      # @example
      #
      #     module UiHelpers
      #       def run_in_browser
      #         # ...
      #       end
      #     end
      #
      #     module PermissionHelpers
      #       def define_permissions
      #         # ...
      #       end
      #     end
      #
      #     RSpec.configure do |config|
      #       config.extend(UiHelpers, :type => :request)
      #       config.extend(PermissionHelpers, :with_permissions, :type => :request)
      #     end
      #
      #     describe "edit profile", :with_permissions, :type => :request do
      #       run_in_browser
      #       define_permissions
      #
      #       it "does stuff in the client" do
      #         # ...
      #       end
      #     end
      #
      # @see #include
      # @see #prepend
      def extend: (untyped mod, *untyped filters) -> untyped

      # Tells RSpec to prepend example groups with `mod`. Methods defined in
      # `mod` are exposed to examples (not example groups). Use `filters` to
      # constrain the groups in which to prepend the module.
      #
      # Similar to `include`, but module is included before the example group's class
      # in the ancestor chain.
      #
      # @example
      #
      #     module OverrideMod
      #       def override_me
      #         "overridden"
      #       end
      #     end
      #
      #     RSpec.configure do |config|
      #       config.prepend(OverrideMod, :method => :prepend)
      #     end
      #
      #     describe "overriding example's class", :method => :prepend do
      #       it "finds the user" do
      #         self.class.class_eval do
      #           def override_me
      #           end
      #         end
      #         override_me # => "overridden"
      #         # ...
      #       end
      #     end
      #
      # @see #include
      # @see #extend
      def prepend: (untyped mod, *untyped filters) -> untyped

      # @private
      #
      # Used internally to extend a group with modules using `include`, `prepend` and/or
      # `extend`.
      def configure_group: (untyped group) -> untyped

      # @private
      #
      # Used internally to extend the singleton class of a single example's
      # example group instance with modules using `include` and/or `extend`.
      def configure_example: (untyped example, untyped example_hooks) -> untyped

      # @private
      def requires=: (untyped paths) -> untyped

      # @private
      def in_project_source_dir_regex: () -> untyped

      # @private
      def configure_mock_framework: () -> untyped

      # @private
      def configure_expectation_framework: () -> untyped

      # @private
      def load_spec_files: () -> untyped

      # @private
      DEFAULT_FORMATTER: untyped

      # Formats the docstring output using the block provided.
      #
      # @example
      #   # This will strip the descriptions of both examples and example
      #   # groups.
      #   RSpec.configure do |config|
      #     config.format_docstrings { |s| s.strip }
      #   end
      def format_docstrings: () { () -> untyped } -> untyped

      # @private
      def format_docstrings_block: () -> untyped

      # @private
      def self.delegate_to_ordering_manager: (*untyped methods) -> untyped

      # Set Ruby warnings on or off.
      def warnings=: (untyped value) -> untyped

      # @return [Boolean] Whether or not ruby warnings are enabled.
      def warnings?: () -> untyped

      # @private
      RAISE_ERROR_WARNING_NOTIFIER: untyped

      # Turns warnings into errors. This can be useful when
      # you want RSpec to run in a 'strict' no warning situation.
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.raise_on_warning = true
      #   end
      def raise_on_warning=: (untyped value) -> untyped

      # Exposes the current running example via the named
      # helper method. RSpec 2.x exposed this via `example`,
      # but in RSpec 3.0, the example is instead exposed via
      # an arg yielded to `it`, `before`, `let`, etc. However,
      # some extension gems (such as Capybara) depend on the
      # RSpec 2.x's `example` method, so this config option
      # can be used to maintain compatibility.
      #
      # @param method_name [Symbol] the name of the helper method
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.expose_current_running_example_as :example
      #   end
      #
      #   RSpec.describe MyClass do
      #     before do
      #       # `example` can be used here because of the above config.
      #       do_something if example.metadata[:type] == "foo"
      #     end
      #   end
      def expose_current_running_example_as: (untyped method_name) -> untyped

      # @private
      module ExposeCurrentExample
      end

      # Turns deprecation warnings into errors, in order to surface
      # the full backtrace of the call site. This can be useful when
      # you need more context to address a deprecation than the
      # single-line call site normally provided.
      #
      # @example
      #
      #   RSpec.configure do |rspec|
      #     rspec.raise_errors_for_deprecations!
      #   end
      def raise_errors_for_deprecations!: () -> untyped

      # Enables zero monkey patching mode for RSpec. It removes monkey
      # patching of the top-level DSL methods (`describe`,
      # `shared_examples_for`, etc) onto `main` and `Module`, instead
      # requiring you to prefix these methods with `RSpec.`. It enables
      # expect-only syntax for rspec-mocks and rspec-expectations. It
      # simply disables monkey patching on whatever pieces of RSpec
      # the user is using.
      #
      # @note It configures rspec-mocks and rspec-expectations only
      #   if the user is using those (either explicitly or implicitly
      #   by not setting `mock_with` or `expect_with` to anything else).
      #
      # @note If the user uses this options with `mock_with :mocha`
      #   (or similiar) they will still have monkey patching active
      #   in their test environment from mocha.
      #
      # @example
      #
      #   # It disables all monkey patching.
      #   RSpec.configure do |config|
      #     config.disable_monkey_patching!
      #   end
      #
      #   # Is an equivalent to
      #   RSpec.configure do |config|
      #     config.expose_dsl_globally = false
      #
      #     config.mock_with :rspec do |mocks|
      #       mocks.syntax = :expect
      #       mocks.patch_marshal_to_support_partial_doubles = false
      #     end
      #
      #     config.expect_with :rspec do |expectations|
      #       expectations.syntax = :expect
      #     end
      #   end
      def disable_monkey_patching!: () -> untyped

      # @private
      attr_accessor disable_monkey_patching: untyped

      # Defines a callback that can assign derived metadata values.
      #
      # @param filters [Array<Symbol>, Hash] metadata filters that determine
      #   which example or group metadata hashes the callback will be triggered
      #   for. If none are given, the callback will be run against the metadata
      #   hashes of all groups and examples.
      # @yieldparam metadata [Hash] original metadata hash from an example or
      #   group. Mutate this in your block as needed.
      #
      # @example
      #   RSpec.configure do |config|
      #     # Tag all groups and examples in the spec/unit directory with
      #     # :type => :unit
      #     config.define_derived_metadata(:file_path => %r{/spec/unit/}) do |metadata|
      #       metadata[:type] = :unit
      #     end
      #   end
      def define_derived_metadata: (*untyped filters) { () -> untyped } -> untyped

      # Defines a callback that runs after the first example with matching
      # metadata is defined. If no examples are defined with matching metadata,
      # it will not get called at all.
      #
      # This can be used to ensure some setup is performed (such as bootstrapping
      # a DB or loading a specific file that adds significantly to the boot time)
      # if needed (as indicated by the presence of an example with matching metadata)
      # but avoided otherwise.
      #
      # @example
      #   RSpec.configure do |config|
      #     config.when_first_matching_example_defined(:db) do
      #       # Load a support file that does some heavyweight setup,
      #       # including bootstrapping the DB, but only if we have loaded
      #       # any examples tagged with `:db`.
      #       require 'support/db'
      #     end
      #   end
      def when_first_matching_example_defined: (*untyped filters) { () -> untyped } -> (nil | untyped)

      # @private
      def apply_derived_metadata_to: (untyped metadata) -> (nil | untyped)

      # Defines a `before` hook. See {Hooks#before} for full docs.
      #
      # This method differs from {Hooks#before} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once before
      # the first example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #prepend_before
      # @see #after
      # @see #append_after
      def before: (?untyped? scope, *untyped meta) { () -> untyped } -> untyped

      alias append_before before

      # Adds `block` to the start of the list of `before` blocks in the same
      # scope (`:example`, `:context`, or `:suite`), in contrast to {#before},
      # which adds the hook to the end of the list.
      #
      # See {Hooks#before} for full `before` hook docs.
      #
      # This method differs from {Hooks#prepend_before} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once before
      # the first example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #before
      # @see #after
      # @see #append_after
      def prepend_before: (?untyped? scope, *untyped meta) { () -> untyped } -> untyped

      # Defines a `after` hook. See {Hooks#after} for full docs.
      #
      # This method differs from {Hooks#after} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once after
      # the last example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #append_after
      # @see #before
      # @see #prepend_before
      def after: (?untyped? scope, *untyped meta) { () -> untyped } -> untyped

      alias prepend_after after

      # Adds `block` to the end of the list of `after` blocks in the same
      # scope (`:example`, `:context`, or `:suite`), in contrast to {#after},
      # which adds the hook to the start of the list.
      #
      # See {Hooks#after} for full `after` hook docs.
      #
      # This method differs from {Hooks#append_after} in only one way: it supports
      # the `:suite` scope. Hooks with the `:suite` scope will be run once after
      # the last example of the entire suite is executed. Conditions passed along
      # with `:suite` are effectively ignored.
      #
      # @see #append_after
      # @see #before
      # @see #prepend_before
      def append_after: (?untyped? scope, *untyped meta) { () -> untyped } -> untyped

      # Registers `block` as an `around` hook.
      #
      # See {Hooks#around} for full `around` hook docs.
      def around: (?untyped? scope, *untyped meta) { () -> untyped } -> untyped

      # @private
      def with_suite_hooks: () { () -> untyped } -> untyped

      # @private
      # Holds the various registered hooks. Here we use a FilterableItemRepository
      # implementation that is specifically optimized for the read/write patterns
      # of the config object.
      def hooks: () -> untyped

      # Invokes block before defining an example group
      def on_example_group_definition: () { () -> untyped } -> untyped

      # @api private
      # Returns an array of blocks to call before defining an example group
      def on_example_group_definition_callbacks: () -> untyped

      # @private
      def bisect_runner_class: () -> untyped

      private

      def load_file_handling_errors: (untyped method, untyped file) -> untyped

      def handle_suite_hook: (untyped scope, untyped meta) { () -> untyped } -> (nil | untyped)

      def run_suite_hooks: (untyped hook_description, untyped hooks) -> untyped

      def get_files_to_run: (untyped paths) -> untyped

      def paths_to_check: (untyped paths) -> untyped

      def pattern_might_load_specs_from_vendored_dirs?: () -> untyped

      def gather_directories: (untyped path) -> untyped

      def get_matching_files: (untyped path, untyped pattern) -> untyped

      def file_glob_from: (untyped path, untyped pattern) -> untyped

      # :nocov:
      def absolute_pattern?: (untyped pattern) -> untyped

      def windows_absolute_network_path?: (untyped pattern) -> (false | untyped)

      def extract_location: (untyped path) -> (::Array[untyped] | untyped)

      def command: () -> untyped

      def value_for: (untyped key) { () -> untyped } -> untyped

      def define_built_in_hooks: () -> untyped

      def assert_no_example_groups_defined: (untyped config_option) -> (nil | untyped)

      def output_wrapper: () -> untyped

      def output_to_tty?: (?untyped output) -> untyped

      def conditionally_disable_mocks_monkey_patching: () -> (nil | untyped)

      def conditionally_disable_expectations_monkey_patching: () -> (nil | untyped)

      def rspec_mocks_loaded?: () -> untyped

      def rspec_expectations_loaded?: () -> untyped

      def update_pattern_attr: (untyped name, untyped value) -> untyped

      def clear_values_derived_from_example_status_persistence_file_path: () -> untyped

      def configure_group_with: (untyped group, untyped module_list, untyped application_method) -> untyped

      def add_hook_to_existing_matching_groups: (untyped meta, untyped scope) { () -> untyped } -> untyped

      def on_existing_matching_groups: (untyped meta) { (untyped) -> untyped } -> untyped

      def metadata_applies_to_group?: (untyped meta, untyped group) -> untyped

      def safe_prepend: (untyped mod, untyped host) -> untyped

      def safe_include: (untyped mod, untyped host) -> untyped

      def safe_extend: (untyped mod, untyped host) -> untyped

      def define_mixed_in_module: (untyped mod, untyped filters, untyped mod_list, untyped config_method) { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    # Provides `before`, `after` and `around` hooks as a means of
    # supporting common setup and teardown. This module is extended
    # onto {ExampleGroup}, making the methods available from any `describe`
    # or `context` block and included in {Configuration}, making them
    # available off of the configuration object to define global setup
    # or teardown logic.
    module Hooks
      # @api public
      #
      # @overload before(&block)
      # @overload before(scope, &block)
      #   @param scope [Symbol] `:example`, `:context`, or `:suite`
      #     (defaults to `:example`)
      # @overload before(scope, *conditions, &block)
      #   @param scope [Symbol] `:example`, `:context`, or `:suite`
      #     (defaults to `:example`)
      #   @param conditions [Array<Symbol>, Hash] constrains this hook to
      #     examples matching these conditions e.g.
      #     `before(:example, :ui => true) { ... }` will only run with examples
      #     or groups declared with `:ui => true`. Symbols will be transformed
      #     into hash entries with `true` values.
      # @overload before(conditions, &block)
      #   @param conditions [Hash]
      #     constrains this hook to examples matching these conditions e.g.
      #     `before(:example, :ui => true) { ... }` will only run with examples
      #     or groups declared with `:ui => true`.
      #
      # @see #after
      # @see #around
      # @see ExampleGroup
      # @see SharedContext
      # @see SharedExampleGroup
      # @see Configuration
      #
      # Declare a block of code to be run before each example (using `:example`)
      # or once before any example (using `:context`). These are usually
      # declared directly in the {ExampleGroup} to which they apply, but they
      # can also be shared across multiple groups.
      #
      # You can also use `before(:suite)` to run a block of code before any
      # example groups are run. This should be declared in {RSpec.configure}.
      #
      # Instance variables declared in `before(:example)` or `before(:context)`
      # are accessible within each example.
      #
      # ### Order
      #
      # `before` hooks are stored in three scopes, which are run in order:
      # `:suite`, `:context`, and `:example`. They can also be declared in
      # several different places: `RSpec.configure`, a parent group, the current
      # group. They are run in the following order:
      #
      #     before(:suite)    # Declared in RSpec.configure.
      #     before(:context)  # Declared in RSpec.configure.
      #     before(:context)  # Declared in a parent group.
      #     before(:context)  # Declared in the current group.
      #     before(:example)  # Declared in RSpec.configure.
      #     before(:example)  # Declared in a parent group.
      #     before(:example)  # Declared in the current group.
      #
      # If more than one `before` is declared within any one example group, they
      # are run in the order in which they are declared. Any `around` hooks will
      # execute after `before` context hooks but before any `before` example
      # hook regardless of where they are declared.
      #
      # ### Conditions
      #
      # When you add a conditions hash to `before(:example)` or
      # `before(:context)`, RSpec will only apply that hook to groups or
      # examples that match the conditions. e.g.
      #
      #     RSpec.configure do |config|
      #       config.before(:example, :authorized => true) do
      #         log_in_as :authorized_user
      #       end
      #     end
      #
      #     RSpec.describe Something, :authorized => true do
      #       # The before hook will run in before each example in this group.
      #     end
      #
      #     RSpec.describe SomethingElse do
      #       it "does something", :authorized => true do
      #         # The before hook will run before this example.
      #       end
      #
      #       it "does something else" do
      #         # The hook will not run before this example.
      #       end
      #     end
      #
      # Note that filtered config `:context` hooks can still be applied
      # to individual examples that have matching metadata. Just like
      # Ruby's object model is that every object has a singleton class
      # which has only a single instance, RSpec's model is that every
      # example has a singleton example group containing just the one
      # example.
      #
      # ### Warning: `before(:suite, :with => :conditions)`
      #
      # The conditions hash is used to match against specific examples. Since
      # `before(:suite)` is not run in relation to any specific example or
      # group, conditions passed along with `:suite` are effectively ignored.
      #
      # ### Exceptions
      #
      # When an exception is raised in a `before` block, RSpec skips any
      # subsequent `before` blocks and the example, but runs all of the
      # `after(:example)` and `after(:context)` hooks.
      #
      # ### Warning: implicit before blocks
      #
      # `before` hooks can also be declared in shared contexts which get
      # included implicitly either by you or by extension libraries. Since
      # RSpec runs these in the order in which they are declared within each
      # scope, load order matters, and can lead to confusing results when one
      # before block depends on state that is prepared in another before block
      # that gets run later.
      #
      # ### Warning: `before(:context)`
      #
      # It is very tempting to use `before(:context)` to speed things up, but we
      # recommend that you avoid this as there are a number of gotchas, as well
      # as things that simply don't work.
      #
      # #### Context
      #
      # `before(:context)` is run in an example that is generated to provide
      # group context for the block.
      #
      # #### Instance variables
      #
      # Instance variables declared in `before(:context)` are shared across all
      # the examples in the group. This means that each example can change the
      # state of a shared object, resulting in an ordering dependency that can
      # make it difficult to reason about failures.
      #
      # #### Unsupported RSpec constructs
      #
      # RSpec has several constructs that reset state between each example
      # automatically. These are not intended for use from within
      # `before(:context)`:
      #
      #   * `let` declarations
      #   * `subject` declarations
      #   * Any mocking, stubbing or test double declaration
      #
      # ### other frameworks
      #
      # Mock object frameworks and database transaction managers (like
      # ActiveRecord) are typically designed around the idea of setting up
      # before an example, running that one example, and then tearing down. This
      # means that mocks and stubs can (sometimes) be declared in
      # `before(:context)`, but get torn down before the first real example is
      # ever run.
      #
      # You _can_ create database-backed model objects in a `before(:context)`
      # in rspec-rails, but it will not be wrapped in a transaction for you, so
      # you are on your own to clean up in an `after(:context)` block.
      #
      # @example before(:example) declared in an {ExampleGroup}
      #
      #     RSpec.describe Thing do
      #       before(:example) do
      #         @thing = Thing.new
      #       end
      #
      #       it "does something" do
      #         # Here you can access @thing.
      #       end
      #     end
      #
      # @example before(:context) declared in an {ExampleGroup}
      #
      #     RSpec.describe Parser do
      #       before(:context) do
      #         File.open(file_to_parse, 'w') do |f|
      #           f.write <<-CONTENT
      #             stuff in the file
      #           CONTENT
      #         end
      #       end
      #
      #       it "parses the file" do
      #         Parser.parse(file_to_parse)
      #       end
      #
      #       after(:context) do
      #         File.delete(file_to_parse)
      #       end
      #     end
      #
      # @note The `:example` and `:context` scopes are also available as
      #       `:each` and `:all`, respectively. Use whichever you prefer.
      # @note The `:suite` scope is only supported for hooks registered on
      #       `RSpec.configuration` since they exist independently of any
      #       example or example group.
      def before: (*untyped args) { () -> untyped } -> untyped

      alias append_before before

      # Adds `block` to the front of the list of `before` blocks in the same
      # scope (`:example`, `:context`, or `:suite`).
      #
      # See {#before} for scoping semantics.
      def prepend_before: (*untyped args) { () -> untyped } -> untyped

      # @api public
      # @overload after(&block)
      # @overload after(scope, &block)
      #   @param scope [Symbol] `:example`, `:context`, or `:suite` (defaults to
      #     `:example`)
      # @overload after(scope, *conditions, &block)
      #   @param scope [Symbol] `:example`, `:context`, or `:suite` (defaults to
      #     `:example`)
      #   @param conditions [Array<Symbol>, Hash] constrains this hook to
      #     examples matching these conditions e.g.
      #     `after(:example, :ui => true) { ... }` will only run with examples
      #     or groups declared with `:ui => true`. Symbols will be transformed
      #     into hash entries with `true` values.
      # @overload after(conditions, &block)
      #   @param conditions [Hash]
      #     constrains this hook to examples matching these conditions e.g.
      #     `after(:example, :ui => true) { ... }` will only run with examples
      #     or groups declared with `:ui => true`.
      #
      # @see #before
      # @see #around
      # @see ExampleGroup
      # @see SharedContext
      # @see SharedExampleGroup
      # @see Configuration
      #
      # Declare a block of code to be run after each example (using `:example`)
      # or once after all examples n the context (using `:context`). See
      # {#before} for more information about ordering.
      #
      # ### Exceptions
      #
      # `after` hooks are guaranteed to run even when there are exceptions in
      # `before` hooks or examples. When an exception is raised in an after
      # block, the exception is captured for later reporting, and subsequent
      # `after` blocks are run.
      #
      # ### Order
      #
      # `after` hooks are stored in three scopes, which are run in order:
      # `:example`, `:context`, and `:suite`. They can also be declared in
      # several different places: `RSpec.configure`, a parent group, the current
      # group. They are run in the following order:
      #
      #     after(:example) # Declared in the current group.
      #     after(:example) # Declared in a parent group.
      #     after(:example) # Declared in RSpec.configure.
      #     after(:context) # Declared in the current group.
      #     after(:context) # Declared in a parent group.
      #     after(:context) # Declared in RSpec.configure.
      #     after(:suite)   # Declared in RSpec.configure.
      #
      # This is the reverse of the order in which `before` hooks are run.
      # Similarly, if more than one `after` is declared within any example
      # group, they are run in reverse order of that in which they are declared.
      # Also `around` hooks will run after any `after` example hooks are
      # invoked but before any `after` context hooks.
      #
      # @note The `:example` and `:context` scopes are also available as
      #       `:each` and `:all`, respectively. Use whichever you prefer.
      # @note The `:suite` scope is only supported for hooks registered on
      #       `RSpec.configuration` since they exist independently of any
      #       example or example group.
      def after: (*untyped args) { () -> untyped } -> untyped

      alias prepend_after after

      # Adds `block` to the back of the list of `after` blocks in the same
      # scope (`:example`, `:context`, or `:suite`).
      #
      # See {#after} for scoping semantics.
      def append_after: (*untyped args) { () -> untyped } -> untyped

      # @api public
      # @overload around(&block)
      # @overload around(scope, &block)
      #   @param scope [Symbol] `:example` (defaults to `:example`)
      #     present for syntax parity with `before` and `after`, but
      #     `:example`/`:each` is the only supported value.
      # @overload around(scope, *conditions, &block)
      #   @param scope [Symbol] `:example` (defaults to `:example`)
      #     present for syntax parity with `before` and `after`, but
      #     `:example`/`:each` is the only supported value.
      #   @param conditions [Array<Symbol>, Hash] constrains this hook to
      #     examples matching these conditions e.g.
      #     `around(:example, :ui => true) { ... }` will only run with examples
      #     or groups declared with `:ui => true`. Symbols will be transformed
      #     into hash entries with `true` values.
      # @overload around(conditions, &block)
      #   @param conditions [Hash] constrains this hook to examples matching
      #     these conditions e.g. `around(:example, :ui => true) { ... }` will
      #     only run with examples or groups declared with `:ui => true`.
      #
      # @yield [Example] the example to run
      #
      # @note the syntax of `around` is similar to that of `before` and `after`
      #   but the semantics are quite different. `before` and `after` hooks are
      #   run in the context of the examples with which they are associated,
      #   whereas `around` hooks are actually responsible for running the
      #   examples. Consequently, `around` hooks do not have direct access to
      #   resources that are made available within the examples and their
      #   associated `before` and `after` hooks.
      #
      # @note `:example`/`:each` is the only supported scope.
      #
      # Declare a block of code, parts of which will be run before and parts
      # after the example. It is your responsibility to run the example:
      #
      #     around(:example) do |ex|
      #       # Do some stuff before.
      #       ex.run
      #       # Do some stuff after.
      #     end
      #
      # The yielded example aliases `run` with `call`, which lets you treat it
      # like a `Proc`. This is especially handy when working with libraries
      # that manage their own setup and teardown using a block or proc syntax,
      # e.g.
      #
      #     around(:example) {|ex| Database.transaction(&ex)}
      #     around(:example) {|ex| FakeFS(&ex)}
      #
      # ### Order
      #
      # The `around` hooks execute surrounding an example and its hooks.
      #
      # This means after any `before` context hooks, but before any `before`
      # example hooks, and similarly after any `after` example hooks but before
      # any `after` context hooks.
      #
      # They are not a synonym for `before`/`after`.
      def around: (*untyped args) { () -> untyped } -> untyped

      # @private
      # Holds the various registered hooks.
      def hooks: () -> untyped

      # @private
      Hook: untyped

      # @private
      class BeforeHook # < Hook
        def run: (untyped example) -> untyped
      end

      # @private
      class AfterHook # < Hook
        def run: (untyped example) -> untyped
      end

      # @private
      class AfterContextHook # < Hook
        def run: (untyped example) -> untyped
      end

      # @private
      class AroundHook # < Hook
        def execute_with: (untyped example, untyped procsy) -> (nil | untyped)

        # def hook_description: () -> ::String

        # for 1.8.7
        # :nocov:
        def hook_description: () -> "around hook"
      end

      # @private
      #
      # This provides the primary API used by other parts of rspec-core. By hiding all
      # implementation details behind this facade, it's allowed us to heavily optimize
      # this, so that, for example, hook collection objects are only instantiated when
      # a hook is added. This allows us to avoid many object allocations for the common
      # case of a group having no hooks.
      #
      # This is only possible because this interface provides a "tell, don't ask"-style
      # API, so that callers _tell_ this class what to do with the hooks, rather than
      # asking this class for a list of hooks, and then doing something with them.
      class HookCollections
        def initialize: (untyped owner, untyped filterable_item_repo_class) -> void

        def register_globals: (untyped host, untyped globals) -> untyped

        def register_global_singleton_context_hooks: (untyped example, untyped globals) -> untyped

        def register: (untyped prepend_or_append, untyped position, *untyped args) { () -> untyped } -> (nil | untyped)

        # @private
        #
        # Runs all of the blocks stored with the hook in the context of the
        # example. If no example is provided, just calls the hook directly.
        def run: (untyped position, untyped scope, untyped example_or_group) { () -> untyped } -> (nil | untyped)

        SCOPES: ::Array[:example | :context]

        SCOPE_ALIASES: { each: :example, all: :context }

        HOOK_TYPES: { before: untyped, after: untyped, around: untyped }

        EMPTY_HOOK_ARRAY: ::Array[untyped]

        def matching_hooks_for: (untyped position, untyped scope, untyped example_or_group) -> untyped

        def all_hooks_for: (untyped position, untyped scope) -> untyped

        def run_owned_hooks_for: (untyped position, untyped scope, untyped example_or_group) -> untyped

        def processable_hooks_for: (untyped position, untyped scope, untyped host) -> untyped

        private

        def hooks_for: (untyped position, untyped scope) { () -> untyped } -> untyped

        def ensure_hooks_initialized_for: (untyped position, untyped scope) -> untyped

        def process: (untyped host, untyped parent_groups, untyped globals, untyped position, untyped scope) { (untyped) -> untyped } -> (nil | untyped)

        def scope_and_options_from: (*untyped args) -> (:suite | untyped)

        def extract_scope_from: (untyped args) -> untyped

        def known_scope?: (untyped scope) -> untyped

        def normalized_scope_for: (untyped scope) -> untyped

        def run_example_hooks_for: (untyped example, untyped position, untyped each_method) -> untyped

        def run_around_example_hooks_for: (untyped example) { () -> untyped } -> untyped

        def owner_parent_groups: () -> untyped
      end
    end
  end
end

module RSpec
  module Core
    # DSL defines methods to group examples, most notably `describe`,
    # and exposes them as class methods of {RSpec}. They can also be
    # exposed globally (on `main` and instances of `Module`) through
    # the {Configuration} option `expose_dsl_globally`.
    #
    # By default the methods `describe`, `context` and `example_group`
    # are exposed. These methods define a named context for one or
    # more examples. The given block is evaluated in the context of
    # a generated subclass of {RSpec::Core::ExampleGroup}.
    #
    # ## Examples:
    #
    #     RSpec.describe "something" do
    #       context "when something is a certain way" do
    #         it "does something" do
    #           # example code goes here
    #         end
    #       end
    #     end
    #
    # @see ExampleGroup
    # @see ExampleGroup.example_group
    module DSL
      # @private
      def self.example_group_aliases: () -> untyped

      # @private
      def self.exposed_globally?: () -> untyped

      # @private
      def self.expose_example_group_alias: (untyped name) -> (nil | untyped)

      # @private
      attr_accessor self.top_level: untyped

      # Adds the describe method to Module and the top level binding.
      # @api private
      def self.expose_globally!: () -> (nil | untyped)

      # Removes the describe method from Module and the top level binding.
      # @api private
      def self.remove_globally!: () -> (nil | untyped)

      # @private
      def self.expose_example_group_alias_globally: (untyped method_name) -> untyped

      # @private
      def self.change_global_dsl: () { () -> untyped } -> untyped
    end
  end
end

module RSpec
  module Core
    # Provides the main entry point to run a suite of RSpec examples.
    class Runner
      # @attr_reader
      # @private
      attr_reader options: untyped

      # @attr_reader
      # @private
      attr_reader configuration: untyped

      # @attr_reader
      # @private
      attr_reader world: untyped

      # Register an `at_exit` hook that runs the suite when the process exits.
      #
      # @note This is not generally needed. The `rspec` command takes care
      #       of running examples for you without involving an `at_exit`
      #       hook. This is only needed if you are running specs using
      #       the `ruby` command, and even then, the normal way to invoke
      #       this is by requiring `rspec/autorun`.
      def self.autorun: () -> (nil | untyped)

      # @private
      def self.perform_at_exit: () -> (nil | untyped)

      # Runs the suite of specs and exits the process with an appropriate exit
      # code.
      def self.invoke: () -> untyped

      # Run a suite of RSpec examples. Does not exit.
      #
      # This is used internally by RSpec to run a suite, but is available
      # for use by any other automation tool.
      #
      # If you want to run this multiple times in the same process, and you
      # want files like `spec_helper.rb` to be reloaded, be sure to load `load`
      # instead of `require`.
      #
      # @param args [Array] command-line-supported arguments
      # @param err [IO] error stream
      # @param out [IO] output stream
      # @return [Fixnum] exit status code. 0 if all specs passed,
      #   or the configured failure exit code (1 by default) if specs
      #   failed.
      def self.run: (untyped args, ?untyped err, ?untyped `out`) -> untyped

      def initialize: (untyped options, ?untyped configuration, ?untyped world) -> void

      # Configures and runs a spec suite.
      #
      # @param err [IO] error stream
      # @param out [IO] output stream
      def run: (untyped err, untyped `out`) -> untyped

      # Wires together the various configuration objects and state holders.
      #
      # @param err [IO] error stream
      # @param out [IO] output stream
      def setup: (untyped err, untyped `out`) -> untyped

      # Runs the provided example groups.
      #
      # @param example_groups [Array<RSpec::Core::ExampleGroup>] groups to run
      # @return [Fixnum] exit status code. 0 if all specs passed,
      #   or the configured failure exit code (1 by default) if specs
      #   failed.
      def run_specs: (untyped example_groups) -> untyped

      # @private
      def configure: (untyped err, untyped `out`) -> untyped

      # @private
      def self.disable_autorun!: () -> untyped

      # @private
      def self.autorun_disabled?: () -> untyped

      # @private
      def self.installed_at_exit?: () -> untyped

      # @private
      def self.running_in_drb?: () -> (false | untyped)

      # @private
      def self.trap_interrupt: () -> untyped

      # @private
      def self.handle_interrupt: () -> untyped

      # @private
      def exit_code: (?bool examples_passed) -> (untyped | 0)

      private

      def persist_example_statuses: () -> untyped
    end
  end
end

module RSpec
  module Core
    # @api private
    #
    # Internal container for global non-configuration data.
    class World
      # @private
      attr_reader example_groups: untyped

      # @private
      attr_reader filtered_examples: untyped

      # @private
      attr_reader example_group_counts_by_spec_file: untyped

      # Used internally to determine what to do when a SIGINT is received.
      attr_accessor wants_to_quit: untyped

      # Used internally to signify that a SystemExit occurred in
      # `Configuration#load_file_handling_errors`, and thus examples cannot
      # be counted accurately. Specifically, we cannot accurately report
      # "No examples found".
      # @private
      attr_accessor rspec_is_quitting: untyped

      # Used internally to signal that a failure outside of an example
      # has occurred, and that therefore the exit status should indicate
      # the run failed.
      # @private
      attr_accessor non_example_failure: untyped

      def initialize: (?untyped configuration) -> void

      # @api public
      #
      # Prepares filters so that they apply to example groups when they run.
      #
      # This is a separate method so that filters can be modified/replaced and
      # examples refiltered during a process's lifetime, which can be useful for
      # a custom runner.
      def prepare_example_filtering: () -> untyped

      # @api private
      #
      # Apply ordering strategy from configuration to example groups.
      def ordered_example_groups: () -> untyped

      # @api private
      #
      # Reset world to 'scratch' before running suite.
      def reset: () -> untyped

      # @private
      def filter_manager: () -> untyped

      # @private
      def registered_example_group_files: () -> untyped

      # @api private
      #
      # Records an example group.
      def record: (untyped example_group) -> untyped

      # @private
      def num_example_groups_defined_in: (untyped file) -> untyped

      # @private
      def shared_example_group_registry: () -> untyped

      # @private
      def inclusion_filter: () -> untyped

      # @private
      def exclusion_filter: () -> untyped

      # @api private
      #
      # Get count of examples to be run.
      def example_count: (?untyped groups) -> untyped

      # @private
      def all_example_groups: () -> untyped

      # @private
      def all_examples: () -> untyped

      # @private
      # Traverses the tree of each top level group.
      # For each it yields the group, then the children, recursively.
      # Halts the traversal of a branch of the tree as soon as the passed block returns true.
      # Note that siblings groups and their sub-trees will continue to be explored.
      # This is intended to make it easy to find the top-most group that satisfies some
      # condition.
      def traverse_example_group_trees_until: () { () -> untyped } -> untyped

      # @api private
      #
      # Find line number of previous declaration.
      def preceding_declaration_line: (untyped absolute_file_name, untyped filter_line) -> (nil | untyped)

      # @private
      def reporter: () -> untyped

      # @private
      def source_from_file: (untyped path) -> untyped

      # @private
      def syntax_highlighter: () -> untyped

      # @api private
      #
      # Notify reporter of filters.
      def announce_filters: () -> (nil | untyped)

      # @private
      def report_filter_message: (untyped message) -> untyped

      # @private
      def everything_filtered_message: () -> ::String

      # @api private
      #
      # Add inclusion filters to announcement message.
      def announce_inclusion_filter: (untyped announcements) -> (nil | untyped)

      # @api private
      #
      # Add exclusion filters to announcement message.
      def announce_exclusion_filter: (untyped announcements) -> (nil | untyped)

      private

      def descending_declaration_line_numbers_by_file: () -> untyped

      def fail_if_config_and_cli_options_invalid: () -> (nil | untyped)

      # @private
      # Provides a null implementation for initial use by configuration.
      module Null
        def self.non_example_failure: () -> nil

        def self.non_example_failure=: (untyped _) -> nil

        def self.registered_example_group_files: () -> ::Array[untyped]

        def self.traverse_example_group_trees_until: () -> nil

        # :nocov:
        def self.example_groups: () -> ::Array[untyped]

        def self.all_example_groups: () -> ::Array[untyped]
      end
    end
  end
end

# Namespace for all core RSpec code.
module RSpec
  extend RSpec::Core::Warnings

  # Setters for shared global objects
  # @api private
  attr_writer self.configuration: untyped

  # Setters for shared global objects
  # @api private
  attr_writer self.world: untyped

  # Used to ensure examples get reloaded and user configuration gets reset to
  # defaults between multiple runs in the same process.
  #
  # Users must invoke this if they want to have the configuration reset when
  # they use the runner multiple times within the same process. Users must deal
  # themselves with re-configuration of RSpec before run.
  def self.reset: () -> untyped

  # Used to ensure examples get reloaded between multiple runs in the same
  # process and ensures user configuration is persisted.
  #
  # Users must invoke this if they want to clear all examples but preserve
  # current configuration when they use the runner multiple times within the
  # same process.
  def self.clear_examples: () -> untyped

  # Returns the global [Configuration](RSpec/Core/Configuration) object. While
  # you _can_ use this method to access the configuration, the more common
  # convention is to use [RSpec.configure](RSpec#configure-class_method).
  #
  # @example
  #     RSpec.configuration.drb_port = 1234
  # @see RSpec.configure
  # @see Core::Configuration
  def self.configuration: () -> untyped

  # Yields the global configuration to a block.
  # @yield [Configuration] global configuration
  #
  # @example
  #     RSpec.configure do |config|
  #       config.add_formatter 'documentation'
  #     end
  # @see Core::Configuration
  def self.configure: () { (untyped) -> untyped } -> untyped

  # The example being executed.
  #
  # The primary audience for this method is library authors who need access
  # to the example currently being executed and also want to support all
  # versions of RSpec 2 and 3.
  #
  # @example
  #
  #     RSpec.configure do |c|
  #       # context.example is deprecated, but RSpec.current_example is not
  #       # available until RSpec 3.0.
  #       fetch_current_example = RSpec.respond_to?(:current_example) ?
  #         proc { RSpec.current_example } : proc { |context| context.example }
  #
  #       c.before(:example) do
  #         example = fetch_current_example.call(self)
  #
  #         # ...
  #       end
  #     end
  #
  def self.current_example: () -> untyped

  # Set the current example being executed.
  # @api private
  def self.current_example=: (untyped example) -> untyped

  # Set the current scope rspec is executing in
  # @api private
  def self.current_scope=: (untyped scope) -> untyped

  # Get the current RSpec execution scope
  #
  # Returns (in order of lifecycle):
  #   * `:suite` as an initial value, this is outside of the test lifecycle.
  #   * `:before_suite_hook` during `before(:suite)` hooks.
  #   * `:before_context_hook` during `before(:context)` hooks.
  #   * `:before_example_hook` during `before(:example)` hooks and `around(:example)` before `example.run`.
  #   * `:example` within the example run.
  #   * `:after_example_hook` during `after(:example)` hooks and `around(:example)` after `example.run`.
  #   * `:after_context_hook` during `after(:context)` hooks.
  #   * `:after_suite_hook` during `after(:suite)` hooks.
  #   * `:suite` as a final value, again this is outside of the test lifecycle.
  #
  # Reminder, `:context` hooks have `:all` alias and `:example` hooks have `:each` alias.
  # @return [Symbol]
  def self.current_scope: () -> untyped

  # @private
  # Internal container for global non-configuration data.
  def self.world: () -> untyped

  # Namespace for the rspec-core code.
  module Core
    # @private
    # This avoids issues with reporting time caused by examples that
    # change the value/meaning of Time.now without properly restoring
    # it.
    class Time
    end

    # @private path to executable file.
    def self.path_to_executable: () -> untyped
  end

  # @private
  MODULES_TO_AUTOLOAD: { Matchers: "rspec/expectations", Expectations: "rspec/expectations", Mocks: "rspec/mocks" }

  # @private
  def self.const_missing: (untyped name) -> untyped
end


